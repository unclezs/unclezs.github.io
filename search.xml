<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>打造好用的PowerShell媲美oh-my-zsh</title>
    <url>/%E7%8E%A9%E6%9C%BA/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/%E6%89%93%E9%80%A0%E5%A5%BD%E7%94%A8%E7%9A%84PowerShell%E5%AA%B2%E7%BE%8Eoh-my-zsh.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>windows下面的CMD控制台很难用，也很丑，但是wndows后面出了个powershell，用着还是不错，但是还是丑，并且有些功能高效功能不具备，比如git分支显示，历史命令提示。</p>
<p>在windows下用了oh-my-zsh后，用着十分的舒服。所以在windows上寻找了一样的结局方案。利用powershell7打造属于windows的强劲终端</p>
<p>先上个效果图：</p>
<ol>
<li>Git分支显示</li>
<li>历史命令提示</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210102140236.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210102140236.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210102125012.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210102125012.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="终端选择"><a href="#终端选择" class="headerlink" title="终端选择"></a>终端选择</h2><ul>
<li><a href="https://github.com/felixse/FluentTerminal">Fluent Terminate</a>(我的选择)</li>
<li><a href="https://github.com/Eugeny/terminus">Terminus</a></li>
<li>Windows Terminal (微软应用商店)</li>
<li>…</li>
</ul>
<p>其实windows自带的也是可以的，不过用着总是不算那么舒服</p>
<h2 id="下载Powershell7"><a href="#下载Powershell7" class="headerlink" title="下载Powershell7"></a>下载Powershell7</h2><p>去 <a href="https://github.com/PowerShell/PowerShell/releases">PowerShell Release Page</a> 下载安装即可</p>
<h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>本节就来改造下 PowerShell（以下简称 Posh）。</p>
<h3 id="字体安装"><a href="#字体安装" class="headerlink" title="字体安装"></a>字体安装</h3><p>需要配置PowerLine字体来显示一些特殊字符</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">clone</span></span>
git clone https://github.com/powerline/fonts.git --depth=1
<span class="hljs-meta">#</span><span class="bash"> install</span>
cd fonts
./install.sh
<span class="hljs-meta">#</span><span class="bash"> clean-up a bit</span>
cd ..
rm -rf fonts</code></pre>
<p>再将终端字体设置为 Meslo LG S DZ for PowerLine</p>
<h3 id="oh-my-posh"><a href="#oh-my-posh" class="headerlink" title="oh-my-posh"></a>oh-my-posh</h3><p>zsh 下有 oh-my-zsh，Posh 下也有 oh-my-posh 可以做到和 oh-my-zsh 一样的外观。</p>
<pre><code class="hljs shell">Install-Module posh-git -Scope CurrentUser
Install-Module oh-my-posh -Scope CurrentUser
Install-Module posh-docker -Scope CurrentUser</code></pre>

<p>安装完后，我们还需要配置下 Posh 才能使其变成 oh-my-zsh 的样子。</p>
<p>首先在 Posh 中输入 $profile 并回车，Posh 会输出你当前使用的 Profile 文件地址，打开该文件（若没有就需要新建），在该文件中写入以下内容。</p>
<p>或者直接使用：</p>
<pre><code class="hljs shell">notepad $profile</code></pre>
<p>编辑保存</p>
<p>写入：</p>
<pre><code class="hljs shell">Import-Module posh-git
Import-Module oh-my-posh
Set-Theme Paradox
<span class="hljs-meta">#</span><span class="bash"> 单行显示，但是在我的IDEA下显示有问题 自测</span>
<span class="hljs-meta">#</span><span class="bash">Set-Theme Agnoster</span></code></pre>

<p>保存之后重启posh即可看到效果</p>
<h3 id="命令提示"><a href="#命令提示" class="headerlink" title="命令提示"></a>命令提示</h3><p>通过<a href="https://github.com/PowerShell/PSReadLine">PSReadLine</a>实现zsh-autosuggestions插件的功能。</p>
<p>安装：</p>
<pre><code class="hljs shell">Install-Module -Name PowerShellGet -Force</code></pre>

<p>在主题配置文件后加入</p>
<pre><code class="hljs shell">Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录
 
Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全
Set-PSReadLineKeyHandler -Key &quot;Ctrl+d&quot; -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 Intellisense
Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销
Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录
Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录</code></pre>
<p>即可看到最开始简介时候的效果</p>
<h3 id="配置Vim"><a href="#配置Vim" class="headerlink" title="配置Vim"></a>配置Vim</h3><ol>
<li>下载vim:  <a href="https://www.vim.org/download.php#pc">https://www.vim.org/download.php#pc</a></li>
<li>记住安装路径</li>
<li>编辑配置文件设置vim别名</li>
</ol>
<p>执行：</p>
<pre><code class="hljs shell">notepad $profile</code></pre>
<p>加入一行：</p>
<pre><code class="hljs shell">set-alias vim &quot;D:\Program Files\Vim\vim82\vim.exe&quot;</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210103155205.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103155205.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>也可以把notepad++配置一下更加方便的编辑</p>
<pre><code class="hljs shell">set-alias open &quot;C:\Program Files\Notepad++\notepad++.exe&quot;</code></pre>
<p>然后就可以通过open xx文件名打开文件了</p>
<h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">http_proxy = <span class="hljs-string">&quot;http://127.0.0.1:1080&quot;</span></span>
<span class="hljs-meta">$</span><span class="bash">socks5_proxy = <span class="hljs-string">&quot;socks5://127.0.0.1:1080&quot;</span></span>
<span class="hljs-meta">$</span><span class="bash">env:http_proxy=<span class="hljs-string">&quot;<span class="hljs-variable">$socks5_proxy</span>&quot;</span> </span>
<span class="hljs-meta">$</span><span class="bash">env:https_proxy=<span class="hljs-string">&quot;<span class="hljs-variable">$socks5_proxy</span>&quot;</span> </span></code></pre>

<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>具体查看：<a href="https://github.com/gerardog/gsudo">https://github.com/gerardog/gsudo</a></p>
<p>通过scoop安装：</p>
<pre><code class="hljs shell">scoop install gsudo</code></pre>
<p>安装之后就可以使用sudo了</p>
<h2 id="在Idea中配置"><a href="#在Idea中配置" class="headerlink" title="在Idea中配置"></a>在Idea中配置</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/20210102132631.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210102132631.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>填写自己PowerShell路径，加上nologo则不会打印开头的字体。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210102132745.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210102132745.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="在VsCode中配置"><a href="#在VsCode中配置" class="headerlink" title="在VsCode中配置"></a>在VsCode中配置</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/20210102132845.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210102132845.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>选择默认终端为powershell7</p>
<p>配置字体无logo文字</p>
<pre><code class="hljs json">&#123;
    <span class="hljs-attr">&quot;terminal.integrated.shell.windows&quot;</span>: <span class="hljs-string">&quot;C:\\Program Files\\PowerShell\\7\\pwsh.exe&quot;</span>,
    <span class="hljs-attr">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="hljs-string">&quot;Meslo LG S DZ for PowerLine&quot;</span>,
    <span class="hljs-attr">&quot;terminal.integrated.shellArgs.windows&quot;</span>: <span class="hljs-string">&quot; -nologo&quot;</span>,
&#125;</code></pre>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其实windows下还有wsl2，可以直接使用oh-my-zsh，但是我体验了一阵，发现如果在wsl2中编译windows下的文件十分缓慢，IO性能太差，不能日常，如果把项目放到wsl2中确实可以解决项目编译慢的问题，但是又会有其他一些问题，比如idea读取不到maven的子模块。坑就很多所以还是放弃了，也就偶尔用来使用windows环境了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.ixk.me/say-goodbye-to-the-ugly-and-hard-to-use-windows-terminal-and-build-a-good-powershell.html">告别 Windows 终端的难看难用，打造好用的 PowerShell</a></li>
</ul>
]]></content>
      <categories>
        <category>玩机</category>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>powershell</tag>
      </tags>
  </entry>
  <entry>
    <title>利用PhantomJs抓取动态网页</title>
    <url>/%E7%88%AC%E8%99%AB/%E5%88%A9%E7%94%A8PhantomJs%E6%8A%93%E5%8F%96%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PhantomJS是可使用JavaScript编写脚本的无头WebKit，我们可以用来做一些爬虫工作，网页截图等，不过目前项目已经被挂起。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>下载执行文件对应自己的操作系统，目前最新的是v2.11 <a href="https://phantomjs.org/download.html">下载地址</a></p>
<p>语法</p>
<pre><code class="hljs shell">phantomjs [options] script.js [arg1 [arg2 [...]]]</code></pre>

<p>编写脚本 hello.js</p>
<pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello phantomJS!&quot;</span>)
phantom.exit(<span class="hljs-number">0</span>)</code></pre>

<p>执行脚本</p>
<pre><code class="hljs shell">phantom hello.js</code></pre>

<p>输出</p>
<pre><code class="hljs plain">hello phantomJS!</code></pre>

<h2 id="抓取网页脚本"><a href="#抓取网页脚本" class="headerlink" title="抓取网页脚本"></a>抓取网页脚本</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> page = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpage&#x27;</span>).create();
page.open(<span class="hljs-string">&#x27;http://blog.unclezs.com&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (status !== <span class="hljs-string">&#x27;success&#x27;</span>) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;failed&#x27;</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">console</span>.log(page.content);
    &#125;
    phantom.exit();
&#125;);</code></pre>

<p>执行即可看到抓取到的html</p>
<h2 id="自定义请求头"><a href="#自定义请求头" class="headerlink" title="自定义请求头"></a>自定义请求头</h2><p>可以通过 <a href="http://httpbin.org/get">http://httpbin.org/get</a> 这个网站测试自己的请求内容</p>
<pre><code class="hljs js">page.customHeaders=&#123;
  <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#x27;</span>
&#125;</code></pre>

<h2 id="忽略SSL错误"><a href="#忽略SSL错误" class="headerlink" title="忽略SSL错误"></a>忽略SSL错误</h2><p>通过参数 –proxy=address:port 设置</p>
<p>比如 phantom –proxy=127.0.0.1:80 script.js</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>通过参数 –ignore-ssl-errors=[true|false|yes|no]  默认为false</p>
<p>比如 phantom –proxy=127.0.0.1:80 script.js</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>取消图片加载 –load-images=[true|false|yes|no] 默认true</p>
<h2 id="Java示例"><a href="#Java示例" class="headerlink" title="Java示例"></a>Java示例</h2><h3 id="Js脚本"><a href="#Js脚本" class="headerlink" title="Js脚本"></a>Js脚本</h3><pre><code class="hljs js"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * phantomjs 解析动态网页</span>
<span class="hljs-comment"> * 支持传入referer、cookie、useragent</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author </span>blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date   </span>2020-12-24</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@see    </span>https://phantomjs.org/api/</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> page = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpage&#x27;</span>).create();
<span class="hljs-keyword">var</span> system = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;system&#x27;</span>);

<span class="hljs-comment">// 只传入脚本名称 不传入参数不执行</span>
<span class="hljs-keyword">if</span> (system.args.length === <span class="hljs-number">1</span>) &#123;
    phantom.exit();
&#125;
<span class="hljs-comment">// 为了提升加载速度，不加载图片</span>
page.settings.loadImages = <span class="hljs-literal">false</span>;
<span class="hljs-comment">// 超过10秒放弃加载</span>
page.settings.resourceTimeout = <span class="hljs-number">10000</span>;
<span class="hljs-comment">// 忽略SSL错误</span>

<span class="hljs-comment">// 参数 需要按照顺序</span>
<span class="hljs-keyword">var</span> url = system.args[<span class="hljs-number">1</span>];
<span class="hljs-keyword">var</span> referer = system.args[<span class="hljs-number">2</span>];
<span class="hljs-keyword">var</span> cookie = system.args[<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> userAgent = system.args[<span class="hljs-number">4</span>];
<span class="hljs-keyword">var</span> customHeaders = &#123;
    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#x27;</span>,
    <span class="hljs-string">&#x27;Referer&#x27;</span>: url
&#125;;
<span class="hljs-keyword">if</span> (referer) &#123;
    customHeaders[<span class="hljs-string">&#x27;Referer&#x27;</span>] = referer;
&#125;
<span class="hljs-keyword">if</span> (cookie) &#123;
    customHeaders[<span class="hljs-string">&#x27;Cookie&#x27;</span>] = cookie;
&#125;
<span class="hljs-keyword">if</span> (userAgent) &#123;
    customHeaders[<span class="hljs-string">&#x27;User-Agent&#x27;</span>] = userAgent;
&#125;
page.customHeaders = customHeaders;
page.open(url, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (status === <span class="hljs-string">&#x27;success&#x27;</span>) &#123;
        <span class="hljs-built_in">console</span>.log(page.content);
    &#125;
    phantom.exit();
&#125;);</code></pre>

<h3 id="Java工具"><a href="#Java工具" class="headerlink" title="Java工具"></a>Java工具</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * https://phantomjs.org/api/</span>
<span class="hljs-comment"> * &lt;p&gt;</span>
<span class="hljs-comment"> * 首先 添加system properties PHANTOMJS_PATH、PHANTOMJS_SCRIPT</span>
<span class="hljs-comment"> * &lt;p&gt;</span>
<span class="hljs-comment"> * 不然会使用默认位置去读取</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/12/24 17:30</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomJsClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpProvider</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * PhantomJs执行文件的位置</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PHANTOMJS_PATH = <span class="hljs-string">&quot;PHANTOMJS_PATH&quot;</span>;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 脚本位置</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PHANTOMJS_SCRIPT = <span class="hljs-string">&quot;PHANTOMJS_SCRIPT_PATH&quot;</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PHANTOMJS_SCRIPT = FileUtil.USER_DIR + <span class="hljs-string">&quot;/script/spider.js&quot;</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PHANTOMJS_PATH =
        FileUtil.USER_DIR + <span class="hljs-string">&quot;/script/phantomjs&quot;</span> + SystemUtil.getExecuteSuffix();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 获取网页内容</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 请求数据</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> /</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">content</span><span class="hljs-params">(RequestData data)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        <span class="hljs-keyword">return</span> executePhantomJs(PhantomJsRequestData.from(data));
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">stream</span><span class="hljs-params">(RequestData requestData)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedEncodingException(<span class="hljs-string">&quot;PhantomJs动态网页HTTP客户端不支持获取流&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDynamic</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">content</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        <span class="hljs-keyword">return</span> content(RequestData.defaultRequestData(url));
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 执行PhantomJs脚本抓取动态网页</span>
<span class="hljs-comment">     * phantomjs [options] script.js [arg1 [arg2 [...]]]</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 请求数据</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">executePhantomJs</span><span class="hljs-params">(PhantomJsRequestData data)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        <span class="hljs-keyword">if</span> (StringUtil.isEmpty(data.getUrl())) &#123;
            log.warn(<span class="hljs-string">&quot;phantomJS request url 不能为空&quot;</span>);
            <span class="hljs-keyword">return</span> StringUtil.EMPTY;
        &#125;
        StringBuilder command = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-comment">// phantomJs</span>
        command.append(System.getProperty(PHANTOMJS_PATH, DEFAULT_PHANTOMJS_PATH));
        <span class="hljs-comment">// 忽略SSL错误</span>
        command.append(StringUtil.BLANK).append(<span class="hljs-string">&quot;--ignore-ssl-errors=&quot;</span>).append(data.isIgnoreSslError());
        <span class="hljs-comment">// 不加载图片</span>
        command.append(StringUtil.BLANK).append(<span class="hljs-string">&quot;--load-images=&quot;</span>).append(data.isLoadImg());
        <span class="hljs-comment">// HTTP代理</span>
        <span class="hljs-keyword">if</span> (StringUtil.isNotEmpty(data.getProxy())) &#123;
            command.append(StringUtil.BLANK).append(<span class="hljs-string">&quot;--proxy=&quot;</span>).append(data.getProxy());
        &#125;
        <span class="hljs-comment">// script</span>
        command.append(StringUtil.BLANK).append(System.getProperty(PHANTOMJS_SCRIPT, DEFAULT_PHANTOMJS_SCRIPT));
        <span class="hljs-comment">// args</span>
        command.append(StringUtil.BLANK).append(data.getUrl());
        command.append(StringUtil.BLANK).append(data.getReferer());
        command.append(StringUtil.BLANK).append(data.getCookie());
        command.append(StringUtil.BLANK).append(data.getUserAgent());
        <span class="hljs-keyword">return</span> CommandUtil.execute(command.toString());
    &#125;
&#125;


<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 执行CMD命令工具</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhanghongguo@sensorsdata.cn</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/12/25 11:09</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@UtilityClass</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandUtil</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 执行CMD命令</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command 命令</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 控制台数据</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">execute</span><span class="hljs-params">(String command)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        StringBuilder buffer = <span class="hljs-keyword">new</span> StringBuilder();
        log.trace(<span class="hljs-string">&quot;执行Command - 命令：&#123;&#125;&quot;</span>, command);
        Process process = Runtime.getRuntime().exec(command);
        InputStream is = process.getInputStream();
        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is));
        String tmp;
        <span class="hljs-keyword">while</span> ((tmp = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;
            buffer.append(tmp).append(StringUtil.NEW_LINE);
        &#125;
        <span class="hljs-keyword">return</span> buffer.toString();
    &#125;
&#125;</code></pre>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://phantomjs.org/api/">官方文档</a></p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>PhantomJs</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的摘要算法MessageDigest</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E7%9A%84%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95MessageDigest.html</url>
    <content><![CDATA[<h2 id="MessageDigest"><a href="#MessageDigest" class="headerlink" title="MessageDigest"></a>MessageDigest</h2><p>Java的摘要算法在java.security包下MessageDigest，通过SPI加载更多的摘要算法，这个包还提供了一些Java的权限检查，这里提一下摘要算法，用可以配合Base64或者Hex转化组合进行加密。<br>可以有MD2、MD5、SHA-224、SHA-256、SHA-384、SHA-512等等</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Java的摘要算法</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> unclezs</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/12/19 14:48</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageDigestSample</span> </span>&#123;
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * 常用的摘要算法</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIGEST_MD2 = <span class="hljs-string">&quot;MD2&quot;</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIGEST_MD5 = <span class="hljs-string">&quot;MD5&quot;</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIGEST_SHA = <span class="hljs-string">&quot;SHA&quot;</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIGEST_SHA_224 = <span class="hljs-string">&quot;SHA-224&quot;</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIGEST_SHA_256 = <span class="hljs-string">&quot;SHA-256&quot;</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIGEST_SHA_384 = <span class="hljs-string">&quot;SHA-384&quot;</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIGEST_SHA_512 = <span class="hljs-string">&quot;SHA-512&quot;</span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    String[] algorithms =
        &#123;DIGEST_MD2, DIGEST_MD5, DIGEST_SHA, DIGEST_SHA_224, DIGEST_SHA_256, DIGEST_SHA_384, DIGEST_SHA_512&#125;;
    <span class="hljs-keyword">for</span> (String algorithm : algorithms) &#123;
      <span class="hljs-keyword">try</span> &#123;
        String original = <span class="hljs-string">&quot;original&quot;</span>;
        String salt = <span class="hljs-string">&quot;salt&quot;</span>;
        MessageDigest digest = MessageDigest.getInstance(algorithm);
        digest.reset();
        digest.update(salt.getBytes(StandardCharsets.UTF_8));
        <span class="hljs-keyword">byte</span>[] hashed = digest.digest(original.getBytes());
        log.info(<span class="hljs-string">&quot;&#123;&#125;生成的摘要：&#123;&#125;&quot;</span>, algorithm, Arrays.toString(hashed));
      &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;
        log.error(<span class="hljs-string">&quot;摘要算法不存在:&#123;&#125;&quot;</span>, algorithm, e);
      &#125;
    &#125;
  &#125;
&#125;</code></pre>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><img src="https://gitee.com/unclezs/image-blog/raw/master///20201219154626.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201219154626.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="HMac"><a href="#HMac" class="headerlink" title="HMac"></a>HMac</h2><p>HMAC（Hash-based Message Authentication Code，散列消息认证码）是一种使用密码散列函数，同时结合一个加密密钥，通过特别计算方式之后产生的消息认证码（MAC）。它可以用来保证数据的完整性，同时可以用来作某个消息的身份验证。<br>HMAC算法 是一种基于密钥的报文完整性的验证方法。HMAC算法利用哈希运算，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。其安全性是建立在Hash加密算法基础上的。它要求通信双方共享密钥、约定算法、对报文进行Hash运算，形成固定长度的认证码。通信双方通过认证码的校验来确定报文的合法性。HMAC算法可以用来作加密、数字签名、报文验证等。</p>
<p>在javax.crypto包下提供了实现</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * HmacSha256算法加密</span>
<span class="hljs-comment"> * https://blog.csdn.net/sdnyqfyqf/article/details/105534376</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> unclezs</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/12/19 16:33</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HmacSample</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    log.info(<span class="hljs-string">&quot;HmacSHA256 加密后：&#123;&#125;&quot;</span>,byHmacSha256(<span class="hljs-string">&quot;salt&quot;</span>, <span class="hljs-string">&quot;unclezs&quot;</span>));
  &#125;

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] byHmacSha256(String salt, String original) &#123;
    String hmacSha256 = <span class="hljs-string">&quot;HmacSHA256&quot;</span>;
    <span class="hljs-keyword">try</span> &#123;
      Mac mac = Mac.getInstance(hmacSha256);
      SecretKey key = <span class="hljs-keyword">new</span> SecretKeySpec(salt.getBytes(StandardCharsets.UTF_8), hmacSha256);
      mac.init(key);
      <span class="hljs-keyword">return</span> mac.doFinal(original.getBytes(StandardCharsets.UTF_8));
    &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;
      log.error(<span class="hljs-string">&quot;加密算法不存在：&#123;&#125;&quot;</span>, hmacSha256, e);
    &#125; <span class="hljs-keyword">catch</span> (InvalidKeyException e) &#123;
      log.error(<span class="hljs-string">&quot;非法私有key：&#123;&#125;&quot;</span>, hmacSha256, e);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];
  &#125;
&#125;</code></pre>

<pre><code class="hljs log">2020-12-19 16:45:20 [main] INFO  com.unclezs.samples.java.encryption.HmacSample #main:23 - HmacSHA256 加密后：[3, 40, -93, -87, 70, 63, 79, 86, 31, 59, -1, -67, 115, -26, 76, -46, 31, 4, 35, -119, -112, -82, 43, -27, 97, -12, 76, 63, 115, -113, 41, 109]</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的四种引用类型详解</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h2 id="概念及应用场景"><a href="#概念及应用场景" class="headerlink" title="概念及应用场景"></a>概念及应用场景</h2><ul>
<li>强引用：Java中的引用，默认都是强引用。比如new一个对象，对它的引用就是强引用。对于被强引用指向的对象，就算JVM内存不足OOM，也不会去回收它们。</li>
<li>软引用：若一个对象只被软引用所引用，那么它将在JVM内存不足的时候被回收，即如果JVM内存足够，则软引用所指向的对象不会被垃圾回收(其实这个说法也不够准确，具体原因后面再说)。根据这个性质，软引用很适合做内存缓存：既能提高查询效率，也不会造成内存泄漏。</li>
<li>弱引用：若一个对象只被弱引用所引用，那么它将在下一次GC中被回收掉。如ThreadLocal和WeakHashMap中都使用了弱引用，防止内存泄漏。</li>
<li>虚引用：虚引用是四种引用中最弱的一种引用。我们永远无法从虚引用中拿到对象，被虚引用引用的对象就跟不存在一样。虚引用一般用来跟踪垃圾回收情况，或者可以完成垃圾收集器之外的一些定制化操作。Java NIO中的堆外内存(DirectByteBuffer)因为不受GC的管理，这些内存的清理就是通过虚引用来完成的。</li>
<li>终结器引用：无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象<img src="https://gitee.com/unclezs/image-blog/raw/master///20201217150908.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201217150908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ul>
<h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>引用队列(Reference Queue)是一个链表，顾名思义，存放的是引用对象(Reference对象)的队列。<br>软引用与弱引用可以和一个引用队列(Reference Queue)配合使用，当引用所指向的对象被垃圾回收之后，该引用对象本身会被添加到与之关联的引用队列中，从而方便后续一些跟踪或者额外的清理操作。<br>因为无法从虚引用中拿到目标对象，虚引用必须和一个引用队列(Reference Queue)配合使用。</p>
<h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.samples.java.reference;

<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;

<span class="hljs-keyword">import</span> java.lang.ref.PhantomReference;
<span class="hljs-keyword">import</span> java.lang.ref.Reference;
<span class="hljs-keyword">import</span> java.lang.ref.ReferenceQueue;
<span class="hljs-keyword">import</span> java.lang.ref.SoftReference;
<span class="hljs-keyword">import</span> java.lang.ref.WeakReference;
<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 几种引用类型测试</span>
<span class="hljs-comment"> * &lt;p&gt;</span>
<span class="hljs-comment"> * 指定VM参数 -Xms20m -Xmx20m -XX:+PrintGCDetails -verbose:gc</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhanghongguo@sensorsdata.cn</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/12/17 13:56</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceSamples</span> </span>&#123;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE1KB = <span class="hljs-number">1024</span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    <span class="hljs-comment">// 引用队列，存放Reference对象</span>
    ReferenceQueue&lt;Byte[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();
    <span class="hljs-comment">// 定义四种引用对象，强/弱/虚引用为1kb，软引用为1mb</span>
    Byte[] strong = <span class="hljs-keyword">new</span> Byte[SIZE1KB];
    SoftReference&lt;Byte[]&gt; soft = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> Byte[SIZE1MB * <span class="hljs-number">10</span>], queue);
    WeakReference&lt;Byte[]&gt; weak = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> Byte[SIZE1KB], queue);
    PhantomReference&lt;Byte[]&gt; phantom = <span class="hljs-keyword">new</span> PhantomReference&lt;&gt;(<span class="hljs-keyword">new</span> Byte[SIZE1KB], queue);

    Reference&lt;? extends Byte[]&gt; collectedReference;
    <span class="hljs-comment">// 初始状态</span>
    log.info(<span class="hljs-string">&quot;初始值 强引用： &#123;&#125;&quot;</span>, Arrays.hashCode(strong));
    log.info(<span class="hljs-string">&quot;初始值 软引用： &#123;&#125;&quot;</span>, Arrays.hashCode(soft.get()));
    log.info(<span class="hljs-string">&quot;初始值 弱引用： &#123;&#125;&quot;</span>, Arrays.hashCode(weak.get()));
    log.info(<span class="hljs-string">&quot;初始值 虚引用： &#123;&#125;&quot;</span>, Arrays.hashCode(phantom.get()));
    <span class="hljs-keyword">do</span> &#123;
      collectedReference = queue.poll();
      log.info(<span class="hljs-string">&quot;初始值 引用队列： &quot;</span> + collectedReference);
    &#125; <span class="hljs-keyword">while</span> (collectedReference != <span class="hljs-keyword">null</span>);
    log.info(<span class="hljs-string">&quot;********************&quot;</span>);
    <span class="hljs-comment">// 第一次手动触发GC</span>
    System.gc();
    <span class="hljs-comment">// 停100ms保证垃圾回收已经执行</span>
    Thread.sleep(<span class="hljs-number">100</span>);

    log.info(<span class="hljs-string">&quot;GC后 强引用： &#123;&#125;&quot;</span>, Arrays.hashCode(strong));
    log.info(<span class="hljs-string">&quot;GC后 软引用： &#123;&#125;&quot;</span>, Arrays.hashCode(soft.get()));
    log.info(<span class="hljs-string">&quot;GC后 弱引用： &#123;&#125;&quot;</span>, Arrays.hashCode(weak.get()));
    log.info(<span class="hljs-string">&quot;GC后 虚引用： &#123;&#125;&quot;</span>, Arrays.hashCode(phantom.get()));
    <span class="hljs-keyword">do</span> &#123;
      collectedReference = queue.poll();
      log.info(<span class="hljs-string">&quot;GC后 引用队列： &quot;</span> + collectedReference);
    &#125;
    <span class="hljs-keyword">while</span> (collectedReference != <span class="hljs-keyword">null</span>);
    log.info(<span class="hljs-string">&quot;********************&quot;</span>);

    <span class="hljs-comment">// 再分配1M的内存，以模拟OOM的情况</span>
    Byte[] newByte = <span class="hljs-keyword">new</span> Byte[SIZE1MB * <span class="hljs-number">15</span>];

    log.info(<span class="hljs-string">&quot;Full GC后 强引用： &#123;&#125;&quot;</span>, Arrays.hashCode(strong));
    log.info(<span class="hljs-string">&quot;Full GC后 软引用： &#123;&#125;&quot;</span>, Arrays.hashCode(soft.get()));
    log.info(<span class="hljs-string">&quot;Full GC后 弱引用： &#123;&#125;&quot;</span>, Arrays.hashCode(weak.get()));
    log.info(<span class="hljs-string">&quot;Full GC失败后 虚引用： &#123;&#125;&quot;</span>, Arrays.hashCode(phantom.get()));
    <span class="hljs-keyword">do</span> &#123;
      collectedReference = queue.poll();
      log.info(<span class="hljs-string">&quot;Full GC失败后 引用队列： &quot;</span> + collectedReference);
    &#125;
    <span class="hljs-keyword">while</span> (collectedReference != <span class="hljs-keyword">null</span>);
  &#125;
&#125;</code></pre>

<img src="https://gitee.com/unclezs/image-blog/raw/master///20201217143337.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201217143337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>注意设置VM参数，每个机器不一样，你可以试着调试到合适自己的。</p>
<ul>
<li>初始状态下，虚引用用就返回null，其他三个引用都有值。</li>
<li>当触发GC之后，弱引用指向的对象也被回收了，而且可以看到弱引用和虚引用两个引用对象被加到了它们相关联的引用队列中了；强引用和软引用还是可以取到值。</li>
<li>当JVM内存不足之后，软引用也被内存回收了（可以看到软引用，第一次gc后还是内存不足，第二次gc时候，回收了软引用对象），同时该软引用也被加到了与之关联的引用队列中了。而强引用依然能取到值。</li>
</ul>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h3><p>弱引用，软引用和虚引用都继承自Reference类，我们从Reference类看起</p>
<pre><code class="hljs java"><span class="hljs-comment">// 此Reference对象可能会有四种状态：active, pending, enqueued, inactive</span>
<span class="hljs-comment">// avtive: 新创建的对象状态是active</span>
<span class="hljs-comment">// pending: 当Reference所指向的对象不可达，并且Reference与一个引用队列关联，那么垃圾收集器</span>
<span class="hljs-comment">//     会将Reference标记为pending，并且会将之加到pending队列里面</span>
<span class="hljs-comment">// enqueued: 当Reference从pending队列中，移到引用队列中之后，就是enqueued状态</span>
<span class="hljs-comment">// inactive: 如果Reference所指向的对象不可达，并且Reference没有与引用队列关联，Reference</span>
<span class="hljs-comment">//     从引用队列移除之后，变为inactive状态。inactive就是最终状态</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-comment">// 该对象就是Reference所指向的对象，垃圾收集器会对此对象做特殊处理。</span>
    <span class="hljs-keyword">private</span> T referent;         <span class="hljs-comment">/* Treated specially by GC */</span>
    <span class="hljs-comment">// Reference相关联的引用队列</span>
    <span class="hljs-keyword">volatile</span> ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; queue;
    <span class="hljs-comment">// 当Reference是active时，next为null</span>
    <span class="hljs-comment">// 当该Reference处于引用队列中时，next指向队列中的下一个Reference</span>
    <span class="hljs-comment">// 其他情况next指向this，即自己</span>
    <span class="hljs-comment">// 垃圾收集器只需判断next是不是为null，来看是否需要对此Reference做特殊处理</span>
    <span class="hljs-keyword">volatile</span> Reference next;
    <span class="hljs-comment">// 当Reference在pending队列中时，该值指向下一个队列中Reference对象</span>
    <span class="hljs-comment">// 另外垃圾收集器在GC过程中，也会用此对象做标记</span>
    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">private</span> Reference&lt;T&gt; discovered;  <span class="hljs-comment">/* used by VM */</span>

    <span class="hljs-comment">// 锁对象</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> </span>&#123; &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> Lock();

    <span class="hljs-comment">// pending队列，这里的pending是pending链表的队首元素，一般与上面的discovered变量一起使用</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Reference&lt;Object&gt; pending = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// 获取Reference指向的对象。默认返回referent对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.referent;
    &#125;
&#125;</code></pre>

<p>Reference类跟垃圾收集器紧密关联，其状态变化如下图所示：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201217144032.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201217144032.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>上述步骤大多数都是由GC线程来完成，其中Pending到Enqueued是用户线程来做的。Reference类中定义了一个子类ReferenceHandler，专门用来处理Pending状态的Reference。我们来看看它具体做了什么。</p>
<h3 id="ReferenceHandler类"><a href="#ReferenceHandler类" class="headerlink" title="ReferenceHandler类"></a>ReferenceHandler类</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-comment">// 静态块，主要逻辑是启动ReferenceHandler线程</span>
    <span class="hljs-keyword">static</span> &#123;
        <span class="hljs-comment">// 创建ReferenceHandler线程</span>
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        <span class="hljs-keyword">for</span> (ThreadGroup tgn = tg; tgn != <span class="hljs-keyword">null</span>; tg = tgn, tgn = tg.getParent());
            Thread handler = <span class="hljs-keyword">new</span> ReferenceHandler(tg, <span class="hljs-string">&quot;Reference Handler&quot;</span>);
        <span class="hljs-comment">// 设置成守护线程，最高优先级，并启动</span>
        handler.setPriority(Thread.MAX_PRIORITY);
        handler.setDaemon(<span class="hljs-keyword">true</span>);
        handler.start();
        <span class="hljs-comment">// 访问控制</span>
        SharedSecrets.setJavaLangRefAccess(<span class="hljs-keyword">new</span> JavaLangRefAccess() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryHandlePendingReference</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">return</span> tryHandlePending(<span class="hljs-keyword">false</span>);
            &#125;
        &#125;);
    &#125;

    <span class="hljs-comment">// 内部类ReferenceHandler，用来处理Pending状态的Reference</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureClassInitialized</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;
            <span class="hljs-keyword">try</span> &#123;
                Class.forName(clazz.getName(), <span class="hljs-keyword">true</span>, clazz.getClassLoader());
            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
                <span class="hljs-keyword">throw</span> (Error) <span class="hljs-keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);
            &#125;
        &#125;
        <span class="hljs-comment">// 静态块，确保InterruptedException和Cleaner已经被ClassLoader加载</span>
        <span class="hljs-comment">// 因为后面会用到这两个类</span>
        <span class="hljs-keyword">static</span> &#123;
            ensureClassInitialized(InterruptedException.class);
            ensureClassInitialized(Cleaner.class);
        &#125;

        ReferenceHandler(ThreadGroup g, String name) &#123;
            <span class="hljs-keyword">super</span>(g, name);
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-comment">// 死循环调用tryHandlePending方法</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                tryHandlePending(<span class="hljs-keyword">true</span>);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>Reference类在加载进JVM的时候，会启动ReferenceHandler线程，并将它设成最高优先级的守护线程，不断循环调用tryHandlePending方法。<br>接下来看tryHandlePending方法：</p>
<pre><code class="hljs java"><span class="hljs-comment">// waitForNotify默认是true。</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryHandlePending</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> waitForNotify)</span> </span>&#123;
    Reference&lt;Object&gt; r;
    Cleaner c;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 需要在同步块中进行</span>
        <span class="hljs-keyword">synchronized</span> (lock) &#123;
            <span class="hljs-comment">// 判断pending队列是否为空，pending是队首元素</span>
            <span class="hljs-keyword">if</span> (pending != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">// 取到pending队列队首元素，赋值给r</span>
                r = pending;
                <span class="hljs-comment">// Cleaner类是Java NIO中专门用来清理堆外内存(DirectByteBufer)的类，这里对它做了特殊处理</span>
                <span class="hljs-comment">// 当没有其他引用指向堆外内存时，与之关联的Cleaner会被加到pending队列中</span>
                <span class="hljs-comment">// 如果该Reference是Cleaner实例，那么取到该Cleaner，后续可以做一些清理操作。</span>
                c = r <span class="hljs-keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="hljs-keyword">null</span>;
                <span class="hljs-comment">// r.discovered就是下一个元素</span>
                <span class="hljs-comment">// 以下操作即为将队首元素从pending队列移除</span>
                pending = r.discovered;
                r.discovered = <span class="hljs-keyword">null</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// 如果pending队列为空，则释放锁等待</span>
                <span class="hljs-comment">// 当有Reference添加到pending队列中时，ReferenceHandler线程会从此处被唤醒</span>
                <span class="hljs-keyword">if</span> (waitForNotify) &#123;
                    lock.wait();
                &#125;
                <span class="hljs-keyword">return</span> waitForNotify;
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;
        <span class="hljs-comment">// OOM时，让出cpu</span>
        Thread.yield();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-comment">// 给Cleaner的特殊处理，调用clean()方法，以释放与之关联的堆外内存</span>
    <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;
        c.clean();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-comment">// 此处，将此Reference加入到与之关联的引用队列</span>
    ReferenceQueue&lt;? <span class="hljs-keyword">super</span> Object&gt; q = r.queue;
    <span class="hljs-keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre>

<p>看到这里，豁然开朗。ReferenceHandler线程专门用来处理pending状态的Reference，跟GC线程组成类似生产者消费者的关系。当pending队列为空，则等待；当Reference关联的对象被回收，Reference被加入到pending队列中之后，ReferenceHandler线程会被唤醒来处理pending的Reference，主要做三件事：</p>
<ul>
<li>将该Reference从pending队列移除</li>
<li>如果该Reference是Cleaner的实例，那么调用clean方法，释放堆外内存</li>
<li>将Reference加入到与之关联的引用队列</li>
</ul>
<h2 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h2><pre><code class="hljs java"><span class="hljs-comment">// 相比WeakReference，它增加了两个时间戳，clock和timestamp</span>
<span class="hljs-comment">// 这两个参数是实现他们内存回收上区别的关键</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SoftReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-comment">// 每次GC之后，若该引用指向的对象没有被回收，则垃圾收集器会将clock更新成当前时间</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> clock;
    <span class="hljs-comment">// 每次调用get方法的时候，会更新该时间戳为clock值</span>
    <span class="hljs-comment">// 所以该值保存的是上一次(最近一次)GC的时间戳</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timestamp;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SoftReference</span><span class="hljs-params">(T referent)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(referent);
        <span class="hljs-keyword">this</span>.timestamp = clock;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SoftReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(referent, q);
        <span class="hljs-keyword">this</span>.timestamp = clock;
    &#125;
    <span class="hljs-comment">// 每次调用，更新timestamp的值，使之等于clock的值，即最近一次gc的时间</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
        T o = <span class="hljs-keyword">super</span>.get();
        <span class="hljs-keyword">if</span> (o != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.timestamp != clock)
            <span class="hljs-keyword">this</span>.timestamp = clock;
        <span class="hljs-keyword">return</span> o;
    &#125;
&#125;</code></pre>
<p>SoftReference除了多了两个时间戳之外，跟WeakReference几乎没有区别，它是如何做到在内存不足时被回收这件事的呢？其实这是垃圾收集器干的活。垃圾收集器回收SoftReference所指向的对象，会看两个维度：</p>
<ol>
<li>SoftReference.timestamp有多老(距上一次GC过了多久)</li>
<li>JVM的堆空闲空间有多大</li>
</ol>
<p>而具体什么时候回收SoftReference所指向的对象呢，可以参考如下公式：</p>
<pre><code class="hljs plain">interval &lt;&#x3D; free_heap * ms_per_mb</code></pre>

<p>其中interval为上一次GC与当前时间的差值，以毫秒为单位；free_heap为当前JVM中剩余的堆空间大小，以MB为单位；ms_per_mb可以理解为一个常数，即每兆空闲空间可维持的SoftReference的对象生存的时长，默认为1000，可以通过JVM参数-XX:SoftRefLRUPolicyMSPerMB设置。<br>如果上述表达式返回false，则清理SoftReference所指向的对象，并将该SoftReference加入到pending队列中；否则不做处理。所以说在JVM内存不足的时候回收软引用这个说法不是非常准确，只是个经验说法，软引用的回收，还跟它存活的时间有关，甚至跟JVM参数设置(-XX:SoftRefLRUPolicyMSPerMB)都有关系！</p>
<h2 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h2><pre><code class="hljs java"><span class="hljs-comment">// 更加简单，只重写了两个构造方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeakReference</span><span class="hljs-params">(T referent)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(referent);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeakReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(referent, q);
    &#125;
&#125;</code></pre>

<h2 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用(PhantomReference)"></a>虚引用(PhantomReference)</h2><p>一般用于获取被回收的时候的通知，比如NIO的直接内存属于JVM之外的，就用了这个实现的 具体可以看Cleaner类</p>
<pre><code class="hljs java"><span class="hljs-comment">// 灰常简单，只重写了一个构造方法，一个get方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-comment">// get方法永远返回null</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;

    <span class="hljs-comment">// 只提供了一个包含ReferenceQueue的构造方法，说明它必须和引用队列一起使用</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhantomReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(referent, q);
    &#125;
&#125;</code></pre>

<h2 id="终结器引用（FinalReference-与-Finalizer）"><a href="#终结器引用（FinalReference-与-Finalizer）" class="headerlink" title="终结器引用（FinalReference 与 Finalizer）"></a>终结器引用（FinalReference 与 Finalizer）</h2><p>因为jvm只能管理jvm内存空间，但是对于应用运行时需要的其它native资源(jvm通过jni暴漏出来的功能)：例如直接内存DirectByteBuffer，网络连接SocksSocketImpl，文件流FileInputStream等与操作系统有交互的资源，jvm就无能为力了，需要我们自己来调用释放这些资源方法来释放，为了避免对象死了之后，程序员忘记手动释放这些资源，导致这些对象有的外部资源泄露，java提供了finalizer机制通过重写对象的finalizer方法，在这个方法里面执行释放对象占用的外部资源的操作，这样使用这些资源的程序员即使忘记手动释放，jvm也可以在回收对象之前帮助释放掉这些外部资源，帮助我们调用这个方法回收资源的线程就是我们在导出jvm线程栈时看到的名为Finalizer的守护线程；</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Final references, used to implement finalization</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FinalReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(referent, q);
    &#125;
&#125;</code></pre>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fjeremymanson.blogspot.com%2F2009%2F07%2Fhow-hotspot-decides-to-clear_07.html">How Hotspot Clear Softreference</a><br><a href="https://blog.csdn.net/csdn_life18/article/details/107338308">FinalReference类的功能</a><br><a href="https://blog.csdn.net/dhaibo1986/article/details/107314800">FinalReference和Finalizer的源码分析</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>引用类型</tag>
        <tag>虚引用</tag>
        <tag>弱引用</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal与FastThreadLocal</title>
    <url>/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E4%B8%8EFastThreadLocal.html</url>
    <content><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。ThreadLocal为每个线程的中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。<br>ThreadLocal不能使用基本数据类型，只能使用Object类型。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>ThreadLocal就是绑定在线程上的，可以让每个线程可以存储隔离的线程安全的数据。</p>
<p>其实现就是在Thread类的本地变量中存储ThreadLocal.ThreadlocalMap一个成员变量。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
   ......(其他源码)
    <span class="hljs-comment">/* </span>
<span class="hljs-comment">     * 当前线程的ThreadLocalMap，主要存储该线程自身的ThreadLocal</span>
<span class="hljs-comment">     * 本文主要讨论的就是这个ThreadLocalMap</span>
<span class="hljs-comment">     */</span>
    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">     * InheritableThreadLocal，自父线程集成而来的ThreadLocalMap，</span>
<span class="hljs-comment">     * 主要用于父子线程间ThreadLocal变量的传递</span>
<span class="hljs-comment">     */</span>
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;
&#125;</code></pre>

<p>然后在设置的时候直接使用当前ThreadLocal变量为key到Thread中的ThreadLocalMap中取值，<strong>可以看到这里的ThreadlocalMap是一个hash结构</strong>。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;
            Thread t = Thread.currentThread();
            ThreadLocalMap map = getMap(t);
            <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)
                <span class="hljs-comment">//key为自己声明的threadLocal</span>
                map.set(<span class="hljs-keyword">this</span>, value);
            <span class="hljs-keyword">else</span>
                <span class="hljs-comment">//创建一个ThreadLocalmap</span>
                createMap(t, value);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;
            ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
                T result = (T)e.value;
                <span class="hljs-keyword">return</span> result;
            &#125;
        &#125;
        <span class="hljs-comment">//setInitialValue就是可以在没有设置当前线程的threadlocal的初始值，可以自己定义默认为null</span>
        <span class="hljs-keyword">return</span> setInitialValue();
    &#125;
&#125;</code></pre>

<h3 id="InheritableThreadLocal子线程共享"><a href="#InheritableThreadLocal子线程共享" class="headerlink" title="InheritableThreadLocal子线程共享"></a>InheritableThreadLocal子线程共享</h3><p>InheritableThreadLocal主要用于子线程创建时，需要自动继承父线程的ThreadLocal变量，方便必要信息的进一步传递。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">childValue</span><span class="hljs-params">(T parentValue)</span> </span>&#123;
        <span class="hljs-keyword">return</span> parentValue;
    &#125;
    <span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;
       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;
        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);
    &#125;
&#125;</code></pre>

<p>在新建线程的init方法中如果inheritThreadLocals为true则会继承，默认是true.并且是使用InheritableThreadLocal的才能继承，判断条件就是thread.inheritableThreadLocals是不是为null，而InheritableThreadLocal.createMap就是将threadlocalMap重写为了inheritableThreadLocals</p>
<p>示例</p>
<pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocalSample</span> </span>&#123;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    Thread parent = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
      threadLocal.set(<span class="hljs-string">&quot;uncle&quot;</span>);
      inheritableThreadLocal.set(<span class="hljs-string">&quot;uncle&quot;</span>);
      log.info(<span class="hljs-string">&quot;父线程的值：threadLocal:&#123;&#125;,inheritableThreadLocal:&#123;&#125;&quot;</span>, threadLocal.get(),inheritableThreadLocal.get());
      Thread child = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        log.info(<span class="hljs-string">&quot;父线程的值：threadLocal:&#123;&#125;,inheritableThreadLocal:&#123;&#125;&quot;</span>, threadLocal.get(),inheritableThreadLocal.get());
      &#125;,<span class="hljs-string">&quot;child thread&quot;</span>);
      child.start();
    &#125;,<span class="hljs-string">&quot;parent thread&quot;</span>);
    parent.start();
  &#125;

&#125;</code></pre>
<p>输出</p>
<pre><code class="hljs log">2020-12-17 17:11:59 [parent thread] INFO  com.unclezs.samples.java.thread.threadlocal.InheritableThreadLocalSample #lambda$main$1:18 - 父线程的值：threadLocal:uncle,inheritableThreadLocal:uncle
2020-12-17 17:11:59 [child thread] INFO  com.unclezs.samples.java.thread.threadlocal.InheritableThreadLocalSample #lambda$null$0:20 - 父线程的值：threadLocal:null,inheritableThreadLocal:uncle</code></pre>

<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><p>使用的时候注意ThreadLocal用完之后没用的要释放掉，以免造成内存泄漏。为什么不释放就可能照成内存泄漏呢？JVM不会回收吗？</p>
<p>首先看看ThreadLocalMap的结构，也是哈希结构，不过是开放地址法解决冲突的</p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;
        Object value;
        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;
            <span class="hljs-keyword">super</span>(k);
            value = v;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;
        Entry[] tab = table;
        <span class="hljs-keyword">int</span> len = tab.length;
        <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);
        <span class="hljs-comment">// 开放地址法找到合适的位置</span>
        <span class="hljs-keyword">for</span> (Entry e = tab[i] ;e != <span class="hljs-keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;
            ThreadLocal&lt;?&gt; k = e.get();
            <span class="hljs-comment">//已经存在直接设置value</span>
            <span class="hljs-keyword">if</span> (k == key) &#123;
                e.value = value;
                <span class="hljs-keyword">return</span>;
            &#125;
            <span class="hljs-comment">//entity存在，但是弱引用key threadlocal已经被回收了 获取到的key为null</span>
            <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//直接覆盖这个已经被回收的key的位置 放入新的</span>
                replaceStaleEntry(key, value, i);
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125;
        <span class="hljs-comment">//不存在冲突</span>
        tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);
        <span class="hljs-keyword">int</span> sz = ++size;
        <span class="hljs-comment">//先清理已经被回收了的，范围是keyindex-&gt;size 判断是否需要扩容</span>
        <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
            rehash();
    &#125;
&#125;</code></pre>

<p>所以这里可以看出来，首先Entity是个弱引用对象，引用对象为ThreadLocal，所以ThreadLocal只要发生了GC了就会被回收，这个时候Entity中的样子就变成了：</p>
<p>key=null,value=xx</p>
<p>虽然key threadlocal被回收了，但是value并没有被回收，而且entity也还是在table数组中强引用占用着内存。所以如果不处理这些数据就有可能造成内存泄漏</p>
<p>你可以想象，我们平时使用线程池，这个线程复用技术，因为ThreadLocal实现还是在Thread中放一个ThreadLocalMap，如果复用了Thread也代表会重复用这个ThreadLocalMap，如果一个线程在使用完ThreadLocal之后，另一个线程又拿过来用，导致ThreadLocalMap里面的一直没有正常释放，甚至越放越多。最终导致每个线程里面的ThreadLocalMap都有大量数据，导致内存泄漏</p>
<p>虽然ThreadLocalMap会在set，get以及resize等方法中对stale slots做自动删除（set以及get不保证所有过期slots会在操作中会被删除，而resize则会删除threadLocalMap中所有的过期slots）。但是最佳的实践还是用put就有对应的remove才行</p>
<p>比如用户登录进行put，用户注销进行remove。</p>
<h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>这个为什么说快呢？难道Hash存取数据还不够快吗？还有更快的吗？那也只有数组了。</p>
<p>这个实现是在Netty中的，用数组代替了 Hash+开发地址法。因为ThreadLocalMap是放在线程的成员变量中的，所以Netty自己继承出来一个FastThread,里面就包含了个InternalThreadLocalMap，别看名字是map其实是数组实现的。</p>
<p>所以具体要使用FastThreadLocal需要使用FastThread才行。</p>
<p>更多了解去 <a href="https://blog.csdn.net/theludlows/article/details/85267651">Netty进阶：自顶向下解析FastThreadLocal</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>threadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven之自定义插件</title>
    <url>/Java/Maven/Maven%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mojo：Maven plain Old Java Object。每一个 Mojo 就是 Maven 中的一个执行目标（executable goal），而插件则是对单个或多个相关的 Mojo 做统一分发。</p>
<p>一个 Mojo 包含一个简单的 Java 类。插件中多个类似 Mojo 的通用之处可以使用抽象父类来封装。Maven插件项目的打包方式packaging必须为maven-plugin</p>
<h2 id="第一个插件"><a href="#第一个插件" class="headerlink" title="第一个插件"></a>第一个插件</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>samples-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.unclezs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hello-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hello-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>我的第一maven插件<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">custom.plugin.version</span>&gt;</span>3.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">custom.plugin.version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-plugin-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;custom.plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>plexus-utils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.plexus<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugin-tools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-plugin-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;custom.plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-artifact<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-plugin-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;custom.plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-comment">&lt;!--自定义插件前缀 mvn <span class="hljs-doctag">xxx:</span>mojoName，默认为xxx-maven-plugin的xxx--&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">goalPrefix</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">goalPrefix</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre>

<h3 id="编写mojo"><a href="#编写mojo" class="headerlink" title="编写mojo"></a>编写mojo</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/6 2:51 上午</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Mojo(name = &quot;custom&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPlugin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMojo</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;
        getLog().info(<span class="hljs-string">&quot;hello maven plugin!!!&quot;</span>);
    &#125;
&#125;</code></pre>

<h3 id="安装到本地仓库"><a href="#安装到本地仓库" class="headerlink" title="安装到本地仓库"></a>安装到本地仓库</h3><pre><code class="hljs plain">maven clean install -U</code></pre>

<h3 id="测试插件"><a href="#测试插件" class="headerlink" title="测试插件"></a>测试插件</h3><p>再另个一项目下引入</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.unclezs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hello-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-comment">&lt;!--这个如果加上mvn compile的时候自动执行--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>
<p>然后执行</p>
<pre><code class="hljs shell">mvn hello:custom
mvn com.unclezs:hello-maven-plugin:1.0:custom
mvn groupId:artifactId:version:goal</code></pre>

<img src="https://gitee.com/unclezs/image-blog/raw/master/20201206120417.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201206120417.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs;

<span class="hljs-keyword">import</span> org.apache.maven.plugin.AbstractMojo;
<span class="hljs-keyword">import</span> org.apache.maven.plugin.MojoExecutionException;
<span class="hljs-keyword">import</span> org.apache.maven.plugin.MojoFailureException;
<span class="hljs-keyword">import</span> org.apache.maven.plugins.annotations.Mojo;
<span class="hljs-keyword">import</span> org.apache.maven.plugins.annotations.Parameter;

<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.net.URL;
<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/6 2:51 上午</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Mojo(name = &quot;param&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParameterPlugin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMojo</span> </span>&#123;
    <span class="hljs-meta">@Parameter(property = &quot;param.name&quot;, defaultValue = &quot;$&#123;project.artifactId&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> Integer number;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> Boolean bool;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> Double doubleValue;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> Date date;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> File file;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> URL url;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> Color color;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> String[] array;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> List&lt;String&gt; list;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; map;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> Properties properties;
    <span class="hljs-meta">@Parameter</span>
    <span class="hljs-keyword">private</span> User obj;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;
        getLog().info(<span class="hljs-string">&quot;String:&quot;</span>+name);
        getLog().info(<span class="hljs-string">&quot;Integer:&quot;</span> + number);
        getLog().info(<span class="hljs-string">&quot;Boolean:&quot;</span> + bool);
        getLog().info(<span class="hljs-string">&quot;Double:&quot;</span> + doubleValue);
        getLog().info(<span class="hljs-string">&quot;Date:&quot;</span> + date);
        getLog().info(<span class="hljs-string">&quot;File:&quot;</span> + file.getName());
        getLog().info(<span class="hljs-string">&quot;URL:&quot;</span> + url);
        getLog().info(<span class="hljs-string">&quot;enum:&quot;</span> + color);
        getLog().info(<span class="hljs-string">&quot;array:&quot;</span> + Arrays.toString(array));
        getLog().info(<span class="hljs-string">&quot;List:&quot;</span> + list);
        getLog().info(<span class="hljs-string">&quot;Map:&quot;</span> + map);
        getLog().info(<span class="hljs-string">&quot;Properties:&quot;</span> + properties);
        getLog().info(<span class="hljs-string">&quot;obj:&quot;</span> + obj);

    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123;
        GREEN,
        RED,
        BLUE
    &#125;
&#125;
</code></pre>

<p>对应的引用时候传值</p>
<pre><code class="hljs plain">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.unclezs&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;hello-maven-plugin&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.0&lt;&#x2F;version&gt;
            &lt;configuration&gt;
                &lt;name&gt;unclezs&lt;&#x2F;name&gt;
                &lt;number&gt;123&lt;&#x2F;number&gt;
                &lt;bool&gt;true&lt;&#x2F;bool&gt;
                &lt;doubleValue&gt;1.0&lt;&#x2F;doubleValue&gt;
                &lt;date&gt;2005-10-06 2:22:55.1 PM&lt;&#x2F;date&gt;
                &lt;file&gt;$&#123;project.basedir&#125;&#x2F;pom.xml&lt;&#x2F;file&gt;
                &lt;url&gt;https:&#x2F;&#x2F;blog.unclezs.com&lt;&#x2F;url&gt;
                &lt;color&gt;GREEN&lt;&#x2F;color&gt;
                &lt;array&gt;
                    &lt;param&gt;value1&lt;&#x2F;param&gt;
                    &lt;param&gt;value2&lt;&#x2F;param&gt;
                &lt;&#x2F;array&gt;
                &lt;list&gt;
                    &lt;param&gt;value1&lt;&#x2F;param&gt;
                    &lt;param&gt;value2&lt;&#x2F;param&gt;
                &lt;&#x2F;list&gt;
                &lt;map&gt;
                    &lt;key1&gt;value1&lt;&#x2F;key1&gt;
                    &lt;key2&gt;value2&lt;&#x2F;key2&gt;
                &lt;&#x2F;map&gt;
                &lt;properties&gt;
                    &lt;property&gt;
                        &lt;name&gt;propertyName1&lt;&#x2F;name&gt;
                        &lt;value&gt;propertyValue1&lt;&#x2F;value&gt;
                    &lt;&#x2F;property&gt;
                    &lt;property&gt;
                        &lt;name&gt;propertyName2&lt;&#x2F;name&gt;
                        &lt;value&gt;propertyValue2&lt;&#x2F;value&gt;
                    &lt;&#x2F;property&gt;
                &lt;&#x2F;properties&gt;
                &lt;obj&gt;
                    &lt;age&gt;12&lt;&#x2F;age&gt;
                    &lt;name&gt;uncle&lt;&#x2F;name&gt;
                &lt;&#x2F;obj&gt;
            &lt;&#x2F;configuration&gt;
            &lt;!--这个如果加上mvn compile的时候自动执行--&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;phase&gt;compile&lt;&#x2F;phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;custom&lt;&#x2F;goal&gt;
                    &lt;&#x2F;goals&gt;
                &lt;&#x2F;execution&gt;
            &lt;&#x2F;executions&gt;
        &lt;&#x2F;plugin&gt;
    &lt;&#x2F;plugins&gt;
&lt;&#x2F;build&gt;</code></pre>

<p>测试输出</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201206124225.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201206124225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<p>更多细节查看<a href="http://maven.apache.org/guides/plugin/guide-java-plugin-development.html#parameters">plugin-parameters</a></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://maven.apache.org/plugin-developers/index.html">Plugin Developers Centre</a></li>
<li><a href="https://github.com/unclezs/samples/tree/main/samples-maven">示例代码</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Model高效转换神器之MapStruct</title>
    <url>/Java/%E5%B7%A5%E5%85%B7/Model%E9%AB%98%E6%95%88%E8%BD%AC%E6%8D%A2%E7%A5%9E%E5%99%A8%E4%B9%8BMapStruct.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MapStruct是一种注释处理器，用于生成类型安全，高性能和无依赖的Bean映射代码。解决了我们日常在各种Vo、Dto、Model之间的转换难题。</p>
<p>有人问不是有BeanUtil了吗，为什么还要这么累赘的写这样的转换器？</p>
<ol>
<li>BeanUtil原理是利用反射，所以效率低，MapStruct是在编译时生成代码效率高</li>
<li>BeanUtil的只是名称类型相同的的转换比较方便</li>
<li>MapStruct支持各种复杂类型的转换。</li>
</ol>
<h2 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h2><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">org.mapstruct.version</span>&gt;</span>1.4.1.Final<span class="hljs-tag">&lt;/<span class="hljs-name">org.mapstruct.version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span>
                    <span class="hljs-comment">&lt;!--如果有用Lombok需要添加下面这个，注意顺序--&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>

<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>用了lombok，不用也一样，自己写getter、setter</p>
<p>示例代码在<a href="https://github.com/unclezs/samples/samples-mapstruct">samples-mapstruct</a></p>
<pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDto</span> </span>&#123;
  <span class="hljs-keyword">private</span> String age;
  <span class="hljs-keyword">private</span> String name;
&#125;
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
  <span class="hljs-keyword">private</span> String age;
  <span class="hljs-keyword">private</span> String name;
&#125;</code></pre>

<p>编写Mapper</p>
<pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;
  UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);
  <span class="hljs-function">User <span class="hljs-title">userDto2User</span><span class="hljs-params">(UserDto userDto)</span></span>;
  <span class="hljs-function">UserDto <span class="hljs-title">userDto2User</span><span class="hljs-params">(User user)</span></span>;
&#125;</code></pre>

<p>测试代码</p>
<pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapStructSample</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;uncle&quot;</span>);
    UserDto userDto = UserMapper.INSTANCE.userDto2User(user);
    log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,userDto);
  &#125;
&#125;</code></pre>

<p>输出</p>
<pre><code class="hljs log">18:20:14.886 [main] INFO com.unclezs.samples.mapstruct.MapStructSample - UserDto(age&#x3D;123, name&#x3D;uncle)</code></pre>

<p>可以看到生成了代码</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201205183955.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201205183955.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="不同的属性名"><a href="#不同的属性名" class="headerlink" title="不同的属性名"></a>不同的属性名</h2><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonDto</span> </span>&#123;
  <span class="hljs-keyword">private</span> String cname;
&#125;

<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
  <span class="hljs-keyword">private</span> String name;
&#125;
<span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonMapper</span> </span>&#123;
  PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);

  <span class="hljs-meta">@Mapping(source = &quot;name&quot;,target = &quot;cname&quot;)</span>
  <span class="hljs-function">PersonDto <span class="hljs-title">personToPersonDto</span><span class="hljs-params">(Person user)</span></span>;
&#125;</code></pre>

<h2 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h2><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonVo</span> </span>&#123;
  <span class="hljs-keyword">private</span> String cname;
  <span class="hljs-keyword">private</span> String userName;
  <span class="hljs-keyword">private</span> String userAge;
&#125;

<span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonMapper</span> </span>&#123;
  PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);

  <span class="hljs-meta">@Mapping(source = &quot;name&quot;, target = &quot;cname&quot;)</span>
  <span class="hljs-function">PersonDto <span class="hljs-title">personToPersonDto</span><span class="hljs-params">(Person user)</span></span>;

  <span class="hljs-meta">@Mapping(source = &quot;user&quot;,target = &quot;guest&quot;)</span>
  <span class="hljs-meta">@Mapping(source = &quot;name&quot;,target = &quot;cname&quot;)</span>
  <span class="hljs-function">PersonDto <span class="hljs-title">personToPersonDtoNested</span><span class="hljs-params">(Person person)</span></span>;

  <span class="hljs-meta">@Mapping(source = &quot;user.name&quot;,target = &quot;userName&quot;)</span>
  <span class="hljs-meta">@Mapping(source = &quot;user.age&quot;,target = &quot;userAge&quot;)</span>
  <span class="hljs-meta">@Mapping(source = &quot;name&quot;,target = &quot;cname&quot;)</span>
  <span class="hljs-function">PersonVo <span class="hljs-title">personToPersonVoNestedProperty</span><span class="hljs-params">(Person person)</span></span>;
&#125;</code></pre>

<p>测试</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNested</span><span class="hljs-params">()</span> </span>&#123;
  Person person = <span class="hljs-keyword">new</span> Person();
  person.setName(<span class="hljs-string">&quot;uncle&quot;</span>);
  User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;uncle&quot;</span>);
  person.setUser(user);
  PersonDto personDto = PersonMapper.INSTANCE.personToPersonDtoNested(person);
  Assert.assertEquals(<span class="hljs-string">&quot;uncle&quot;</span>, personDto.getCname());
  Assert.assertEquals(<span class="hljs-string">&quot;uncle&quot;</span>, personDto.getGuest().getName());
&#125;

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNestedToProperty</span><span class="hljs-params">()</span> </span>&#123;
  Person person = <span class="hljs-keyword">new</span> Person();
  person.setName(<span class="hljs-string">&quot;uncle&quot;</span>);
  User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;uncle&quot;</span>);
  person.setUser(user);
  PersonVo personVo = PersonMapper.INSTANCE.personToPersonVoNestedProperty(person);
  Assert.assertEquals(<span class="hljs-string">&quot;uncle&quot;</span>, personVo.getCname());
  Assert.assertEquals(<span class="hljs-string">&quot;uncle&quot;</span>, personVo.getUserName());
&#125;</code></pre>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://mapstruct.org/documentation/stable/reference/html/">官方文档</a><br><a href="https://github.com/mapstruct/mapstruct">github官方地址</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>高效工具</tag>
        <tag>mapper</tag>
        <tag>mapstruct</tag>
        <tag>属性转换</tag>
      </tags>
  </entry>
  <entry>
    <title>logback源码分析</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/12.logback%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<p>从一个Logger获取说起</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title">getLogger</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;
    <span class="hljs-comment">//获取Logger</span>
    Logger logger = getLogger(clazz.getName());
    <span class="hljs-keyword">if</span> (DETECT_LOGGER_NAME_MISMATCH) &#123;
        Class&lt;?&gt; autoComputedCallingClass = Util.getCallingClass();
        <span class="hljs-keyword">if</span> (autoComputedCallingClass != <span class="hljs-keyword">null</span> &amp;&amp; nonMatchingClasses(clazz, autoComputedCallingClass)) &#123;
            Util.report(String.format(<span class="hljs-string">&quot;Detected logger name mismatch. Given name: \&quot;%s\&quot;; computed name: \&quot;%s\&quot;.&quot;</span>, logger.getName(),
                            autoComputedCallingClass.getName()));
            Util.report(<span class="hljs-string">&quot;See &quot;</span> + LOGGER_NAME_MISMATCH_URL + <span class="hljs-string">&quot; for an explanation&quot;</span>);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> logger;
&#125;</code></pre>

<p>在跟进Logger logger = getLogger(clazz.getName());方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title">getLogger</span><span class="hljs-params">(String name)</span> </span>&#123;
    ILoggerFactory iLoggerFactory = getILoggerFactory();
    <span class="hljs-keyword">return</span> iLoggerFactory.getLogger(name);
&#125;</code></pre>

<p>这个方法就是初始化LoggerContext，如果没有初始化则调用performInitialization进行初始化，初始化了就直接返回</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ILoggerFactory <span class="hljs-title">getILoggerFactory</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;
        <span class="hljs-keyword">synchronized</span> (LoggerFactory.class) &#123;
            <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;
                INITIALIZATION_STATE = ONGOING_INITIALIZATION;
                performInitialization();
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">switch</span> (INITIALIZATION_STATE) &#123;
    <span class="hljs-keyword">case</span> SUCCESSFUL_INITIALIZATION:
        <span class="hljs-keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();
    <span class="hljs-keyword">case</span> NOP_FALLBACK_INITIALIZATION:
        <span class="hljs-keyword">return</span> NOP_FALLBACK_FACTORY;
    <span class="hljs-keyword">case</span> FAILED_INITIALIZATION:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(UNSUCCESSFUL_INIT_MSG);
    <span class="hljs-keyword">case</span> ONGOING_INITIALIZATION:
        <span class="hljs-comment">// support re-entrant behavior.</span>
        <span class="hljs-comment">// See also http://jira.qos.ch/browse/SLF4J-97</span>
        <span class="hljs-keyword">return</span> SUBST_FACTORY;
    &#125;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Unreachable code&quot;</span>);
&#125;</code></pre>

<p>再看看performInitialization()方法，里面就一个绑定和校验</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performInitialization</span><span class="hljs-params">()</span> </span>&#123;
    bind();
    <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) &#123;
        versionSanityCheck();
    &#125;
&#125;</code></pre>

<p>比较核心的方法bind()：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">()</span> </span>&#123;
       <span class="hljs-keyword">try</span> &#123;
           Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="hljs-keyword">null</span>;
           <span class="hljs-comment">//这里通过findPossibleStaticLoggerBinderPathSet查找类路径下的org/slf4j/impl/StaticLoggerBinder.class</span>
           <span class="hljs-comment">//如果有多个或者没有则记录错误信息</span>
           <span class="hljs-keyword">if</span> (!isAndroid()) &#123;
               staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();
               reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);
           &#125;
           <span class="hljs-comment">//这个是直接引入StaticLoggerBinder方式进行加注，这个初始化的时候会在static代码块中执行init方式加载配置</span>
           <span class="hljs-comment">//如果Jar包中没有这个类则会报错NoClassDefFoundError，多个的话Jvm优先选择先被加载的那个实现。</span>
           StaticLoggerBinder.getSingleton();
           <span class="hljs-comment">//初始化成功</span>
           INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;
           <span class="hljs-comment">//显示真实选择的实现类</span>
           reportActualBinding(staticLoggerBinderPathSet);
           fixSubstituteLoggers();
           replayEvents();
           <span class="hljs-comment">// release all resources in SUBST_FACTORY</span>
           SUBST_FACTORY.clear();
       &#125; <span class="hljs-keyword">catch</span> (NoClassDefFoundError ncde) &#123;
           String msg = ncde.getMessage();
           <span class="hljs-keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;
               INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;
               Util.report(<span class="hljs-string">&quot;Failed to load class \&quot;org.slf4j.impl.StaticLoggerBinder\&quot;.&quot;</span>);
               Util.report(<span class="hljs-string">&quot;Defaulting to no-operation (NOP) logger implementation&quot;</span>);
               Util.report(<span class="hljs-string">&quot;See &quot;</span> + NO_STATICLOGGERBINDER_URL + <span class="hljs-string">&quot; for further details.&quot;</span>);
           &#125; <span class="hljs-keyword">else</span> &#123;
               failedBinding(ncde);
               <span class="hljs-keyword">throw</span> ncde;
           &#125;
       &#125; <span class="hljs-keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;
           String msg = nsme.getMessage();
           <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.contains(<span class="hljs-string">&quot;org.slf4j.impl.StaticLoggerBinder.getSingleton()&quot;</span>)) &#123;
               INITIALIZATION_STATE = FAILED_INITIALIZATION;
               Util.report(<span class="hljs-string">&quot;slf4j-api 1.6.x (or later) is incompatible with this binding.&quot;</span>);
               Util.report(<span class="hljs-string">&quot;Your binding is version 1.5.5 or earlier.&quot;</span>);
               Util.report(<span class="hljs-string">&quot;Upgrade your binding to version 1.6.x.&quot;</span>);
           &#125;
           <span class="hljs-keyword">throw</span> nsme;
       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
           failedBinding(e);
           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Unexpected initialization failure&quot;</span>, e);
       &#125;
   &#125;</code></pre>

<p>StaticLoggerBinder.getSingleton();看看具体做了些什么</p>
<pre><code class="hljs java"><span class="hljs-comment">//静态代码块初始化</span>
<span class="hljs-keyword">static</span> &#123;
        SINGLETON.init();
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-keyword">try</span> &#123;
              <span class="hljs-comment">//执行真正的配置自动选择与加载</span>
              <span class="hljs-keyword">new</span> ContextInitializer(defaultLoggerContext).autoConfig();
          &#125; <span class="hljs-keyword">catch</span> (JoranException je) &#123;
              Util.report(<span class="hljs-string">&quot;Failed to auto configure default logger context&quot;</span>, je);
          &#125;
          <span class="hljs-comment">//这里判断如果没有监听状态信息的话就 查看状态列表有没有warn以上的日志，有就打印到控制台</span>
          <span class="hljs-keyword">if</span> (!StatusUtil.contextHasStatusListener(defaultLoggerContext)) &#123;
              StatusPrinter.printInCaseOfErrorsOrWarnings(defaultLoggerContext);
          &#125;
          contextSelectorBinder.init(defaultLoggerContext, KEY);
          initialized = <span class="hljs-keyword">true</span>;
      &#125; <span class="hljs-keyword">catch</span> (Exception t) &#123; <span class="hljs-comment">// see LOGBACK-1159</span>
          Util.report(<span class="hljs-string">&quot;Failed to instantiate [&quot;</span> + LoggerContext.class.getName() + <span class="hljs-string">&quot;]&quot;</span>, t);
      &#125;
&#125;</code></pre>

<p>看看 new ContextInitializer(defaultLoggerContext).autoConfig();到底是怎么做的</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">autoConfig</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JoranException </span>&#123;
    StatusListenerConfigHelper.installIfAsked(loggerContext);
    <span class="hljs-comment">//找到具体的配置文件 logback-test.xml&gt;logback.groovy&gt;logback.xml</span>
    URL url = findURLOfDefaultConfigurationFile(<span class="hljs-keyword">true</span>);
    <span class="hljs-keyword">if</span> (url != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">//执行装载配置</span>
        configureByResource(url);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//如果没有上面的xml、groovy配置到执行则查询SPI,找Configurator的实现类</span>
        Configurator c = EnvUtil.loadFromServiceLoader(Configurator.class);
        <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">try</span> &#123;
                c.setContext(loggerContext);
                c.configure(loggerContext);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LogbackException(String.format(<span class="hljs-string">&quot;Failed to initialize Configurator: %s using ServiceLoader&quot;</span>, c != <span class="hljs-keyword">null</span> ? c.getClass()
                                .getCanonicalName() : <span class="hljs-string">&quot;null&quot;</span>), e);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//确实没有用户自定义配置，使用默认配置</span>
            BasicConfigurator basicConfigurator = <span class="hljs-keyword">new</span> BasicConfigurator();
            basicConfigurator.setContext(loggerContext);
            basicConfigurator.configure(loggerContext);
        &#125;
    &#125;
&#125;</code></pre>

<p>配置完成之后回到init方法，回去执行contextSelectorBinder.init(defaultLoggerContext, KEY);</p>
<p>这里面主要是解决日志分离问题，通过VM参数指定logback.ContextSelector来配置ContextSelector实现日志分离</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(LoggerContext defaultLoggerContext, Object key)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException,</span>
<span class="hljs-function">                IllegalAccessException, InvocationTargetException </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">this</span>.key = key;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key != key) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalAccessException(<span class="hljs-string">&quot;Only certain classes can access this method.&quot;</span>);
    &#125;

    String contextSelectorStr = OptionHelper.getSystemProperty(ClassicConstants.LOGBACK_CONTEXT_SELECTOR);
    <span class="hljs-keyword">if</span> (contextSelectorStr == <span class="hljs-keyword">null</span>) &#123;
        contextSelector = <span class="hljs-keyword">new</span> DefaultContextSelector(defaultLoggerContext);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextSelectorStr.equals(<span class="hljs-string">&quot;JNDI&quot;</span>)) &#123;
        <span class="hljs-comment">// if jndi is specified, let&#x27;s use the appropriate class</span>
        contextSelector = <span class="hljs-keyword">new</span> ContextJNDISelector(defaultLoggerContext);
    &#125; <span class="hljs-keyword">else</span> &#123;
        contextSelector = dynamicalContextSelector(defaultLoggerContext, contextSelectorStr);
    &#125;
&#125;</code></pre>

<p>到这里就初始化完成了。状态也变为了SUCCESSFUL_INITIALIZATION，performInitialization方法执行完成。返回了StaticLoggerBinder.getSingleton().getLoggerFactory();</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ILoggerFactory <span class="hljs-title">getILoggerFactory</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;
        <span class="hljs-keyword">synchronized</span> (LoggerFactory.class) &#123;
            <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;
                INITIALIZATION_STATE = ONGOING_INITIALIZATION;
                performInitialization();
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">switch</span> (INITIALIZATION_STATE) &#123;
        <span class="hljs-keyword">case</span> SUCCESSFUL_INITIALIZATION:
            <span class="hljs-keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();
        <span class="hljs-keyword">case</span> NOP_FALLBACK_INITIALIZATION:
            <span class="hljs-keyword">return</span> NOP_FALLBACK_FACTORY;
        <span class="hljs-keyword">case</span> FAILED_INITIALIZATION:
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(UNSUCCESSFUL_INIT_MSG);
        <span class="hljs-keyword">case</span> ONGOING_INITIALIZATION:
        <span class="hljs-comment">// support re-entrant behavior.</span>
        <span class="hljs-comment">// See also http://jira.qos.ch/browse/SLF4J-97</span>
        <span class="hljs-keyword">return</span> SUBST_FACTORY;
    &#125;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Unreachable code&quot;</span>);
&#125;</code></pre>

<p>返回了指定的logback自定义ILoggerFactory的实现类LoggerContext</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ILoggerFactory <span class="hljs-title">getLoggerFactory</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!initialized) &#123;
        <span class="hljs-keyword">return</span> defaultLoggerContext;
    &#125;

    <span class="hljs-keyword">if</span> (contextSelectorBinder.getContextSelector() == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;contextSelector cannot be null. See also &quot;</span> + NULL_CS_URL);
    &#125;
    <span class="hljs-keyword">return</span> contextSelectorBinder.getContextSelector().getLoggerContext();
&#125;</code></pre>

<p>在执行了LoggerContext.getLogger()方法，可以看到他在创建Logger的时候会根据.分割的，从左到右依次查找，如果不存在就创建并保存，存在直接返回</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Logger <span class="hljs-title">getLogger</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;name argument cannot be null&quot;</span>);
    &#125;
    <span class="hljs-comment">//名字为ROOT直接返回 根LOGGER</span>
    <span class="hljs-keyword">if</span> (Logger.ROOT_LOGGER_NAME.equalsIgnoreCase(name)) &#123;
        <span class="hljs-keyword">return</span> root;
    &#125;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    Logger logger = root;
    <span class="hljs-comment">//查询已经创建了的Logger</span>
    Logger childLogger = (Logger) loggerCache.get(name);
    <span class="hljs-comment">// 存在直接返回</span>
    <span class="hljs-keyword">if</span> (childLogger != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">return</span> childLogger;
    &#125;

    <span class="hljs-comment">//不存在则按照规则创建，配置日志等级，继承祖先配置</span>
    String childName;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
        <span class="hljs-comment">//通过 . 分割Logger等级 划分父子节点</span>
        <span class="hljs-keyword">int</span> h = LoggerNameUtil.getSeparatorIndexOf(name, i);
        <span class="hljs-keyword">if</span> (h == -<span class="hljs-number">1</span>) &#123;
            childName = name;
        &#125; <span class="hljs-keyword">else</span> &#123;
            childName = name.substring(<span class="hljs-number">0</span>, h);
        &#125;
        <span class="hljs-comment">// 记录当前的分割位置（祖先节点到哪里了）</span>
        i = h + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">synchronized</span> (logger) &#123;
            <span class="hljs-comment">//这里是遍历子节点，拿到Logger，只找一级</span>
            childLogger = logger.getChildByName(childName);
            <span class="hljs-comment">//没有子节点了，创建Logger</span>
            <span class="hljs-keyword">if</span> (childLogger == <span class="hljs-keyword">null</span>) &#123;
                childLogger = logger.createChildByName(childName);
                <span class="hljs-comment">//添加缓存</span>
                loggerCache.put(childName, childLogger);
                incSize();
            &#125;
        &#125;
        <span class="hljs-comment">//返回logger</span>
        logger = childLogger;
        <span class="hljs-keyword">if</span> (h == -<span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">return</span> childLogger;
        &#125;
    &#125;
&#125;</code></pre>

<p>到这里就拿到了Logger进行了打印日志了，但是注意日志记录加载过程中，会经过turbofilter进行初步过滤，再经过RegularFilter进行过滤Appender，如果Appender都通过了再通过layout格式化日志，在经过Encoder把日志写入输出流显示。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>logback中使用MDC</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/11.logback%E4%B8%AD%E4%BD%BF%E7%94%A8MDC.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>logback 设计的目标之一是审计与调试复杂的分布式应用。大部分的分布式系统需要同时处理多个客户端。在一个系统典型的多线程实现中，不同的线程处理不同的客户端。一种可能但是不建议的方式是在每个客户端实例化一个新的且独立的 logger，来区分一个客户端与另一个客户端的日志输出。这种方式会导致 logger 急剧增加并且会增加维护成本。</p>
<p>一种轻量级的技术是给每个为客户端服务的 logger 打一个标记。Neil Harrison 在 Patterns for Logging Diagnostic Messages in Pattern Languages of Program Design 3, edited by R. Martin, D. Riehle, and F. Buschmann (Addison-Wesley, 1997) 这本书中描述了这种方法。logback 在 SLF4J API 利用了这种技术的变体：诊断上下文映射 (MDC)。</p>
<p>为了给每个请求打上唯一的标记，用户需要将上下文信息放到 MDC (Mapped Diagnostic Context 的缩写) 中。下面列出了 MDC 类中主要的部分。</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> org.slf4j;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MDC</span> </span>&#123;
  <span class="hljs-comment">// 将上下文的值作为 MDC 的 key 放到ThreadContext的 map 中</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, String val)</span></span>;

  <span class="hljs-comment">// 通过 key 获取上下文标识</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>;

  <span class="hljs-comment">// 通过 key 移除上下文标识</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(String key)</span></span>;

  <span class="hljs-comment">// 清除 MDC 中所有的 entry</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>

<p>MDC 类中只包含静态方法。它让开发人员可以在 诊断上下文 中放置信息，而后通过特定的 logback 组件去获取。MDC 在 每个线程的基础上 管理上下文信息。通常，当为一个新客户端启动服务时，开发人员会将特定的上文信息插入到 MDC 中。例如，客户端 id，客户端 IP 地址，请求参数等。如果 logback 组件配置得当的话，会自动在每个日志条目中包含这些信息。</p>
<p>请注意，logback-classic 实现的 MDC，假设值以适当的频率放置。还需注意的一点是，子线程不会自动继承父线程的 MDC。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MdcSample</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        LoggerHelper.reconfigure(<span class="hljs-string">&quot;logback-mdc.xml&quot;</span>);
        Logger logger = LoggerFactory.getLogger(MdcSample.class);
        MDC.put(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-string">&quot;uncle&quot;</span>);
        MDC.put(<span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);
        logger.info(<span class="hljs-string">&quot;user visited home page..&quot;</span>);
    &#125;
&#125;</code></pre>

<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;1 second&quot;</span> <span class="hljs-attr">packagingData</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span></span>
<span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %green([%thread]) %highlight(%-5level) %boldMagenta(%logger) - %cyan(%msg%n)&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>用户：%mdc&#123;userId&#125; $&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
            <span class="hljs-comment">&lt;!--在头部打印出pattern--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
        <span class="hljs-comment">&lt;!--立即刷新到流--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<pre><code class="hljs plain">用户：uncle 2020-12-04 23:17:59 [main] INFO  com.unclezs.samples.log.slf4j.logback.MdcSample - user visited home page..</code></pre>

<h2 id="正确移除MDC"><a href="#正确移除MDC" class="headerlink" title="正确移除MDC"></a>正确移除MDC</h2><p>因为服务端经常会复用线程，MDC又是利用ThreadContext实现的，所以可能会出现脏数据，最好使用一个过滤器在每次请求到来或者结束的时候移除掉MDC中的数据。</p>
<p>可以通过getCopyOfContextMap来装载初始值。</p>
<p>可以查看ch.qos.logback.classic.util.LogbackMDCAdapter了解MDC的实现。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>logback中的Filter</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/10.logback%E4%B8%AD%E7%9A%84Filter.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>logback 过滤器基于三元逻辑，允许它们组装或者链接在一起组成一个任意复杂的过滤策略。它们在很大程度上受到 Linux iptables 的启发。</p>
<p>在 logback-classic 中，有两种类型的过滤器，regular 过滤器以及 turbo 过滤器。</p>
<h2 id="Regular"><a href="#Regular" class="headerlink" title="Regular"></a>Regular</h2><p>reqular 过滤器继承自 Filter 这个抽象类。本质上它由一个单一的 decide() 方法组成，接收一个 ILoggingEvent 实例作为参数。</p>
<p>过滤器通过一个有序列表进行管理，并且基于三元逻辑。每个过滤器的 decide(ILoggingEvent event) 被依次调用。这个方法返回 FilterReply 枚举值中的一个， DENY, NEUTRAL 或者 ACCEPT。如果 decide() 方法返回 DENY，那么日志事件会被丢弃掉，并且不会考虑后续的过滤器。如果返回的值是 NEUTRAL，那么才会考虑后续的过滤器。如果没有其它的过滤器了，那么日志事件会被正常处理。如果返回值是 ACCEPT，那么会跳过剩下的过滤器而直接被处理。</p>
<p>在 logback-classic 中，过滤器可以被直接添加到 Appender 实例上。通过将一个或者多个过滤器添加到 appender 上，你可以通过任意标准来过滤日志事件。例如，日志消息的内容，MDC 的内容，时间，或者日志事件的其它部分。</p>
<h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>创建一个自己的过滤器非常的简单。只需要继承 Filter 并且实现 decide() 方法就可以了。</p>
<p>自定一个过滤器，把日志内容包含“different”的不打印</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/3 1:05 上午</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomRegularFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Filter</span>&lt;<span class="hljs-title">ILoggingEvent</span>&gt; </span>&#123;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> FilterReply <span class="hljs-title">decide</span><span class="hljs-params">(ILoggingEvent event)</span> </span>&#123;
    <span class="hljs-keyword">return</span> event.getMessage().contains(<span class="hljs-string">&quot;different&quot;</span>)?FilterReply.DENY:FilterReply.ACCEPT;
  &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/12/04 17:26</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterSample</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    LoggerHelper.reconfigure(<span class="hljs-string">&quot;logback-filter.xml&quot;</span>);
    Logger logger = LoggerFactory.getLogger(FilterSample.class);
    logger.info(<span class="hljs-string">&quot;different log&quot;</span>);
    logger.info(<span class="hljs-string">&quot;same log&quot;</span>);
  &#125;
&#125;</code></pre>


<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;1 second&quot;</span> <span class="hljs-attr">packagingData</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span></span>
<span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %green([%thread]) %highlight(%-5level) %boldMagenta(%logger) - %cyan(%msg%n)&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback.filter.CustomRegularFilter&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
            <span class="hljs-comment">&lt;!--在头部打印出pattern--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
        <span class="hljs-comment">&lt;!--立即刷新到流--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>


<h3 id="LevelFilter"><a href="#LevelFilter" class="headerlink" title="LevelFilter"></a>LevelFilter</h3><p>LevelFilter 基于级别来过滤日志事件。如果事件的级别与配置的级别相等，过滤器会根据配置的 onMatch 与 onMismatch 属性，接受或者拒绝事件。如下是一个简单的示例：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span></code></pre>

<h3 id="ThresholdFilter"><a href="#ThresholdFilter" class="headerlink" title="ThresholdFilter"></a>ThresholdFilter</h3><p>ThresholdFilter 基于给定的临界值来过滤事件。如果事件的级别等于或高于给定的临界值，当调用 decide() 时，ThresholdFilter 将会返回 NEUTRAL。但是事件的级别低于临界值将会被拒绝。下面是一个简单的例子：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span></code></pre>

<h3 id="EvaluatorFilter"><a href="#EvaluatorFilter" class="headerlink" title="EvaluatorFilter"></a>EvaluatorFilter</h3><p>EvaluatorFilter 是一个通用的过滤器，它封装了一个 EventEvaluator。顾名思义，EventEvaluator 根据给定的标准来评估给定的事件是否符合标准。在 match 和 mismatch 的情况下，EvaluatorFilter 将会返回 onMatch 或 onMismatch 指定的值。</p>
<p>注意 EventEvaluator 是一个抽象类。你可以通过继承 EventEvaluator 来实现自己事件评估逻辑。</p>
<p><strong>GEventEvaluator</strong>是EventEvaluator一个实现类，通过Groogy脚本判断是否需要过滤。</p>
<h2 id="JaninoEventEvaluator"><a href="#JaninoEventEvaluator" class="headerlink" title="JaninoEventEvaluator"></a>JaninoEventEvaluator</h2><p>logback-classic 附带的另外一个 EventEvaluator 的具体实现名为 JaninoEventEvaluator，它接受任意返回布尔值的 Java 代码块作为评判标准。我们把这种 Java 布尔表达式称为 “评估表达式”。评估表达式在事件过滤中可以更加的灵活。JaninoEventEvaluator 需要 Janino 类库。请参见相关章节进行设置。跟 JaninoEventEvaluator 相比，GEventEvaluator 使用 Groovy 语言，使用起来非常方便。但是 JaninoEventEvaluator 将使用运行更快的等效表达式。</p>
<p>评估表达式在解析配置文件期间被动态编译。作为用户，不需要考虑实际的情况。但是，你需要确保你的 Java 表达式是有效的，保证它的评估结果为 true 或 false。</p>
<p>评估表达式对当前日志事件进行评估。logback-classic 自动导出日志事件的各种字段作为变量，为了可以从评估表达式访问。这些导出的变量是大小写敏感的，如下表所示：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>event</td>
<td>LoggingEvent</td>
<td>日志请求的原始日志事件。下面所有的变量都来自这个日志事件。例如，event.getMessage() 返回的字符串跟下面的 message 变量返回的字符串一样。</td>
</tr>
<tr>
<td>message</td>
<td>String</td>
<td>日志请求的原始信息。例如，对于 logger I，当你写的是 I.info(“Hello {}“, name); 时，name 的值被指定为 “Alice”，消息就为 “Hello {}“。</td>
</tr>
<tr>
<td>formattedMessage</td>
<td>String</td>
<td>日志请求中格式化后的消息。例如，对于 logger I，当你写的是 I.info(“Hello {}“, name); 时，name 的值被指定为 “Alice”，格式化后的消息就为 “Hello Alice”。</td>
</tr>
<tr>
<td>logger</td>
<td>String</td>
<td>logger 的名字</td>
</tr>
<tr>
<td>loggerContext</td>
<td>LoggerContextVO</td>
<td>日志事件属于 logger 上下文中哪个受限的视图 (值对象)</td>
</tr>
<tr>
<td>level</td>
<td>int</td>
<td>事件级别对应的 int 值。用来创建包含级别的表达式。默认值是 DEBUG，INFO，WARN 以及 ERROR 也是有效的。所以 level &gt; INFO 是有效的表达式。</td>
</tr>
<tr>
<td>timeStamp</td>
<td>long</td>
<td>日志事件创建的时间</td>
</tr>
<tr>
<td>marker</td>
<td>Marker</td>
<td>与日志请求相关的 Marker 对象。注意，marker 可能会为 null，因此你需要对这种情况进行检查，进而避免  NullPointerException。</td>
</tr>
<tr>
<td>mdc</td>
<td>Map</td>
<td>创建日志事件时包含的所有的 MDC 值的一个映射。可以通过 mdc.get(“myKey”) 来获取 MDC 中对应的值。在 0.9.30 版本的 logback-classic，mdc 变量永远不会为 null。java.util.Map 类型是非参数化的，因为 Janino 不支持泛型。因此，mdc.get() 返回值的类型是 Object 而不是 String。但是可以将返回值强制转换为 String。例如， ((String) mdc.get(“k”)).contains(“val”)。</td>
</tr>
<tr>
<td>throwable</td>
<td>java.lang.Throwable</td>
<td>如果日志事件没有相关的异常，那么变量 “throwable” 的值为 null。”throwable” 不可以被序列化。所以在远程服务器上，这个值永远为 null。想要使用与位置无关的表达式，可以使用下面的 throwableProxy。</td>
</tr>
<tr>
<td>throwableProxy</td>
<td>IThrowableProxy</td>
<td>日志事件的异常代理。如果日志事件没有相关的异常，那么 throwableProxy 的值为 null。与 “throwable” 相反，即使在远程服务器上序列化之后，日志事件相关的异常也不会为 null。</td>
</tr>
</tbody></table>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;</span>&gt;</span>      
      <span class="hljs-tag">&lt;<span class="hljs-name">evaluator</span>&gt;</span> <span class="hljs-comment">&lt;!-- defaults to type ch.qos.logback.classic.boolex.JaninoEventEvaluator --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">expression</span>&gt;</span>return message.contains(&quot;billing&quot;);<span class="hljs-tag">&lt;/<span class="hljs-name">expression</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">evaluator</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">OnMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">OnMismatch</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">OnMatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">OnMatch</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>
        %-4relative [%thread] %-5level %logger - %msg%n
      <span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<p>上面的配置将 EvaluatorFilter 添加到 ConsoleAppender。一个类型为 JaninoEventEvaluator 的 evaluator 之后被注入到 EvaluatorFilter 中。&lt;evaluator 在缺少 class 属性的情况下，Joran 会指定 evaluator 的默认类型为 JaninoEventEvaluator。这是少数几个需要 Joran 默认指定类型的组件。</p>
<p>expression 元素对应刚才讨论过的评估表达式。表达式 return message.contains(“billing”); 返回一个布尔值。message 变量会被 JaninoEventEvaluator 自动导出。</p>
<p>甚至可以是更复杂的表达式</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">evaluator</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">expression</span>&gt;</span>
    if(logger.startsWith(&quot;org.apache.http&quot;))
      return true;
    if(mdc == null || mdc.get(&quot;entity&quot;) == null)
      return false;
    String payee = (String) mdc.get(&quot;entity&quot;);
    if(logger.equals(&quot;org.apache.http.wire&quot;) <span class="hljs-symbol">&amp;amp;</span><span class="hljs-symbol">&amp;amp;</span>
        payee.contains(&quot;someSpecialValue&quot;) <span class="hljs-symbol">&amp;amp;</span><span class="hljs-symbol">&amp;amp;</span>
        !message.contains(&quot;someSecret&quot;)) &#123;
      return true;
    &#125;
    return false;
  <span class="hljs-tag">&lt;/<span class="hljs-name">expression</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">evaluator</span>&gt;</span></code></pre>

<h3 id="Matchers"><a href="#Matchers" class="headerlink" title="Matchers"></a>Matchers</h3><p>虽然可以通过调用 String 类的 matches() 方法来进行模式匹配，但是每次调用 filter 都需要耗费时间重新编译一个新的 Pattern 对象。为了消除这种影响，你可以预先定义一个或者多个 Matcher 对象。一旦定义了一个 matcher，就可以在评估表达式中重复使用了。</p>
<pre><code class="hljs xml">
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">evaluator</span>&gt;</span>        
        <span class="hljs-tag">&lt;<span class="hljs-name">matcher</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Name</span>&gt;</span>odd<span class="hljs-tag">&lt;/<span class="hljs-name">Name</span>&gt;</span>
          <span class="hljs-comment">&lt;!-- filter out odd numbered statements --&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">regex</span>&gt;</span>statement [13579]<span class="hljs-tag">&lt;/<span class="hljs-name">regex</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">matcher</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">expression</span>&gt;</span>odd.matches(formattedMessage)<span class="hljs-tag">&lt;/<span class="hljs-name">expression</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">evaluator</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">OnMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">OnMismatch</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">OnMatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">OnMatch</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="TurboFilters"><a href="#TurboFilters" class="headerlink" title="TurboFilters"></a>TurboFilters</h2><p>TurboFilter 对象都继承 TurboFilter 抽象类。对于 regular 过滤器，它们使用三元逻辑来返回对日志事件的评估。</p>
<p>总之，它们跟之前提到的过滤工作原理差不多。主要的不同点在于 Filter 与 TurboFilter 对象。</p>
<p>TurboFilter 对象被绑定刚在 logger 上下文中。因此，在使用给定的 appender 以及每次发出的日志请求都会调用 TurboFilter 对象。因此，turbo 过滤器可以为日志事件提供高性能的过滤，即使是在事件被创建之前。</p>
<h3 id="实现自己的-TurboFilter"><a href="#实现自己的-TurboFilter" class="headerlink" title="实现自己的 TurboFilter"></a>实现自己的 TurboFilter</h3><p>想要创建自己的 TurboFilter 组件，只需要继承 TurboFilter 这个抽象类就可以了。跟之前的一样，想要实现定制的过滤器对象，开发自定义的 TurboFilter，只需要实现 decide() 方法就可以了。下一个例子，我们会创建一个稍微复杂一点的过滤器：</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/4 10:32 下午</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTurboFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TurboFilter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterReply <span class="hljs-title">decide</span><span class="hljs-params">(Marker marker, Logger logger, Level level, String format, Object[] params, Throwable t)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> FilterReply.DENY;
        &#125;
        <span class="hljs-keyword">return</span> FilterReply.ACCEPT;
    &#125;
&#125;</code></pre>


<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;1 second&quot;</span> <span class="hljs-attr">packagingData</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span></span>
<span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %green([%thread]) %highlight(%-5level) %boldMagenta(%logger) - %cyan(%msg%n)&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">turboFilter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback.filter.CustomTurboFilter&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback.filter.CustomRegularFilter&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
            <span class="hljs-comment">&lt;!--在头部打印出pattern--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
        <span class="hljs-comment">&lt;!--立即刷新到流--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>


<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>loback-classic 附带了几个 TurboFilter 类可以开箱即用。MDCFilter 用来检查给定的值在 MDC 中是否存在。DynamicThresholdFilter 根据 MDC key/level 相关的阀值来进行过滤。MarkerFilter 用来检查日志请求中指定的 marker 是否存在。</p>
<ul>
<li>DuplicateMessageFilter</li>
<li>MarkerFilter</li>
<li>MDCFilter</li>
<li>DynamicThresholdFilter</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>logback中的Layouts</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/9.logback%E4%B8%AD%E7%9A%84Layouts.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Layout就是负责将事件对象转换为String对象的，而且支持自定义，你可以把日志转换为其他格式html，json等等。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Layout</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ContextAware</span>, <span class="hljs-title">LifeCycle</span> </span>&#123;

  <span class="hljs-function">String <span class="hljs-title">doLayout</span><span class="hljs-params">(E event)</span></span>;
  <span class="hljs-function">String <span class="hljs-title">getFileHeader</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">String <span class="hljs-title">getPresentationHeader</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">String <span class="hljs-title">getFileFooter</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">String <span class="hljs-title">getPresentationFooter</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">String <span class="hljs-title">getContentType</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>

<h2 id="自定义Layout"><a href="#自定义Layout" class="headerlink" title="自定义Layout"></a>自定义Layout</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LayoutBase</span>&lt;<span class="hljs-title">ILoggingEvent</span>&gt; </span>&#123;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doLayout</span><span class="hljs-params">(ILoggingEvent event)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;自定义布局器：&quot;</span>+ (event.getTimeStamp() - event.getLoggerContextVO().getBirthTime())
        + <span class="hljs-string">&quot; &quot;</span>
        + event.getLevel()
        + <span class="hljs-string">&quot; [&quot;</span>
        + event.getThreadName()
        + <span class="hljs-string">&quot;] &quot;</span>
        + event.getLoggerName()
        + <span class="hljs-string">&quot; - &quot;</span>
        + event.getFormattedMessage()
        + CoreConstants.LINE_SEPARATOR;
  &#125;
&#125;</code></pre>

<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;1 second&quot;</span> <span class="hljs-attr">packagingData</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span></span>
<span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %green([%thread]) %highlight(%-5level) %boldMagenta(%logger) - %cyan(%msg%n)&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback.layouts.MyLayout&quot;</span>/&gt;</span>
            <span class="hljs-comment">&lt;!--立即刷新到流--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="本文代码"><a href="#本文代码" class="headerlink" title="本文代码"></a>本文代码</h2><p><a href="https://github.com/unclezs/samples/tree/main/samples-log/log-slf4j-logback">log-slf4j-logback</a></p>
<h2 id="PatternLayout"><a href="#PatternLayout" class="headerlink" title="PatternLayout"></a>PatternLayout</h2><p>logback 配备了一个更加灵活的 layout 叫做 PatternLayout。跟所有的 layout 一样，PatternLayout 接收一个日志事件并返回一个字符串。但是，可以通过调整 PatternLayout 的转换模式来进行定制。</p>
<p>PatternLayout 中的转换模式与 C 语言中 printf() 方法中的转换模式密切相关。转换模式由字面量与格式控制表达式也叫转换说明符组成。你可以在转换模式中自由的插入字面量。每一个转换说明符由一个百分号开始 ‘%’，后面跟随可选的格式修改器，以及用综括号括起来的转换字符与可选的参数。转换字符需要转换的字段。如：logger 的名字，日志级别，日期以及线程名。格式修改器控制字段的宽度，间距以及左右对齐。</p>
<p>正如我们已经在其它地方提到过的，FileAppender 及其子类需要一个 encoder。因为，当将 FileAppender 及其子类与 PatternLayout 结合使用时，PatternLayout 必须用 encoder 包裹起来。鉴于 FileAppender/PatternLayout 结合使用很常见，因此 logback 单独设计了一个名叫 PatternLayoutEncoder 的 encoder，包裹了一个 PatternLayout，因此它可以被当作一个 encoder。下面是通过代码配置 ConsoleAppender 与 PatternLayoutEncoder 使用的例子：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PatternSample</span> </span>&#123;

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    Logger rootLogger = (Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    LoggerContext loggerContext = rootLogger.getLoggerContext();
    loggerContext.reset();

    PatternLayoutEncoder encoder = <span class="hljs-keyword">new</span> PatternLayoutEncoder();
    encoder.setContext(loggerContext);
    encoder.setPattern(<span class="hljs-string">&quot;%-5level [%thread]: %message%n&quot;</span>);
    encoder.start();

    ConsoleAppender&lt;ILoggingEvent&gt; appender = <span class="hljs-keyword">new</span> ConsoleAppender&lt;ILoggingEvent&gt;();
    appender.setContext(loggerContext);
    appender.setEncoder(encoder); 
    appender.start();

    rootLogger.addAppender(appender);

    rootLogger.debug(<span class="hljs-string">&quot;Message 1&quot;</span>); 
    rootLogger.warn(<span class="hljs-string">&quot;Message 2&quot;</span>);
  &#125; 
&#125;</code></pre>

<p>转化后输出：</p>
<pre><code class="hljs log">DEBUG [main]: Message 1 
WARN  [main]: Message 2</code></pre>

<h2 id="格式化日志的写法"><a href="#格式化日志的写法" class="headerlink" title="格式化日志的写法"></a>格式化日志的写法</h2><table>
<thead>
<tr>
<th align="center"><strong>格式化字符</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">%logger{length}</td>
<td align="center">logger的名字，长度是最大长度，如果全限定类名超过长度了就进行简写，但是类名不会被简写 eg: %logger{3}: com.unclezs.Test=&gt;c.u.Test</td>
</tr>
<tr>
<td align="center">%class{length}</td>
<td align="center">调用者的全限定类名，通过计算的，比价慢，一般不用</td>
</tr>
<tr>
<td align="center">%contextName</td>
<td align="center">输出日志事件附加到的 logger 上下文的名字</td>
</tr>
<tr>
<td align="center">%date{pattern,[timezone]}</td>
<td align="center">时区可选，显示当前时间</td>
</tr>
<tr>
<td align="center">caller{depth}、caller{depthStart..depthEnd}、caller{depth, evaluator-1, ... evaluator-n}、caller{depthStart..depthEnd, evaluator-1, ... evaluator-n}</td>
<td align="center">%caller{2} 显示2层调用栈</td>
</tr>
<tr>
<td align="center">%line</td>
<td align="center">行号，效率低，不建议使用</td>
</tr>
<tr>
<td align="center">%n</td>
<td align="center">换行</td>
</tr>
<tr>
<td align="center">%level</td>
<td align="center">日志级别</td>
</tr>
<tr>
<td align="center">%relative</td>
<td align="center">打日志消耗时间毫秒数</td>
</tr>
<tr>
<td align="center">%thread</td>
<td align="center">输出生成日志事件的线程名。</td>
</tr>
<tr>
<td align="center">m / msg / message</td>
<td align="center">日志信息</td>
</tr>
<tr>
<td align="center">method</td>
<td align="center">调用打印日志的所在方法名字，比较慢，不建议用</td>
</tr>
<tr>
<td align="center">X/mdc</td>
<td align="center">如果 MDC 转换字符后面跟着用花括号括起来的 ，例 %mdc{userid}，那么 ‘userid’ 所对应 MDC 的值将会输出。如果该值为 null，那么通过 :- 指定的默认值 将会输出。如果没有指定默认值，那么将会输出空字符串。 如果没有指定的 key，那么 MDC 的整个内容将会以 “key1=val1, key2=val2” 的格式输出。</td>
</tr>
<tr>
<td align="center">exception{depth}/throwable{depth}</td>
<td align="center">depth: short第一行、full全部、数字指定几行。</td>
</tr>
<tr>
<td align="center">%xException /xE/xThrowbale</td>
<td align="center">和exception一样，不过会在每行后面显示jar包名字和版本号</td>
</tr>
<tr>
<td align="center">%rootException</td>
<td align="center">和xeception一样，反向输出</td>
</tr>
<tr>
<td align="center">marker</td>
<td align="center">输出相关的标签</td>
</tr>
<tr>
<td align="center">property{key}</td>
<td align="center">输出属性值</td>
</tr>
<tr>
<td align="center">replace(p){r, t}</td>
<td align="center">在子模式 ‘p’ 产生的字符中，将所有出现正则表达式 ‘r’ 的地方替换为 ‘t’。例如，”%replace(%msg){‘\s’, ‘’}“ 将会移除事件消息中所有空格。</td>
</tr>
</tbody></table>
<h2 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h2><p>默认情况下，相关信息按照原样输出。但是，在格式修改器的帮助下，可以对每个数据字段进行对齐，以及更改最大最小宽度。</p>
<p>可选的格式修改器放在百分号跟转换字符之间。</p>
<p>第一个可选的格式修改器是左对齐标志，也就是减号 (-) 字符。接下来的是最小字段宽度修改器，它是一个十进制常量，表示输出至少多少个字符。如果字段包含很少的数据，它会选择填充左边或者右边，直到满足最小宽度。默认是填充左边 (右对齐)，但是你可以通过左对齐标志来对右边进行填充。填充字符为空格。如果字段的数据大于最小字段的宽度，会自动扩容去容纳所有的数据。字段的数据永远不会被截断。</p>
<p>这个行为可以通过使用最大字段宽度修改器来改变，它通过一个点后面跟着一个十进制常量来指定。如果字段的数据长度大于最大字段的宽度，那么会从数据字段的开头移除多余的字符。举个🌰，如果最大字段的宽度是 8，数据长度是十个字符的长度，那么开头的两个字符将会被丢弃。这个行为跟 C 语言中 printf 函数从后面开始截断的行为相违背。</p>
<p>如果想从后面开始截断，可以在点后面增加一个减号。如果是这样的话，最大字段宽度是 8，数据长度是十个字符的长度，那么最后两个字符将会被丢弃。</p>
<p>下面是各种格式修改器的例子：</p>
<table>
<thead>
<tr>
<th><strong>格式修改器</strong></th>
<th><strong>左对齐</strong></th>
<th><strong>最小宽度</strong></th>
<th><strong>最大宽度</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>%20logger</td>
<td>false</td>
<td>20</td>
<td>none</td>
<td>如果 logger 的名字小于 20 个字符的长度，那么会在左边填充空格</td>
</tr>
<tr>
<td>%-20logger</td>
<td>true</td>
<td>20</td>
<td>none</td>
<td>如果 logger 的名字小于 20 个字符的长度，那么会在右边填充空格</td>
</tr>
<tr>
<td>%.30logger</td>
<td>NA</td>
<td>none</td>
<td>30</td>
<td>如果 logger 的名字大于 30 个字符的长度，那么从前面开始截断</td>
</tr>
<tr>
<td>%20.30logger</td>
<td>false</td>
<td>20</td>
<td>30</td>
<td>如果 logger 的名字大于 20 个字符的长度，那么会从左边填充空格。但是如果 logger 的名字大于 30 字符，将会从前面开始截断</td>
</tr>
<tr>
<td>%-20.30logger</td>
<td>true</td>
<td>20</td>
<td>30</td>
<td>如果 logger 的名字小于 20 个字符的长度，那么从右边开始填充空格。但是如果 logger 的名字大于 30 个字符，将会从前面开始截断</td>
</tr>
<tr>
<td>%.-30logger</td>
<td>NA</td>
<td>none</td>
<td>30</td>
<td>如果 logger 的名字大于 30 个字符的长度，那么从后面开始截断</td>
</tr>
</tbody></table>
<p>下面的表格列出了格式修改器截断的例子。但是请注意综括号 “[]” 不是输出结果的一部分，它只是用来区分输出的长度：</p>
<table>
<thead>
<tr>
<th><strong>格式修改器</strong></th>
<th><strong>logger 的名字</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>[%20.20logger]</td>
<td>main.Name</td>
<td>[           main.Name]</td>
</tr>
<tr>
<td>[%-20.20logger]</td>
<td>main.Name</td>
<td>[main.Name           ]</td>
</tr>
<tr>
<td>[%10.10logger]</td>
<td>main.foo.foo.bar.Name</td>
<td>[o.bar.Name]</td>
</tr>
<tr>
<td>[%10.-10logger]</td>
<td>main.foo.foo.bar.Name</td>
<td>[main.foo.f]</td>
</tr>
</tbody></table>
<h2 id="转义字符的选项"><a href="#转义字符的选项" class="headerlink" title="转义字符的选项"></a>转义字符的选项</h2><pre><code class="hljs plain">&lt;pattern&gt;%-5level - %replace(%msg)&#123;&#39;\d&#123;14,16&#125;&#39;, &#39;XXXX&#39;&#125;%n&lt;&#x2F;pattern&gt;</code></pre>

<p>我们传递 \d{16} 与 XXXX 给 replace 转换字符。它将消息中 14，15 或者 16 位的数字替换为 XXXX，用来混淆信用卡号码。在正则表达式中，”\d” 表示一个数字的简写。”{14,16}” 会被解析成 “{14,16}”，也就是说前一个项将会被重复至少 14 次，至多 16 次。</p>
<h2 id="特殊的圆括号"><a href="#特殊的圆括号" class="headerlink" title="特殊的圆括号"></a>特殊的圆括号</h2><p>在 logback 里，模式字符串中的圆括号被看作为分组标记。因此，它能够对子模式进行分组，并且直接对子模式进行格式化。在 0.9.27 版本，logback 开始支持综合转换字符，例如 %replace 可以对子模式进行转换。</p>
<p>例如一下模式：</p>
<pre><code class="hljs plain">%-30(%d&#123;HH:mm:ss.SSS&#125; [%thread]) %-5level %logger&#123;32&#125; - %msg%n</code></pre>
<p>将会对子模式 “%d{HH:mm:ss.SSS} [%thread]” 进行分组输出，为了在少于 30 个字符时进行右填充。</p>
<pre><code class="hljs plain">13:09:30 [main]            DEBUG c.q.logback.demo.ContextListener - Classload hashcode is 13995234
13:09:30 [main]            DEBUG c.q.logback.demo.ContextListener - Initializing for ServletContext
13:09:30 [main]            DEBUG c.q.logback.demo.ContextListener - Trying platform Mbean server
13:09:30 [pool-1-thread-1] INFO  ch.qos.logback.demo.LoggingTask - Howdydy-diddly-ho - 0
13:09:38 [btpool0-7]       INFO  c.q.l.demo.lottery.LotteryAction - Number: 50 was tried.
13:09:40 [btpool0-7]       INFO  c.q.l.d.prime.NumberCruncherImpl - Beginning to factor.
13:09:40 [btpool0-7]       DEBUG c.q.l.d.prime.NumberCruncherImpl - Trying 2 as a factor.
13:09:40 [btpool0-7]       INFO  c.q.l.d.prime.NumberCruncherImpl - Found factor 2</code></pre>

<h2 id="高亮彩色日志"><a href="#高亮彩色日志" class="headerlink" title="高亮彩色日志"></a>高亮彩色日志</h2><p>如上所述的圆括号分组，允许对子模式进行着色。在 1.0.5 版本，PatternLayout 可以识别 “%black”，”%red”，”%green”，”%yellow”，”%blue”，”%magenta”,”%cyan”, “%white”, “%gray”, “%boldRed”,”%boldGreen”, “%boldYellow”, “%boldBlue”, “%boldMagenta””%boldCyan”, “%boldWhite” 以及 “%highlight” 作为转换字符。这些转换字符都还可以包含一个子模式。任何被颜色转换字符包裹的子模式都会通过指定的颜色输出。</p>
<p>然后在pattern中使用即可。</p>
<h2 id="Evaluators"><a href="#Evaluators" class="headerlink" title="Evaluators"></a>Evaluators</h2><p>可以用来动态判断是否需要显示某些信息，比如异常信息,调用信息。</p>
<p>由于 XML 的编码规则，&amp; 符号需要被转义为 &amp;</p>
<p>判断打印的消息中是否包含different字符串：</p>
<pre><code class="hljs plain">&lt;configuration debug&#x3D;&quot;false&quot; scan&#x3D;&quot;false&quot; scanPeriod&#x3D;&quot;1 second&quot; packagingData&#x3D;&quot;false&quot;&gt;
    &lt;evaluator name&#x3D;&quot;isError&quot;&gt;
        &lt;expression&gt;message.contains(&quot;different&quot;)&lt;&#x2F;expression&gt;
    &lt;&#x2F;evaluator&gt;
    &lt;property name&#x3D;&quot;pattern&quot;
              value&#x3D;&quot; %-4relative [%thread] %-5level - %msg%n%caller&#123;2, isError&#125;&quot;&#x2F;&gt;
    &lt;appender name&#x3D;&quot;console&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;
            &lt;pattern&gt;$&#123;pattern&#125;&lt;&#x2F;pattern&gt;
            &lt;!--在头部打印出pattern--&gt;
            &lt;outputPatternAsHeader&gt;true&lt;&#x2F;outputPatternAsHeader&gt;
        &lt;&#x2F;encoder&gt;
        &lt;!--立即刷新到流--&gt;
        &lt;immediateFlush&gt;true&lt;&#x2F;immediateFlush&gt;
    &lt;&#x2F;appender&gt;
    &lt;logger name&#x3D;&quot;com.unclezs.samples.log.slf4j.logback&quot; level&#x3D;&quot;info&quot; additivity&#x3D;&quot;false&quot;&gt;
        &lt;appender-ref ref&#x3D;&quot;console&quot;&#x2F;&gt;
    &lt;&#x2F;logger&gt;
    &lt;root level&#x3D;&quot;off&quot;&gt;
    &lt;&#x2F;root&gt;
&lt;&#x2F;configuration&gt;</code></pre>

<pre><code class="hljs log">741  [main] INFO  - test message by different level
Caller+0	 at com.unclezs.samples.log.slf4j.logback.utils.LoggerHelper.logMsg(LoggerHelper.java:46)
Caller+1	 at com.unclezs.samples.log.slf4j.logback.utils.LoggerHelper.logMsg(LoggerHelper.java:57)</code></pre>

<h2 id="自定义转换说明符"><a href="#自定义转换说明符" class="headerlink" title="自定义转换说明符"></a>自定义转换说明符</h2><p>我们可以在 PatternLayout 中使用内置的转换字符。我们也可以使用自己新建的转换字符。</p>
<p>新建一个自定义的转换字符需要两步。</p>
<p><strong>1. 自定义</strong></p>
<p>首先，你必须继承 ClassicConverter 类。ClassicConverter 对象负责从 ILoggingEvent 实例中抽取信息并输出字符串。例如，%logger 对应的转换器 LoggerConverter，可以从 ILoggingEvent 从抽取 logger 的名字，返回一个字符串。它可以缩写 logger 的名字。</p>
<p>下面是一个自定义的转换器，获取当前时间戳。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/12/04 17:03</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomNowTimeConverter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassicConverter</span> </span>&#123;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(ILoggingEvent event)</span> </span>&#123;
    <span class="hljs-keyword">return</span> String.valueOf(System.currentTimeMillis());
  &#125;
&#125;</code></pre>

<p><strong>2. 配置</strong></p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;1 second&quot;</span> <span class="hljs-attr">packagingData</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;nowTime&quot;</span></span>
<span class="hljs-tag">                    <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback.converter.CustomNowTimeConverter&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span></span>
<span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%nowTime - %cyan(%msg%n)&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
            <span class="hljs-comment">&lt;!--在头部打印出pattern--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
        <span class="hljs-comment">&lt;!--立即刷新到流--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<p><strong>3. 输出</strong></p>
<pre><code class="hljs log">1607072991810 - test message by different level
1607072991810 - test message by different level
1607072991810 - test message by different level</code></pre>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>HTMLLayout</li>
<li>XMLLayout</li>
<li>还有Logback Access包中也有提供</li>
</ul>
<h2 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h2><p><a href="http://logback.qos.ch/manual/layouts.html">Chapter 6: Layouts</a><br><a href="https://github.com/unclezs/samples/tree/main/samples-log/log-slf4j-logback">示例代码</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>logback配置中的Encoder</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/8.logback%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84Encoder.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Ecoder负责将事件转换为字节数组，并将该字节数组写出到OutputStream中</p>
<h2 id="Encoder接口"><a href="#Encoder接口" class="headerlink" title="Encoder接口"></a>Encoder接口</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Encoder</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ContextAware</span>, <span class="hljs-title">LifeCycle</span> </span>&#123;
    <span class="hljs-comment">//日志打印时头部显示内容</span>
    <span class="hljs-keyword">byte</span>[] headerBytes();
    <span class="hljs-comment">//日志转码</span>
    <span class="hljs-keyword">byte</span>[] encode(E event);
    <span class="hljs-comment">//尾部内容，通常是结束之后调用</span>
    <span class="hljs-keyword">byte</span>[] footerBytes();
&#125;</code></pre>

<h2 id="LayoutWrappingEncoder"><a href="#LayoutWrappingEncoder" class="headerlink" title="LayoutWrappingEncoder"></a>LayoutWrappingEncoder</h2><p>在0.9.19版本的Logback之前，许多Appender都依赖Layout实例来控制日志输出的格式。由于存在大量基于布局接口的代码，因此我们需要一种encoder与layout进行互操作的方法。 LayoutWrappingEncoder弥合了encoder和layout之间的差距。它实现了编码器接口，并包装了一个布局，该布局委派了将事件转换为字符串的工作。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LayoutWrappingEncoder</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">EncoderBase</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;

    <span class="hljs-keyword">protected</span> Layout&lt;E&gt; layout;
    <span class="hljs-keyword">private</span> Charset charset;
    Appender&lt;?&gt; parent;
    Boolean immediateFlush = <span class="hljs-keyword">null</span>;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] headerBytes() &#123;
        <span class="hljs-keyword">if</span> (layout == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        appendIfNotNull(sb, layout.getFileHeader());
        appendIfNotNull(sb, layout.getPresentationHeader());
        <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">0</span>) &#123;
            sb.append(CoreConstants.LINE_SEPARATOR);
        &#125;
        <span class="hljs-keyword">return</span> convertToBytes(sb.toString());
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] footerBytes() &#123;
        <span class="hljs-keyword">if</span> (layout == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        appendIfNotNull(sb, layout.getPresentationFooter());
        appendIfNotNull(sb, layout.getFileFooter());
        <span class="hljs-keyword">return</span> convertToBytes(sb.toString());
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] convertToBytes(String s) &#123;
        <span class="hljs-keyword">if</span> (charset == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> s.getBytes();
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> s.getBytes(charset);
        &#125;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] encode(E event) &#123;
        String txt = layout.doLayout(event);
        <span class="hljs-keyword">return</span> convertToBytes(txt);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (immediateFlush != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> OutputStreamAppender) &#123;
                addWarn(<span class="hljs-string">&quot;Setting the \&quot;immediateFlush\&quot; property of the enclosing appender to &quot;</span> + immediateFlush);
                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
                OutputStreamAppender&lt;E&gt; parentOutputStreamAppender = (OutputStreamAppender&lt;E&gt;) parent;
                parentOutputStreamAppender.setImmediateFlush(immediateFlush);
            &#125; <span class="hljs-keyword">else</span> &#123;
                addError(<span class="hljs-string">&quot;Could not set the \&quot;immediateFlush\&quot; property of the enclosing appender.&quot;</span>);
            &#125;
        &#125;
        started = <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre>

<h2 id="PatternLayoutEncoder"><a href="#PatternLayoutEncoder" class="headerlink" title="PatternLayoutEncoder"></a>PatternLayoutEncoder</h2><p>鉴于PatternLayout是最常用的布局，因此Logback通过PatternLayoutEncoder迎合了这种常见用例，PatternLayoutEncoder是LayoutWrappingEncoder的扩展，仅限于包装PatternLayout实例。</p>
<p>从0.9.19版开始，每当FileAppender或其子类之一配置有PatternLayout时，都必须改用PatternLayoutEncoder。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PatternLayoutEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PatternLayoutEncoderBase</span>&lt;<span class="hljs-title">ILoggingEvent</span>&gt; </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;
        PatternLayout patternLayout = <span class="hljs-keyword">new</span> PatternLayout();
        patternLayout.setContext(context);
        patternLayout.setPattern(getPattern());
        patternLayout.setOutputPatternAsHeader(outputPatternAsHeader);
        patternLayout.start();
        <span class="hljs-keyword">this</span>.layout = patternLayout;
        <span class="hljs-keyword">super</span>.start();
    &#125;
&#125;</code></pre>

<p>encoder的默认class为PatternLayoutEncoder,可以省略</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT_HIGHLIGHT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;highlightPattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">outputPatternAsHeader</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter进行并发测试之快速开始</title>
    <url>/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/Jmeter%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html</url>
    <content><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>到<a href="http://jmeter.apache.org/download_jmeter.cgi去下载。">http://jmeter.apache.org/download_jmeter.cgi去下载。</a></p>
<p>安装解压即安装，只需要配置Java环境即可。</p>
<p>点击启动即可</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201203192418.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201203192418.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<img src="https://gitee.com/unclezs/image-blog/raw/master///20201203192603.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201203192603.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="创建线程组"><a href="#创建线程组" class="headerlink" title="创建线程组"></a>创建线程组</h2><p>配置10个并发，请求一次</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201203192729.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201203192729.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h2><ol>
<li>创建Http请求</li>
<li>创建查看结果树监听器</li>
<li>运行测试</li>
</ol>
<p>监听器可以创建多个。自己慢慢试试可以。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201203193153.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201203193153.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="更加详细的文档"><a href="#更加详细的文档" class="headerlink" title="更加详细的文档"></a>更加详细的文档</h2><p><a href="https://www.cnblogs.com/imyalost/p/7062784.html">《jmeter：菜鸟入门到进阶》系列</a></p>
]]></content>
      <categories>
        <category>性能调优</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title>logback中的Appender</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/7.logback%E4%B8%AD%E7%9A%84Appender.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Appender最终负责输出日志记录事件。但是，他们可以将事件的实际格式委托给Layout或Encoder对象。每个布局/编码器都与一个且只有一个appender相关联。一些appender具有内置或固定的事件格式。因此，它们不需要布局/编码器。例如，SocketAppender可以简单地序列化日志记录事件，然后再通过网络传输它们</p>
<h2 id="AppenderBase"><a href="#AppenderBase" class="headerlink" title="AppenderBase"></a>AppenderBase</h2><p>ch.qos.logback.core.AppenderBase类是实现Appender接口的抽象类。它提供了所有Appender共享的基本功能，例如获取或设置其名称的方法，其激活状态，其布局和其过滤器。它是Logback附带的所有附加程序的超类。尽管是抽象类，但AppenderBase实际上在Append接口中实现了doAppend（）方法。</p>
<p>可以看到这是一个同步方法，最终还是调用了实现类来进行append.</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAppend</span><span class="hljs-params">(E eventObject)</span> </span>&#123;

  <span class="hljs-comment">// prevent re-entry.</span>
  <span class="hljs-keyword">if</span> (guard) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-keyword">try</span> &#123;
    guard = <span class="hljs-keyword">true</span>;

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.started) &#123;
      <span class="hljs-keyword">if</span> (statusRepeatCount++ &lt; ALLOWED_REPEATS) &#123;
        addStatus(<span class="hljs-keyword">new</span> WarnStatus(
            <span class="hljs-string">&quot;Attempted to append to non started appender [&quot;</span> + name + <span class="hljs-string">&quot;].&quot;</span>,<span class="hljs-keyword">this</span>));
      &#125;
      <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">if</span> (getFilterChainDecision(eventObject) == FilterReply.DENY) &#123;
      <span class="hljs-keyword">return</span>;
    &#125;
    
    <span class="hljs-comment">// ok, we now invoke the derived class&#x27;s implementation of append</span>
    <span class="hljs-keyword">this</span>.append(eventObject);

  &#125; <span class="hljs-keyword">finally</span> &#123;
    guard = <span class="hljs-keyword">false</span>;
  &#125;
&#125;</code></pre>

<h2 id="OutputStreamAppender"><a href="#OutputStreamAppender" class="headerlink" title="OutputStreamAppender"></a>OutputStreamAppender</h2><p>负责基于Java中java.io.OutputStream实现的一个Appender，可以结合类图了解一下</p>
<p>参数：</p>
<ul>
<li>encoder(<a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html">Encoder</a>)：编码器</li>
<li>immediateFlush(boolean)：是否立即刷新流，默认true</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201203110419.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201203110419.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="ConsoleAppender"><a href="#ConsoleAppender" class="headerlink" title="ConsoleAppender"></a>ConsoleAppender</h2><p>参数：</p>
<ul>
<li>encoder(<a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html">Encoder</a>)：编码器</li>
<li>target(String)：System.out 或者 System.err，默认前者。</li>
<li>withJansi(boolean)：是否启用Jansi，这个会开启ANSI的颜色支持。windows需要下依赖org.fusesource.jansi:jansi:1.17 ，默认false。</li>
</ul>
<h2 id="FileAppender"><a href="#FileAppender" class="headerlink" title="FileAppender"></a>FileAppender</h2><ul>
<li>append(boolean)：追加模式，文件内容追加/覆盖，默认为true</li>
<li>encoder(<a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html">Encoder</a>)：编码器</li>
<li>file(String)：文件全路径</li>
<li>prudent(boolean): 谨慎模式，开启后保证文件安全被写入，默认false</li>
</ul>
<p>例子：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">timestamp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;bySecond&quot;</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">&quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>testFile.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">append</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">append</span>&gt;</span>
    <span class="hljs-comment">&lt;!--设置为false，吞吐量更高--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">immediateFlush</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">immediateFlush</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
        
  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="RollingFileAppender"><a href="#RollingFileAppender" class="headerlink" title="RollingFileAppender"></a>RollingFileAppender</h2><p>这个是一个日志滚动记录器，也是是可以指定日志在什么情况下换一个日志文件进行存储，也是继承自FileAppnder.</p>
<p>参数：</p>
<ul>
<li>fileName(String)</li>
<li>append(boolean)</li>
<li>encoder</li>
<li>rollingPolicy：在预警达到后做的操作</li>
<li>triggeringPolicy：控制在什么条件下出发</li>
<li>prudent: 谨慎模式，FixedWindowRollingPolicy不支持，TimeBasedRollingPolicy支持。</li>
</ul>
<h3 id="rollingPolicies"><a href="#rollingPolicies" class="headerlink" title="rollingPolicies"></a>rollingPolicies</h3><ol>
<li><p>TimeBasedRollingPolicy</p>
<ul>
<li><p>fileNamePattern(String)：文件名字的格式化，指定出发</p>
</li>
<li><p>maxHistory(int)，日志文件最多多少个</p>
</li>
<li><p>totalSizeCap(int)，所有日志文件可以用的最大空间，超过了会异步删除旧的，先判断maxHistory再判断totalSizeCap。</p>
</li>
<li><p>cleanHistoryOnStart(boolean)，启动的时候删除旧的文件</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ROLLING_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>access-rolling-$&#123;today&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">append</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">append</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>%d&#123;yyyy-MM-dd,aux&#125;/%d&#123;yyyy-MM-dd_HH-mm&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">totalSizeCap</span>&gt;</span>3GB<span class="hljs-tag">&lt;/<span class="hljs-name">totalSizeCap</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre></li>
</ul>
</li>
<li><p>SizeAndTimeBasedRollingPolicy</p>
<ul>
<li><p>maxFileSize 单个文件的最大大小。</p>
</li>
<li><p>其他参数同TimeBasedRollingPolicy</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ROLLING_FILE_SIZE_TIME&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>access-rolling-$&#123;today&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">append</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">append</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>%d&#123;yyyy-MM-dd,aux&#125;/%d&#123;yyyy-MM-dd_HH-mm&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100M<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">totalSizeCap</span>&gt;</span>3GB<span class="hljs-tag">&lt;/<span class="hljs-name">totalSizeCap</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre>
</li>
</ul>
</li>
<li><p>FixedWindowRollingPolicy</p>
<ul>
<li><p>minIndex：初始,触发一次就会+1</p>
</li>
<li><p>maxIndex：最大，</p>
</li>
<li><p>fileNamePattern，文件名字，%i代表索引，%d代表时间</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_INDEX&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>test.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>tests.%i.log.zip<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">minIndex</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">minIndex</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">maxIndex</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">maxIndex</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>1MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre>

<p>第三个也看到了通过SizeBasedTriggeringPolicy达到了最大文件大小，触发索引的+1操作。到达最大值后进行归档。</p>
</li>
</ul>
</li>
</ol>
<h2 id="SiftingAppender"><a href="#SiftingAppender" class="headerlink" title="SiftingAppender"></a>SiftingAppender</h2><p>顾名思义，SiftingAppender可以根据给定的运行时属性来分离（或筛选）日志记录。例如，SiftingAppender可以根据用户会话将日志记录事件分开，以便将不同用户生成的日志放入不同的日志文件中，每个用户一个日志文件.</p>
<p>通过MDC传入userId</p>
<pre><code class="hljs java">logger.debug(<span class="hljs-string">&quot;Application started&quot;</span>);
MDC.put(<span class="hljs-string">&quot;userid&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>);
logger.debug(<span class="hljs-string">&quot;Alice says hello&quot;</span>);</code></pre>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;SIFT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.sift.SiftingAppender&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">discriminator</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>userid<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">defaultValue</span>&gt;</span>unknown<span class="hljs-tag">&lt;/<span class="hljs-name">defaultValue</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">discriminator</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">sift</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE-$&#123;userid&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;userid&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">append</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">append</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d [%thread] %level %mdc %logger&#123;35&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">sift</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;SIFT&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="自定义Appender"><a href="#自定义Appender" class="headerlink" title="自定义Appender"></a>自定义Appender</h2><ul>
<li>编写Appender</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.samples.log.slf4j.logback.appender;

<span class="hljs-keyword">import</span> ch.qos.logback.classic.encoder.PatternLayoutEncoder;
<span class="hljs-keyword">import</span> ch.qos.logback.classic.spi.ILoggingEvent;
<span class="hljs-keyword">import</span> ch.qos.logback.core.AppenderBase;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAppender</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppenderBase</span>&lt;<span class="hljs-title">ILoggingEvent</span>&gt; </span>&#123;

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_COUNT = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> limit = MAX_COUNT;

  PatternLayoutEncoder encoder;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.encoder == <span class="hljs-keyword">null</span>) &#123;
      addError(<span class="hljs-string">&quot;No encoder set for the appender named [&quot;</span> + name + <span class="hljs-string">&quot;].&quot;</span>);
      <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">super</span>.start();
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(ILoggingEvent event)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (counter &gt;= limit) &#123;
      <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-comment">//格式化</span>
    String bytes = <span class="hljs-keyword">this</span>.encoder.getLayout().doLayout(event);
    System.out.print(bytes);
    counter++;
  &#125;

  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * 通过getter setter设置</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> PatternLayoutEncoder <span class="hljs-title">getEncoder</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> encoder;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEncoder</span><span class="hljs-params">(PatternLayoutEncoder encoder)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.encoder = encoder;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.limit = limit;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLimit</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> limit;
  &#125;
&#125;</code></pre>

<ul>
<li>配置</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MY_APPENDER&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.unclezs.samples.log.slf4j.logback.appender.MyAppender&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">limit</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">limit</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;highlightPattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAppenderSample</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    Logger logger = LoggerFactory.getLogger(MyAppenderSample.class);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
      logger.info(<span class="hljs-string">&quot;第&#123;&#125;次&quot;</span>, i);
    &#125;
  &#125;
&#125;</code></pre>

<h2 id="其他appender"><a href="#其他appender" class="headerlink" title="其他appender"></a>其他appender</h2><ul>
<li>SMTP</li>
<li>DB</li>
<li>Syslog</li>
<li>Socket</li>
</ul>
<p>略，官网查看 <a href="http://logback.qos.ch/manual/appenders.html#SocketAppender">Logback Appender</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>logback配置文件语法</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/6.logback%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h2><p>因为logback的配置十分灵活，所以无法通过一个DTD文件或者XML Schema来指定允许的语法。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201203001928.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201203001928.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="标签名区分大小写"><a href="#标签名区分大小写" class="headerlink" title="标签名区分大小写"></a>标签名区分大小写</h2><p>对于特定的标签名字是大小写不敏感的，比如<logger>, <Logger> 和 <LOGGER>都是合法的配置，但是<xyz>只能用</xyz>关闭，不能是<XyZ>，但是针对驼峰规则是适用的，比如<xyz>只能用</Xyz>关闭，不能是<xYz>。驼峰规则可以参考<a href="http://en.wikipedia.org/wiki/CamelCase">维基百科camelCase convention</a></p>
<h2 id="configuration标签"><a href="#configuration标签" class="headerlink" title="configuration标签"></a>configuration标签</h2><p>根标签，其中可以包含:</p>
<ul>
<li>Appender</li>
<li>Logger</li>
<li>Root</li>
<li>property</li>
</ul>
<h2 id="logger标签"><a href="#logger标签" class="headerlink" title="logger标签"></a>logger标签</h2><ul>
<li>name(string): 必填，logger的名称</li>
<li>additivity（boolean）：选填，是否最累加Appender（是否继承是用父logger的Appender）</li>
<li>level(TRACE,DEBUG,INFO,WARN,ERROR,ALL,OFF,INHERITED):选填，不填则同INHERITED，代表继承父logger的日志级别，大小写不敏感。 </li>
<li>appender-ref：选填，子标签（非属性），可以配置多个。中有ref标签指定Appender的name.</li>
</ul>
<h2 id="root标签"><a href="#root标签" class="headerlink" title="root标签"></a>root标签</h2><p>在整个配置文件中只能存在一个，可以当做是一个name为”ROOT”的Logger标签，但是不能有additivity属性，全局只能存在一个。</p>
<ul>
<li>level（TRACE, DEBUG, INFO, WARN, ERROR, ALL or OFF）：选填，不填则默认为debug</li>
<li>appender-ref：同logger</li>
</ul>
<h2 id="appenders标签"><a href="#appenders标签" class="headerlink" title="appenders标签"></a>appenders标签</h2><ul>
<li><p>name(string):必填，名称，用于引用</p>
</li>
<li><p>class(string):必填，Appender全限定类名，指定Appender</p>
</li>
<li><encoder></li>
<li><layout></li>
<li><filter>

</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201203004908.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201203004908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="设置上下文名称"><a href="#设置上下文名称" class="headerlink" title="设置上下文名称"></a>设置上下文名称</h2><p>每个logger都属于loggerContext, loggerContext默认的名字是“default”,这个名字可以设置</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>myAppName<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d %contextName [%t] %level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>可以用<property>定义变量，在 1.0.7 版本之后可以使用<variable>互换。</p>
<p>可以通过file属性引入指定路径的properties文件进行变量填充。</p>
<p>通过resource属性可以加载classpath下面的properties文件。</p>
<p>可以通过${xxx}读取变量，可以是声明的变量，也可以是System.properties</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;USER_HOME&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/home/sebastien&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;src/main/java/resource/var.properties&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;resource1.properties&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;USER_HOME&#125;/myApp.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="变量的范围"><a href="#变量的范围" class="headerlink" title="变量的范围"></a>变量的范围</h2><p>${xxx}到底可以引用哪些地方的变量呢？</p>
<p>读取顺序依次：</p>
<ol>
<li>配置文件直接定义的</li>
<li>LoggerContext</li>
<li>VM的参数列表</li>
<li>环境变量</li>
</ol>
<p>可以通过scope指定property的作用域,可选值:”local”, “context” 和 “system”，不填默认为local</p>
<p>定义一个context作用域的变量:</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;nodeId&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;firstNode&quot;</span> /&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>/opt/$&#123;nodeId&#125;/myApp.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="变量的默认值"><a href="#变量的默认值" class="headerlink" title="变量的默认值"></a>变量的默认值</h2><p>可以通过 -: 操作符合来使用默认值，比如${LOG_DIR -: /path/logdir}</p>
<p>如果LOG_DIR在域中取不到，则用默认值/path/logdir</p>
<h2 id="变量的嵌套"><a href="#变量的嵌套" class="headerlink" title="变量的嵌套"></a>变量的嵌套</h2><p>名称和值都是支持嵌套的，默认值中也可以使用。</p>
<p>假设 userid=uncle</p>
<p>比如${${userid}.password},可能值就是变为取${uncle.password}这个变量的值。</p>
<p>${id:-${userid}}，id不存在则返回uncle</p>
<h2 id="设置时间戳"><a href="#设置时间戳" class="headerlink" title="设置时间戳"></a>设置时间戳</h2><p>可以定义一个根据当前时间的动态变化的变量。</p>
<ul>
<li>key：引用名字</li>
<li>datePattern：时间格式化，和Java的SimpleDateFormat一样。</li>
<li>timeReference 设置值“contextBirth”为logback启动时间，不写默认为当前时间</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Insert the current time formatted as &quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot; under</span>
<span class="hljs-comment">       the key &quot;bySecond&quot; into the logger context. This value will be</span>
<span class="hljs-comment">       available to all subsequent configuration elements. --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">timestamp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;now&quot;</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">&quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot;</span>/&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">timestamp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;startTime&quot;</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">&quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot;</span> </span>
<span class="hljs-tag">             <span class="hljs-attr">timeReference</span>=<span class="hljs-string">&quot;contextBirth&quot;</span>/&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- use the previously created timestamp to create a uniquely</span>
<span class="hljs-comment">         named log file --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>log-$&#123;bySecond&#125;.txt<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%logger&#123;35&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="定义动态的变量"><a href="#定义动态的变量" class="headerlink" title="定义动态的变量"></a>定义动态的变量</h2><p>通过define标签定义变量，name为变量的值，class为PropertyDefiner接口的实现类，其中的属性是将会通过setter注入这个类，最后这个类的getPropertyValue（）方法将为name对应的值。</p>
<p>目前已经有的实现类：</p>
<ul>
<li>FileExistsPropertyDefiner 变量为主机名</li>
<li>ResourceExistsPropertyDefiner 校验文件是否存在</li>
<li>CanonicalHostNamePropertyDefiner    校验资源是否存在</li>
</ul>
<p>可间一般用于动态获取一些值。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">define</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rootLevel&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a.class.implementing.PropertyDefiner&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">shape</span>&gt;</span>round<span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">color</span>&gt;</span>brown<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">size</span>&gt;</span>24<span class="hljs-tag">&lt;/<span class="hljs-name">size</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">define</span>&gt;</span>
 
  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;$&#123;rootLevel&#125;&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>需要依赖Janino库，支持嵌套</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.janino<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>janino<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<p>例子：</p>
<p>其中property可以简写为p，语法和java中字符串语法一样</p>
<configuration debug="true">

  <if condition='property("HOSTNAME").contains("torino")'>
    <then>
      <appender name="CON" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
          <pattern>%d %-5level %logger{35} - %msg %n</pattern>
        </encoder>
      </appender>
      <root>
        <appender-ref ref="CON" />
      </root>
    </then>
  </if>

  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>${randomOutputDir}/conditional.log</file>
    <encoder>
      <pattern>%d %-5level %logger{35} - %msg %n</pattern>
   </encoder>
  </appender>

  <root level="ERROR">
     <appender-ref ref="FILE" />
  </root>
</configuration>


<h2 id="从JNDI中获取变量"><a href="#从JNDI中获取变量" class="headerlink" title="从JNDI中获取变量"></a>从JNDI中获取变量</h2><p>从JNDI中检索一个AppName的值，赋值给contextName。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">insertFromJNDI</span> <span class="hljs-attr">env-entry-name</span>=<span class="hljs-string">&quot;java:comp/env/appName&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;appName&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>$&#123;appName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d $&#123;CONTEXT_NAME&#125; %level %msg %logger&#123;50&#125;%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="配置引入"><a href="#配置引入" class="headerlink" title="配置引入"></a>配置引入</h2><p>可以通过include标签引入一个配置从其他xml中</p>
<p>include：可以多种方式</p>
<ul>
<li>resource：类路径</li>
<li>url：web</li>
<li>file: 文件路径</li>
</ul>
<p>include如果引入文件不存在，则会报告这个错误信息，如果想不报，可以使用属性 optional=”true”</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;src/main/java/chapters/configuration/includedConfig.xml&quot;</span>/&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;includedConsole&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<p>includedConfig.xml：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">included</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;includedConsole&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>&quot;%d - %m%n&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">included</span>&gt;</span></code></pre>

<h2 id="日志级别改变传播器"><a href="#日志级别改变传播器" class="headerlink" title="日志级别改变传播器"></a>日志级别改变传播器</h2><p>0.9.25版本开始， logback-classic附带了LevelChangePropagator，是LoggerContextListener的实现类，用于监控日志等级改变，然后传输到java.util.logging框架中，这种传播消除了禁用日志语句对性能的影响</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">contextListener</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.jul.LevelChangePropagator&quot;</span>/&gt;</span>
  .... 
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<p>设置resetJUL属性来实现日志等级改变时重置jcl。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">contextListener</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.jul.LevelChangePropagator&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resetJUL</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">resetJUL</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">contextListener</span>&gt;</span>
  ....
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://logback.qos.ch/manual/configuration.html">Chapter 3: Logback configuration</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>logback的配置</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/5.logback%E7%9A%84%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h2 id="配置文件的加载"><a href="#配置文件的加载" class="headerlink" title="配置文件的加载"></a>配置文件的加载</h2><p>顺序依次：</p>
<ol>
<li>classpath下的logback-test.xml</li>
<li>classpath下的logback.groovy</li>
<li>classpath下的logback.xml</li>
<li>通过SPI机制加载META-INF/services/com.qos.logback.classic.spi.Configurator文件，里面写配置类的全限定类名</li>
<li>以上都没有则使用自带的BasicConfigurator配置一个控制台输出日志的配置</li>
</ol>
<p>设置其他方式加载配置文件</p>
<ol>
<li>通过vm参数指定配置文件 -Dlogback.configurationFile=/path/to/config.xml</li>
<li>通过代码内设置<pre><code class="hljs java">System.setProperty(ContextInitializer.CONFIG_FILE_PROPERTY, <span class="hljs-string">&quot;/path/to/config.xml&quot;</span>);</code></pre>

</li>
</ol>
<h2 id="打印配置初始化信息"><a href="#打印配置初始化信息" class="headerlink" title="打印配置初始化信息"></a>打印配置初始化信息</h2><ol>
<li>手动打印</li>
</ol>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
  Logger logger = LoggerFactory.getLogger(<span class="hljs-string">&quot;ROOT&quot;</span>);
  logger.info(<span class="hljs-string">&quot;internal info&quot;</span>);
  <span class="hljs-comment">// assume SLF4J is bound to logback in the current environment</span>
  LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
  <span class="hljs-comment">// print logback&#x27;s internal status</span>
  StatusPrinter.print(lc);
  ...
&#125;</code></pre>

<ol start="2">
<li>自动打印</li>
</ol>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
      ...
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<ol start="3">
<li>StatusListener方式</li>
</ol>
<p>自带的有OnConsoleStatusListener，也可以自己实现</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">statusListener</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.status.OnConsoleStatusListener&quot;</span> /&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="自动扫描更改并且更新配置文件"><a href="#自动扫描更改并且更新配置文件" class="headerlink" title="自动扫描更改并且更新配置文件"></a>自动扫描更改并且更新配置文件</h2><p>设置scan为true，则会启动ReconfigureOnChangeTask按照指定周期更新配置。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;30 seconds&quot;</span> &gt;</span> 
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhanghongguo@sensorsdata.cn</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/12/02 19:54</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScanConfigModifySample</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    Logger logger = LoggerFactory.getLogger(ScanConfigModifySample.class);
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
      logger.info(<span class="hljs-string">&quot;scan period by 1 seconds&quot;</span>);
      Thread.sleep(<span class="hljs-number">2000</span>);
    &#125;
  &#125;
&#125;</code></pre>

<p>然后修改编译后的target/的配置文件，自动更新。</p>
<h2 id="启用在堆栈跟踪中显示Jar包信息"><a href="#启用在堆栈跟踪中显示Jar包信息" class="headerlink" title="启用在堆栈跟踪中显示Jar包信息"></a>启用在堆栈跟踪中显示Jar包信息</h2><p>也就是在打印除了打印堆栈信息外还会显示这一栈信息中属于哪个jar包合jar包的版本信息。这个计算代价很高，特别是在异常频繁发生的情况下。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201202234159.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201202234159.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<ol>
<li>配置中启用</li>
</ol>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">packagingData</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<ol start="2">
<li>代码中启用</li>
</ol>
<pre><code class="hljs java">LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
lc.setPackagingDataEnabled(<span class="hljs-keyword">true</span>);</code></pre>

<h2 id="停止日志记录"><a href="#停止日志记录" class="headerlink" title="停止日志记录"></a>停止日志记录</h2><p>代码控制直接停止日志记录器。</p>
<pre><code class="hljs java">LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();
Logger logger = context.getLogger(<span class="hljs-string">&quot;ROOT&quot;</span>);
logger.info(<span class="hljs-string">&quot;stop start&quot;</span>);
context.stop();
<span class="hljs-comment">//不显示</span>
logger.info(<span class="hljs-string">&quot;is stop?&quot;</span>);</code></pre>

<p>注册日志停止记录的shutdownHook，在独立的Java应用程序中，向配置文件中添加<shutdownHook />指令是确保JVM退出之前允许任何正在进行的压缩任务完成的简便方法，在web应用中，这个会自动注册，shutdownHook /&gt;指令是多余的。</p>
<p>可以通过class来指定自己的showdownHook</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">shutdownHook</span>/&gt;</span>
  .... 
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://logback.qos.ch/manual/configuration.html">Chapter 3: Logback configuration</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>logback的架构</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/4.logback%E7%9A%84%E6%9E%B6%E6%9E%84.html</url>
    <content><![CDATA[<h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>当前logback被分为了三个模块</p>
<ul>
<li>logback-core，为其他两个模块提供基础功能</li>
<li>logback-classic，是一个相对于log4j的显著改进版本，实现了slf4j的api，所以可以轻松的切换其他日志框架，比如jul</li>
<li>logback-access.提供了servlet容器的http访问日志记录的功能</li>
</ul>
<h2 id="Logger-Appenders和Layouts"><a href="#Logger-Appenders和Layouts" class="headerlink" title="Logger,Appenders和Layouts"></a>Logger,Appenders和Layouts</h2><p>这个logback建立在这三个主要的类上面，这三个组件提供了，允许开发着在选择何种等级的日志(Appenders) 、控制日志的格式（Layouts）、和在哪里打日志（logger）</p>
<p>Logger是在logback-classic中的、Appenders和Layouts是在logback-core中的。</p>
<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><h4 id="名称继承"><a href="#名称继承" class="headerlink" title="名称继承"></a>名称继承</h4><p>通常情况下，我们给Logger命名都是通过类的全限定类名。</p>
<p>LoggerContext负责创建Logger，并且按照树一样的格式来进行管理，所以Logger也是分等级的，root logger就是顶端，分级规则也很简单，就是通过一个英文点来进行分，比如 com.unclezs.log，名字为com.unclezs的Logger就比名字为com.unclezs.log的Logger等级高。</p>
<p>获取root logger:</p>
<pre><code class="hljs java">Logger rootLogger = LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);</code></pre>

<h4 id="日志级别与继承的关系"><a href="#日志级别与继承的关系" class="headerlink" title="日志级别与继承的关系"></a>日志级别与继承的关系</h4><p>slf4j提供的日志级别TRACE, DEBUG, INFO, WARN 和 ERROR</p>
<p>TRACE &lt; DEBUG &lt; INFO &lt;  WARN &lt; ERROR.</p>
<p>获取日志的有效等级，当一个log.xx方法执行时，如果当前命名空间没有对应Level，就会根去查找祖先节点的日志级别，直到找到为止</p>
<p><strong>判断日志是否会被打印：</strong></p>
<p>摘自官方文档：</p>
<blockquote>
<p>A log request of level p issued to a logger having an effective level q, is enabled if p &gt;= q.</p>
</blockquote>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201202172227.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201202172227.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>比如com.unclezs.a 配置的logger日志级别为info<br>com.unclezs.a.b 配置的logger日志级别为error<br>在com.unclezs.a.b调用log.warn</p>
<p>得到有效日志等级为error,请求日志等级为warn，warn &lt; error<br>则不打印</p>
<h4 id="检索Logger"><a href="#检索Logger" class="headerlink" title="检索Logger"></a>检索Logger</h4><p>通常情况下我们都是通过Clazz.class来获取Logger，但是也可以传入他的全限定类名。</p>
<p>当然这个名字都是自己定义的，你可以命名为abc，bcd之类的，但是没有什么意义，安装全限定类名进行命名可以很好的利用日志级别按照名称继承等级的好处。</p>
<h3 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h3><p>Appender允许我们将日志打到各种地方，可以是控制台，可以是文件，也可以是数据库、JML等等</p>
<p>一个logger可以拥有多个Appender，并且都会执行，所以你可以通过一个logger就能把日志打到控制台和文件。</p>
<p>Appender也是有累加性质的，也就是会查看父及logger有没有Appender ，如果有，则一起执行。可以在logger上配置additivity=false来关闭这个特性。</p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>Appender的子节点，定义日志的格式。</p>
<pre><code class="hljs plain">%-4relative [%thread] %-5level %logger&#123;32&#125; - %msg%n</code></pre>

<p>输出</p>
<pre><code class="hljs plain">176  [main] DEBUG manual.architecture.HelloWorld2 - Hello world.</code></pre>

<p>第一个参数代表程序启动后所过时间。</p>
<h2 id="参数化打印日志"><a href="#参数化打印日志" class="headerlink" title="参数化打印日志"></a>参数化打印日志</h2><p>下面这种方式会引起 不论是否启用日志记录，都会有构造消息参数的消耗（类型转换）</p>
<pre><code class="hljs java">logger.debug(<span class="hljs-string">&quot;Entry number: &quot;</span> + i + <span class="hljs-string">&quot; is &quot;</span> + String.valueOf(entry[i]));</code></pre>

<p>通常情况下通过下面这种防止来防止消息参数的构造消耗，但是通过这种方法如果日志是开启的情况下，还是会出现同样的情况，甚至还多了个boolean类型的判断消耗</p>
<pre><code class="hljs java"><span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123; 
  logger.debug(<span class="hljs-string">&quot;Entry number: &quot;</span> + i + <span class="hljs-string">&quot; is &quot;</span> + String.valueOf(entry[i]));
&#125;</code></pre>

<p>更好的方案，这样的操作的好处就是，在不进行日志打印的时候，不会进行消息参数构造，也就不会有类型转换的消耗。</p>
<pre><code class="hljs java">logger.debug(<span class="hljs-string">&quot;The new entry is &#123;&#125;.&quot;</span>, entry);
logger.debug(<span class="hljs-string">&quot;Value &#123;&#125; was inserted between &#123;&#125; and &#123;&#125;.&quot;</span>, paramArray);</code></pre>

<h2 id="从一次log-info-的过程"><a href="#从一次log-info-的过程" class="headerlink" title="从一次log.info()的过程"></a>从一次log.info()的过程</h2><img src="https://gitee.com/unclezs/image-blog/raw/master///20201202184808.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201202184808.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://logback.qos.ch/manual/architecture.html">Chapter 2: Architecture</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>logback介绍</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/3.logback%E4%BB%8B%E7%BB%8D.html</url>
    <content><![CDATA[<h2 id="什么是logback"><a href="#什么是logback" class="headerlink" title="什么是logback?"></a>什么是logback?</h2><p>logback是继log4j之后的一个日志框架，比其他现存的日志框架更快占用空间更小，有时候差距很大，还提供了一些其他日志框架没有的功能，作者Ceki Gülcü,也是log4j的开发者之一。</p>
<h2 id="需要的库"><a href="#需要的库" class="headerlink" title="需要的库"></a>需要的库</h2><ul>
<li>slf4j-api.jar</li>
<li>logback-core.jar</li>
<li>logback-classic.jar</li>
</ul>
<h2 id="获取内部日志信息"><a href="#获取内部日志信息" class="headerlink" title="获取内部日志信息"></a>获取内部日志信息</h2><p>我们可以通过StatusManager来访问发生在logback生命周期中的一些事件，可以通过StatusPrinter.print方法打印到控制台</p>
<pre><code class="hljs java"><span class="hljs-comment">// print internal state</span>
LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
StatusPrinter.print(lc);</code></pre>

<p>可以看到logback查找配置文件和装载配置的过程。如果没有配置会打印配置文件缺失的信息</p>
<pre><code class="hljs log">12:49:22.203 [main] DEBUG chapters.introduction.HelloWorld2 - Hello world.
12:49:22,076 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy]
12:49:22,078 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml]
12:49:22,093 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.xml]
12:49:22,093 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Setting up default configuration.</code></pre>

<h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><ol>
<li>引入依赖</li>
<li>配置logback.xml</li>
<li>在想要打日志的类中通过org.slf4j.LoggerFactory.getLogger()获取日志记录器</li>
<li>调用logger的debug(), info(), warn() ，error() 方法记录日志</li>
</ol>
<h2 id="依赖使用"><a href="#依赖使用" class="headerlink" title="依赖使用"></a>依赖使用</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://logback.qos.ch/manual/introduction.html">Chapter 1: Introduction to logback</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>两种常用日志框架搭配快速上手</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/2.%E4%B8%A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E6%90%AD%E9%85%8D%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html</url>
    <content><![CDATA[<h2 id="SLF4J-LogBack用法"><a href="#SLF4J-LogBack用法" class="headerlink" title="SLF4J+LogBack用法"></a>SLF4J+LogBack用法</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/1 10:46 下午</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogbackSample</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(LogbackSample.class);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        logger.info(<span class="hljs-string">&quot;log by Logback&quot;</span>);
        logger.warn(<span class="hljs-string">&quot;log by Logback&quot;</span>);
        logger.error(<span class="hljs-string">&quot;log by Logback&quot;</span>);
        logger.debug(<span class="hljs-string">&quot;log by Logback&quot;</span>);
        logger.trace(<span class="hljs-string">&quot;log by Logback&quot;</span>);
    &#125;
&#125;
</code></pre>

<h3 id="如何配置logback-xml"><a href="#如何配置logback-xml" class="headerlink" title="如何配置logback.xml"></a>如何配置logback.xml</h3><p><a href="http://logback.qos.ch/manual/configuration.html">Logback 配置官方文档</a></p>
<h2 id="Common-Logging-Log4J的用法"><a href="#Common-Logging-Log4J的用法" class="headerlink" title="Common-Logging+Log4J的用法"></a>Common-Logging+Log4J的用法</h2><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/1 10:50 下午</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log4jSample</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Logger logger = LogManager.getLogger(Log4jSample.class);
        logger.info(<span class="hljs-string">&quot;log by log4j2&quot;</span>);
        logger.warn(<span class="hljs-string">&quot;log by log4j2&quot;</span>);
        logger.error(<span class="hljs-string">&quot;log by log4j2&quot;</span>);
        logger.debug(<span class="hljs-string">&quot;log by log4j2&quot;</span>);
        logger.trace(<span class="hljs-string">&quot;log by log4j2&quot;</span>);
    &#125;
&#125;
</code></pre>

<h3 id="配置log4j2-xml"><a href="#配置log4j2-xml" class="headerlink" title="配置log4j2.xml"></a>配置log4j2.xml</h3><ul>
<li><a href="http://logging.apache.org/log4j/2.x/manual/configuration.html">Apache Log4J2 官方配置文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>好看的彩色日志输出</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/13.%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%BD%A9%E8%89%B2%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA.html</url>
    <content><![CDATA[<h2 id="高亮配置"><a href="#高亮配置" class="headerlink" title="高亮配置"></a>高亮配置</h2><h3 id="IDEA无法显示彩色日志"><a href="#IDEA无法显示彩色日志" class="headerlink" title="IDEA无法显示彩色日志"></a>IDEA无法显示彩色日志</h3><ol>
<li>VM参数方式</li>
</ol>
<pre><code class="hljs plain">-Dlog4j.skipJansi&#x3D;false</code></pre>

<ol start="2">
<li>Jar包方式</li>
</ol>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.fusesource.jansi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jansi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h3 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><pre><code class="hljs plain">%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;&#123;black&#125; [%highlight&#123;%thread&#125;] %highlight&#123;%-5level&#125; %style&#123;%C&#125;&#123;bright,Magenta&#125; - %style&#123;%msg&#125;&#123;bright,Green&#125;%n</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201201234110.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201201234110.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><pre><code class="hljs plain">%style&#123;%d&#123;ISO8601&#125;&#125;&#123;bright,white&#125; %highlight&#123;%-5level&#125; %style&#123;[LOGID:%X&#123;ydbus_logid&#125;]&#125;&#123;cyan&#125; [%style&#123;%t&#125;&#123;bright,blue&#125;] [%style&#123;%C&#123;5.&#125;&#125;&#123;bright,yellow&#125;:%L] %msg%n%style&#123;%throwable&#125;&#123;red&#125;</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201201234030.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201201234030.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h3><p><a href="http://logback.qos.ch/manual/layouts.html#coloring">LogBack 彩色配置文档</a></p>
<h4 id="方案一-1"><a href="#方案一-1" class="headerlink" title="方案一"></a>方案一</h4><pre><code class="hljs plain">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %easyHighlight(%5.5level) %magenta(%pid) --- [%15.15thread] %cyan(%-40.40logger&#123;39&#125; [%4.4line]) : %msg%n</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201202021158.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201202021158.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="方案二-1"><a href="#方案二-1" class="headerlink" title="方案二"></a>方案二</h4><pre><code class="hljs plain">%red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %green([%thread]) %highlight(%-5level) %boldMagenta(%logger) - %cyan(%msg%n)</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201202021426.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201202021426.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://logback.qos.ch/manual/layouts.html#coloring">LogBack 彩色配置文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Java中的日志</title>
    <url>/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/1.%E5%88%9D%E8%AF%86Java%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97.html</url>
    <content><![CDATA[<h2 id="Java中的日志框架"><a href="#Java中的日志框架" class="headerlink" title="Java中的日志框架"></a>Java中的日志框架</h2><img src="https://gitee.com/unclezs/image-blog/raw/master///20201202140259.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201202140259.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>上图不是非常精准，但是能够比较清晰地展示现有Java日志体系的主体架构。Java日志体系大体可以分为三个部分：日志门面接口、桥接器、日志框架具体实现。</p>
<h2 id="常用日志框架类别"><a href="#常用日志框架类别" class="headerlink" title="常用日志框架类别"></a>常用日志框架类别</h2><ul>
<li><strong>Log4j</strong>： Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。Log4j是几种Java日志框架之一。</li>
<li><strong>Log4j2</strong>： Apache Log4j 2是apache开发的一款Log4j的升级产品。</li>
<li><strong>Commons Logging</strong>： Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。</li>
<li><strong>Slf4j</strong>： 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。</li>
<li><strong>Logback</strong>： 一套日志组件的实现(Slf4j阵营)。</li>
<li><strong>Jul (Java Util Logging)</strong>：自Java1.4以来的官方日志实现。</li>
</ul>
<h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><ul>
<li><p>1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即Log4j。后来Log4j成为Apache基金会项目中的一员。</p>
</li>
<li><p>期间Log4j近乎成了Java社区的日志标准。据说Apache基金会还曾经建议Sun引入Log4j到java的标准库中，但Sun拒绝了。</p>
</li>
<li><p>2002年Java1.4发布，Sun推出了自己的日志库JUL(Java Util Logging),其实现基本模仿了Log4j的实现。在JUL出来以前，Log4j就已经成为一项成熟的技术，使得Log4j在选择上占据了一定的优势。</p>
</li>
<li><p>接着，Apache推出了Jakarta Commons Logging，JCL只是定义了一套日志接口(其内部也提供一个Simple Log的简单实现)，支持运行时动态加载日志组件的实现，也就是说，在你应用代码里，只需调用Commons Logging的接口，底层实现可以是Log4j，也可以是Java Util Logging。</p>
</li>
<li><p>后来(2006年)，Ceki Gülcü不适应Apache的工作方式，离开了Apache。然后先后创建了Slf4j(日志门面接口，类似于Commons Logging)和Logback(Slf4j的实现)两个项目，并回瑞典创建了QOS公司，QOS官网上是这样描述Logback的：The Generic，Reliable Fast&amp;Flexible Logging Framework(一个通用，可靠，快速且灵活的日志框架)。</p>
</li>
<li><p>现今，Java日志领域被划分为两大阵营：Commons Logging阵营和Slf4j阵营。Commons Logging在Apache大树的笼罩下，有很大的用户基数。但有证据表明，形式正在发生变化。2013年底有人分析了GitHub上30000个项目，统计出了最流行的100个Libraries，可以看出Slf4j的发展趋势更好：<img src="https://gitee.com/unclezs/image-blog/raw/master/20201202010438.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201202010438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
</li>
<li><p>Apache眼看有被Logback反超的势头，于2012-07重写了Log4j 1.x，成立了新的项目Log4j 2, Log4j 2具有Logback的所有特性。</p>
</li>
</ul>
<h2 id="常用日志框架关系"><a href="#常用日志框架关系" class="headerlink" title="常用日志框架关系"></a>常用日志框架关系</h2><ul>
<li>Log4j 2与Log4j 1发生了很大的变化，Log4j 2不兼容Log4j 1。</li>
<li>Commons Logging和Slf4j是日志门面(门面模式是软件工程中常用的一种软件设计模式，也被称为正面模式、外观模式。它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用)。Log4j和Logback则是具体的日志实现方案。可以简单的理解为接口与接口的实现，调用者只需要关注接口而无需关注具体的实现，做到解耦。</li>
<li>比较常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。</li>
<li>Logback必须配合Slf4j使用。由于Logback和Slf4j是同一个作者，其兼容性不言而喻。</li>
</ul>
<h2 id="Commons-Logging与Slf4j实现机制对比"><a href="#Commons-Logging与Slf4j实现机制对比" class="headerlink" title="Commons Logging与Slf4j实现机制对比"></a>Commons Logging与Slf4j实现机制对比</h2><h3 id="Commons-Logging实现机制"><a href="#Commons-Logging实现机制" class="headerlink" title="Commons Logging实现机制"></a>Commons Logging实现机制</h3><p>Commons Logging是通过动态查找机制，在程序运行时，使用自己的ClassLoader寻找和载入本地具体的实现。详细策略可以查看commons-logging-*.jar包中的org.apache.commons.logging.impl.LogFactoryImpl.java文件。由于Osgi不同的插件使用独立的ClassLoader，Osgi的这种机制保证了插件互相独立, 其机制限制了Commons Logging在Osgi中的正常使用。</p>
<h3 id="Slf4j实现机制"><a href="#Slf4j实现机制" class="headerlink" title="Slf4j实现机制"></a>Slf4j实现机制</h3><p>Slf4j在编译期间，静态绑定本地的Log库，因此可以在Osgi中正常使用。它是通过查找类路径下org.slf4j.impl.StaticLoggerBinder，然后在StaticLoggerBinder中进行绑定。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://logback.qos.ch/manual/index.html">LogBack 官方手册</a></li>
<li><a href="http://logback.qos.ch/manual/configuration.html">LogBack 官方配置文档</a></li>
<li><a href="http://logging.apache.org/log4j/2.x/manual/configuration.html">Apache Log4J2 官方配置文档</a></li>
<li><a href="https://www.cnblogs.com/chenhongliang/p/5312517.html">Java常用日志框架介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>用Jcommander打造自己的Java的命令行工具</title>
    <url>/Java/%E5%B7%A5%E5%85%B7/%E7%94%A8Jcommander%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84Java%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候我们用Java开发了一个小工具，希望通过命令行(CLI)或者图形界面直接调用。命令行相较于图形界面，实现迅速，交互更接近于程序员人群，而Jcommander就是Java的这样一款工具。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.beust<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcommander<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.78<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.jcommander;

<span class="hljs-keyword">import</span> com.beust.jcommander.JCommander;
<span class="hljs-keyword">import</span> com.beust.jcommander.Parameter;
<span class="hljs-keyword">import</span> com.beust.jcommander.UnixStyleUsageFormatter;

<span class="hljs-keyword">import</span> java.nio.file.Files;
<span class="hljs-keyword">import</span> java.nio.file.Paths;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 用法示例</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/1 12:15 上午</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-meta">@Parameter(names = &#123;&quot;--path&quot;, &quot;-p&quot;&#125;, description = &quot;文件路径&quot;, order = 1)</span>
    <span class="hljs-keyword">private</span> String path;
    <span class="hljs-meta">@Parameter(names = &#123;&quot;--version&quot;, &quot;-v&quot;&#125;, description = &quot;版本&quot;, order = 2, arity = 0)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> version;
    <span class="hljs-meta">@Parameter(names = &#123;&quot;-h&quot;&#125;, description = &quot;帮助&quot;, order = 3, arity = 0)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> usage;
    <span class="hljs-meta">@Parameter(names = &quot;--help&quot;, help = true)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> help;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Main pathUtil = <span class="hljs-keyword">new</span> Main();
        JCommander jCommander = JCommander.newBuilder()
                .programName(<span class="hljs-string">&quot;pathUtil&quot;</span>)
                .addObject(pathUtil)
                .build();
        jCommander.setUsageFormatter(<span class="hljs-keyword">new</span> UnixStyleUsageFormatter(jCommander));
        jCommander.parse(args);
        <span class="hljs-keyword">if</span> (pathUtil.version) &#123;
            System.out.println(<span class="hljs-string">&quot;pathUtil version 6.6.6&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (pathUtil.path != <span class="hljs-keyword">null</span>) &#123;
            System.out.println(<span class="hljs-string">&quot;path exist? &quot;</span> + Files.exists(Paths.get(pathUtil.path)));
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (pathUtil.usage) &#123;
            jCommander.usage();
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (pathUtil.help) &#123;
            System.out.println(<span class="hljs-string">&quot;help invoke&quot;</span>);
        &#125;
    &#125;
&#125;
</code></pre>

<p>运行后的效果图</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201201004216.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201201004216.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h2><ul>
<li><a href="https://github.com/unclezs/samples/tree/main/samples-jcommander">我自己写的一些示例</a></li>
<li><a href="http://jcommander.org/">官方文档</a></li>
<li><a href="https://commons.apache.org/proper/commons-cli/">另外一款命令行解析工具Apache Commons CLI</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jcommander</tag>
      </tags>
  </entry>
  <entry>
    <title>把自己的包到Maven中央仓库</title>
    <url>/Java/Maven/%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85%E5%88%B0Maven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93.html</url>
    <content><![CDATA[<h2 id="Sonatype"><a href="#Sonatype" class="headerlink" title="Sonatype"></a>Sonatype</h2><ol>
<li>注册<a href="https://issues.sonatype.org/secure/Signup!default.jspa">Sonatype</a> 账户。</li>
<li>登录<a href="https://issues.sonatype.org/secure/Signup!default.jspa">Sonaytype Jira</a></li>
<li>创建如下的 issue，申请发版权限，等待管理员审核。<img src="https://gitee.com/unclezs/image-blog/raw/master/20201129212106.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201129212106.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>等待回复，如果你填了自定义域名则会这么回复你。也就是有自定义域名就解析自定义域名TXT到这个issue，如果没有则用github的<img src="https://gitee.com/unclezs/image-blog/raw/master/20201129212220.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201129212220.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>我是自定义域名所以提交了<img src="https://gitee.com/unclezs/image-blog/raw/master/20201129212346.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201129212346.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>然后回复issue,说你已经成功解析了，然后等他处理就行了</li>
</ol>
<h2 id="准备-GPG"><a href="#准备-GPG" class="headerlink" title="准备 GPG"></a>准备 GPG</h2><p>这个用于加密的，在发release的时候会校验，发快照版本不会校验。</p>
<h3 id="查看是否安装"><a href="#查看是否安装" class="headerlink" title="查看是否安装"></a>查看是否安装</h3><pre><code class="hljs plain">gpg --version</code></pre>

<p>能够显示 GPG 的版本信息，说明已经安装，否则需要去官网下载安装。下载地址如下：</p>
<ul>
<li>window: <a href="http://www.gpg4win.org/download.html">http://www.gpg4win.org/download.html</a></li>
<li>OSX: <a href="https://gnupg.org/download/index.html">https://gnupg.org/download/index.html</a></li>
</ul>
<p>能够显示 GPG 的版本信息，说明已经安装，否则需要去官网下载安装。下载地址如下：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201129212855.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201129212855.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="生成秘钥对"><a href="#生成秘钥对" class="headerlink" title="生成秘钥对"></a>生成秘钥对</h3><p>此时需要输入姓名、邮箱等字段，其它字段可使用默认值，此外，还需要输入一个 Passphase，相当于一个密钥库的密码，一定不要忘了，也不要告诉别人，一定要记下来，后面会用到。</p>
<pre><code class="hljs plain">gpg --gen-key</code></pre>

<h3 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h3><pre><code class="hljs plain">gpg --list-keys</code></pre>

<img src="https://gitee.com/unclezs/image-blog/raw/master/20201129213126.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201129213126.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>可见这里的公钥的 ID是：5A68166AF292264925C6A5053C6675A0EE56F4AA，稍后就会用到。</p>
<h3 id="将公钥发布到-PGP-密钥服务器"><a href="#将公钥发布到-PGP-密钥服务器" class="headerlink" title="将公钥发布到 PGP 密钥服务器"></a>将公钥发布到 PGP 密钥服务器</h3><pre><code class="hljs plain">gpg --keyserver hkp:&#x2F;&#x2F;pool.sks-keyservers.net --send-keys 5A68166AF292264925C6A5053C6675A0EE56F4AA</code></pre>
<p>此后可使用本地的私钥来对上传构件进行数字签名，而下载该构件的用户可通过上传的公钥来验证签名，也就是说，大家可以验证这个构件是否由本人上传的，因为有可能该构件被坏人给篡改了。</p>
<p>如果提示发布失败，可以多尝试几次，如果实在不行，可更换地址源，如 hkp://keyserver.ubuntu.com:11371。</p>
<h3 id="查询公钥是否发布成功"><a href="#查询公钥是否发布成功" class="headerlink" title="查询公钥是否发布成功"></a>查询公钥是否发布成功</h3><pre><code class="hljs plain">gpg --keyserver hkp:&#x2F;&#x2F;pool.sks-keyservers.net --recv-keys 5A68166AF292264925C6A5053C6675A0EE56F4AA</code></pre>
<p>实际上就是从 key server 上通过公钥 ID 来接收公钥，此外也可以到 sks-keyservers.net 上通过公钥 ID 去查询。</p>
<h2 id="修改-Maven-配置文件"><a href="#修改-Maven-配置文件" class="headerlink" title="修改 Maven 配置文件"></a>修改 Maven 配置文件</h2><p>使用自己注册的 Sonatype 账号的用户名与密码来配置server信息到setting.xml</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
...
    <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>oss<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre>

<p>修改项目的Maven配置pom.xml，注意下面的都是必备的</p>
<pre><code class="hljs xml">
<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceencoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceencoding</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Unclezs&#x27;s tools repo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Unclezs&#x27;s repo<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://github.com/unclezs/xtools<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">licenses</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>The Apache Software License, Version 2.0<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.apache.org/licenses/LICENSE-2.0.txt<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">licenses</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">developer</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>unclezs<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>1585503310@qq.com<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">developer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://github.com/unclezs/xtools.git<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">connection</span>&gt;</span>scm:git:https://github.com/xtools.git<span class="hljs-tag">&lt;/<span class="hljs-name">connection</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 对应setting.xml里面的ID --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>oss<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>oss<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://oss.sonatype.org/service/local/staging/deploy/maven2/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- doc plugin,Maven API文档生成插件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>attach-javadocs<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">additionalJOptions</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">additionalJOption</span>&gt;</span>-Xdoclint:none<span class="hljs-tag">&lt;/<span class="hljs-name">additionalJOption</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">additionalJOptions</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- resources plugin,Maven 资源插件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-source-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>attach-sources<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>jar-no-fork<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- compiler plugin,Maven 编译插件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">showWarnings</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">showWarnings</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- gpg 加密校验 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-gpg-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>sign<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><pre><code class="hljs plain">mvn clean deploy</code></pre>

<p>如果成功了直接上 <a href="https://oss.sonatype.org/">https://oss.sonatype.org/</a> 去查看</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201129214125.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201129214125.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>打release包会先进行暂存，需要到这上面进行操作发布，首先选中发布的版本（上传后看的到），点击close，如果校验通过，则点击release发布，然后在issue处回复并关闭。</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="gpg-签名时失败处理"><a href="#gpg-签名时失败处理" class="headerlink" title="gpg: 签名时失败处理"></a>gpg: 签名时失败处理</h3><pre><code class="hljs plain">gpg: signing failed: Inappropriate ioctl for device</code></pre>

<p>添加环境变量</p>
<pre><code class="hljs plain">export GPG_TTY&#x3D;$(tty)</code></pre>

<h3 id="执行-Close-出现-Failed-Signature-Validation"><a href="#执行-Close-出现-Failed-Signature-Validation" class="headerlink" title="执行 Close 出现 Failed: Signature Validation"></a>执行 Close 出现 Failed: Signature Validation</h3><img src="https://gitee.com/unclezs/image-blog/raw/master/20201129214539.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201129214539.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>到 <a href="https://gpgtools.org/">https://gpgtools.org/</a> 上下载了macOS 版本的 GPG Suite Tools客户端工具，安装好之后，打开 GPG Keychain，这是你可能会直接看到刚才生成的GPG秘钥被列出来，你只需要选中，然后右键选中 Send Public to Key Server，接着等待3-5秒，弹出提示 successfully，这一次是真的上传成功了；再次重复 deploy=》Close-》release</p>
<h2 id="到仓库查看"><a href="#到仓库查看" class="headerlink" title="到仓库查看"></a>到仓库查看</h2><p><a href="https://search.maven.org/">https://search.maven.org/</a> 去搜索自己的包看看是不是存在。同步会有一定延迟。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201129215256.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201129215256.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>]]></content>
      <categories>
        <category>Java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-外观模式</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p>外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>外观（Facade）模式的主要缺点如下。</p>
<ol>
<li>不能很好地限制客户使用子系统类，很容易带来未知风险。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
<h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p>
<h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>外观（Facade）模式包含以下主要角色。</p>
<ol>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
<li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201127165806.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201127165806.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.facade;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FacadePattern</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        Facade f=<span class="hljs-keyword">new</span> Facade();
        f.method();
    &#125;
&#125;
<span class="hljs-comment">//外观角色</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">private</span> SubSystem01 obj1=<span class="hljs-keyword">new</span> SubSystem01();
    <span class="hljs-keyword">private</span> SubSystem02 obj2=<span class="hljs-keyword">new</span> SubSystem02();
    <span class="hljs-keyword">private</span> SubSystem03 obj3=<span class="hljs-keyword">new</span> SubSystem03();
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        obj1.method1();
        obj2.method2();
        obj3.method3();
    &#125;
&#125;
<span class="hljs-comment">//子系统角色</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem01</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;子系统01的method1()被调用！&quot;</span>);
    &#125;   
&#125;
<span class="hljs-comment">//子系统角色</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem02</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;子系统02的method2()被调用！&quot;</span>);
    &#125;   
&#125;
<span class="hljs-comment">//子系统角色</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem03</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;子系统03的method3()被调用！&quot;</span>);
    &#125;   
&#125;</code></pre>

<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul>
<li>在Shiro中的SecurityManager就是典型的Facade设计模式</li>
<li>SLF4J也是使用的Facade模式</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Facade</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java应用诊断利器Arthas</title>
    <url>/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/Java%E5%BA%94%E7%94%A8%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8Arthas.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简介Arthas是一个款Java的诊断工具，比如当前JVM中有哪些线程、动态监控方法的调用链、每个方法的调用时间等等，很强大。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201126192331.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201126192331.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="使用arthas-boot"><a href="#使用arthas-boot" class="headerlink" title="使用arthas-boot"></a>使用arthas-boot</h3><p>下载arthas-boot.jar，然后用java -jar的方式启动：</p>
<pre><code class="hljs plain">curl -O https:&#x2F;&#x2F;arthas.aliyun.com&#x2F;arthas-boot.jar
java -jar arthas-boot.jar</code></pre>

<p>打印帮助信息：</p>
<pre><code class="hljs plain">java -jar arthas-boot.jar -h</code></pre>

<p>如果下载速度比较慢，可以使用aliyun的镜像：</p>
<pre><code class="hljs plain">java -jar arthas-boot.jar --repo-mirror aliyun --use-http</code></pre>

<h3 id="使用as-sh"><a href="#使用as-sh" class="headerlink" title="使用as.sh"></a>使用as.sh</h3><p>Arthas 支持在 Linux/Unix/Mac 等平台上一键安装，请复制以下内容，并粘贴到命令行中，敲 回车 执行即可：</p>
<pre><code class="hljs plain">curl -L https:&#x2F;&#x2F;arthas.aliyun.com&#x2F;install.sh | sh</code></pre>


<h2 id="查看线程及MainClass"><a href="#查看线程及MainClass" class="headerlink" title="查看线程及MainClass"></a>查看线程及MainClass</h2><p>thread 1会打印线程ID 1的栈，通常是main函数的线程。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201126192602.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201126192602.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="反编译类"><a href="#反编译类" class="headerlink" title="反编译类"></a>反编译类</h2><pre><code class="hljs plain">jad fxlauncher.Launcher</code></pre>

<p>可以查看类的加载器、类的位置、及反编译后的源码</p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>用户查看方法返回值，及入参</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201126201700.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201126201700.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="web命令行"><a href="#web命令行" class="headerlink" title="web命令行"></a>web命令行</h2><p>Arthas目前支持Web Console，用户在attach成功之后，可以直接访问：<a href="http://127.0.0.1:3658/。">http://127.0.0.1:3658/。</a></p>
<p>可以填入IP，远程连接其它机器上的arthas。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有更强大的:</p>
<ul>
<li>Trace 方法内部调用路径，并输出方法路径上的每个节点上耗时</li>
<li>stack 输出当前方法被调用的调用路径</li>
</ul>
<p>建议看看文档，神器值得一学</p>
<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://arthas.aliyun.com/zh-cn/">Arthas官网</a><br><a href="https://arthas.aliyun.com/doc/advanced-use.html">命令大全</a></p>
]]></content>
      <categories>
        <category>性能调优</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>GRPC初识与快速入门</title>
    <url>/%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91/RPC/GRPC%E5%88%9D%E8%AF%86%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201120180732.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201120180732.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>创建一个maven项目</p>
<p>引入依赖</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.33.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.33.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-stub<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.33.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- necessary for Java 9+ --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotations-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.53<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<p>引入protocol buffer转Java的Maven插件</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.12.0:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.33.1:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>

<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><img src="https://gitee.com/unclezs/image-blog/raw/master///20201120181132.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201120181132.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="proto文件编写"><a href="#proto文件编写" class="headerlink" title="proto文件编写"></a>proto文件编写</h2><pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;

option java_multiple_files &#x3D; true;
option java_package &#x3D; &quot;com.unclezs&quot;;
option java_outer_classname &#x3D; &quot;MyGrpcService&quot;;
option objc_class_prefix &#x3D; &quot;HLW&quot;;

&#x2F;&#x2F; The greeting service definition.
service MyGrpcServer &#123;
  &#x2F;&#x2F; Sends a greeting
  rpc handle (Request) returns (Response) &#123;&#125;
&#125;

&#x2F;&#x2F; The request message containing the user&#39;s name.
message Request &#123;
  string name &#x3D; 1;
&#125;

&#x2F;&#x2F; The response message containing the greetings
message Response &#123;
  string message &#x3D; 1;
&#125;</code></pre>

<h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><img src="https://gitee.com/unclezs/image-blog/raw/master///F0A1E118-EE80-4357-9639-206D8A9F19BB.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///F0A1E118-EE80-4357-9639-206D8A9F19BB.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<img src="https://gitee.com/unclezs/image-blog/raw/master///20201120181658.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201120181658.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.grpc;

<span class="hljs-keyword">import</span> com.sun.xml.internal.ws.client.sei.ResponseBuilder;
<span class="hljs-keyword">import</span> com.unclezs.MyGrpcServerGrpc;
<span class="hljs-keyword">import</span> com.unclezs.Request;
<span class="hljs-keyword">import</span> com.unclezs.Response;
<span class="hljs-keyword">import</span> io.grpc.Server;
<span class="hljs-keyword">import</span> io.grpc.ServerBuilder;
<span class="hljs-keyword">import</span> io.grpc.stub.StreamObserver;

<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldServer</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;
    <span class="hljs-keyword">private</span> Server server;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 启动服务</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        server = ServerBuilder.forPort(port)
                              .addService(<span class="hljs-keyword">new</span> MyGrpcServerGrpcImpl())
                              .build()
                              .start();

        System.out.println(<span class="hljs-string">&quot;service start...&quot;</span>);

        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                System.err.println(<span class="hljs-string">&quot;*** shutting down gRPC server since JVM is shutting down&quot;</span>);
                HelloWorldServer.<span class="hljs-keyword">this</span>.stop();
                System.err.println(<span class="hljs-string">&quot;*** server shut down&quot;</span>);
            &#125;
        &#125;);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;
            server.shutdown();
        &#125;
    &#125;

    <span class="hljs-comment">// block 一直到退出程序</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blockUntilShutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;
            server.awaitTermination();
        &#125;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;
        <span class="hljs-keyword">final</span> HelloWorldServer server = <span class="hljs-keyword">new</span> HelloWorldServer();
        server.start();
        server.blockUntilShutdown();
    &#125;


    <span class="hljs-comment">// 实现 定义一个实现服务接口的类</span>
    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGrpcServerGrpcImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyGrpcServerGrpc</span>.<span class="hljs-title">MyGrpcServerImplBase</span> </span>&#123;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(Request req, StreamObserver&lt;Response&gt; responseObserver)</span> </span>&#123;
            <span class="hljs-comment">//获取参数</span>
            System.out.println(<span class="hljs-string">&quot;收到的信息:&quot;</span>+req.getName());

            <span class="hljs-comment">//这里可以放置具体业务处理代码 start</span>

            <span class="hljs-comment">//这里可以放置具体业务处理代码 end</span>
            Response response= Response.newBuilder().setMessage(<span class="hljs-string">&quot;我收到了&quot;</span>+req.getName()).build();
            responseObserver.onNext(response);
            responseObserver.onCompleted();
        &#125;
    &#125;
&#125;
</code></pre>

<h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.grpc;

<span class="hljs-keyword">import</span> com.unclezs.MyGrpcServerGrpc;
<span class="hljs-keyword">import</span> com.unclezs.Request;
<span class="hljs-keyword">import</span> com.unclezs.Response;
<span class="hljs-keyword">import</span> io.grpc.ManagedChannel;
<span class="hljs-keyword">import</span> io.grpc.ManagedChannelBuilder;
<span class="hljs-keyword">import</span> io.grpc.StatusRuntimeException;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldClient</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ManagedChannel channel; <span class="hljs-comment">//一个gRPC信道</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyGrpcServerGrpc.MyGrpcServerBlockingStub blockingStub;<span class="hljs-comment">//阻塞/同步 存根</span>

   <span class="hljs-comment">//初始化信道和存根</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HelloWorldClient</span><span class="hljs-params">(String host,<span class="hljs-keyword">int</span> port)</span></span>&#123;
        <span class="hljs-keyword">this</span>(ManagedChannelBuilder.forAddress(host, port)
                                  <span class="hljs-comment">// Channels are secure by default (via SSL/TLS). For the example we disable TLS to avoid</span>
                                  <span class="hljs-comment">// needing certificates.</span>
                                  .usePlaintext());
    &#125;

    <span class="hljs-comment">/** Construct client for accessing RouteGuide server using the existing channel. */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HelloWorldClient</span><span class="hljs-params">(ManagedChannelBuilder&lt;?&gt; channelBuilder)</span> </span>&#123;
        channel = channelBuilder.build();
        blockingStub = MyGrpcServerGrpc.newBlockingStub(channel);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        channel.shutdown().awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);
    &#125;

    <span class="hljs-comment">//客户端方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">greet</span><span class="hljs-params">(String name)</span></span>&#123;
        Request request = Request.newBuilder().setName(name).build();
        Response response;
        <span class="hljs-keyword">try</span> &#123;
            response = blockingStub.handle(request);
        &#125; <span class="hljs-keyword">catch</span> (StatusRuntimeException e) &#123;
            System.out.println(<span class="hljs-string">&quot;RPC调用失败:&quot;</span>+e.getMessage());
            <span class="hljs-keyword">return</span>;
        &#125;
        System.out.println(<span class="hljs-string">&quot;服务器返回信息:&quot;</span>+response.getMessage());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        HelloWorldClient client = <span class="hljs-keyword">new</span> HelloWorldClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">50051</span>);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;
                client.greet(<span class="hljs-string">&quot;world:&quot;</span>+i);
            &#125;
        &#125;<span class="hljs-keyword">finally</span> &#123;
            client.shutdown();
        &#125;
    &#125;
&#125;
</code></pre>

<h2 id="启动后测试"><a href="#启动后测试" class="headerlink" title="启动后测试"></a>启动后测试</h2><img src="https://gitee.com/unclezs/image-blog/raw/master///20201120181843.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201120181843.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://doc.oschina.net/grpc?t=58009">gRPC 官方文档中文版</a></p>
]]></content>
      <categories>
        <category>后端研发</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>ProtocolBuffer基本语法</title>
    <url>/%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91/RPC/ProtocolBuffer%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>习惯用 Json、XML 数据存储格式的你们，相信大多都没听过Protocol Buffer</li>
<li>Protocol Buffer 其实 是 Google出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！</li>
</ul>
<p>应用场景：传输数据量大 &amp; 网络环境不稳定 的数据存储、RPC 数据交换 的需求场景</p>
<p>他可以生成多种语言，Java、C++、Go、Python、C#、Dart。</p>
<h2 id="定义一个message"><a href="#定义一个message" class="headerlink" title="定义一个message"></a>定义一个message</h2><p>这个message相当于是一个实体类型，可以假象为一个JavaBean一样的东西，但是不止于此。</p>
<pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;

message SearchRequest &#123;
  string query &#x3D; 1;
  int32 page_number &#x3D; 2;
  int32 result_per_page &#x3D; 3;
&#125;</code></pre>

<p>在Java里面的体现</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchRequest</span> </span>&#123;
  <span class="hljs-keyword">private</span> string query;
  <span class="hljs-keyword">private</span> page_number;
  <span class="hljs-keyword">private</span> result_per_page;
&#125;</code></pre>

<h2 id="成员变量的介绍"><a href="#成员变量的介绍" class="headerlink" title="成员变量的介绍"></a>成员变量的介绍</h2><p>语法格式： [数量修饰符] 类型修饰符 变量名称 = 标记序号</p>
<pre><code class="hljs proto">message SearchRequest &#123;
  repeated string query &#x3D; 1;
  repeated int32 page_number &#x3D; 2;
  int32 result_per_page &#x3D; 3;
  enum Corpus &#123;
    UNIVERSAL &#x3D; 0;
    WEB &#x3D; 1;
    IMAGES &#x3D; 2;
    LOCAL &#x3D; 3;
    NEWS &#x3D; 4;
    PRODUCTS &#x3D; 5;
    VIDEO &#x3D; 6;
  &#125;
  Corpus corpus &#x3D; 4;
&#125;</code></pre>

<h3 id="数量修饰符"><a href="#数量修饰符" class="headerlink" title="数量修饰符"></a>数量修饰符</h3><ul>
<li>required:必须填写的字段</li>
<li>repeated:可以重复出现的，也就是数组或List</li>
<li>optional:可选值</li>
</ul>
<h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><img src="https://gitee.com/unclezs/image-blog/raw/master///20201120174813.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201120174813.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul>
<li>For strings, the default value is the empty string.</li>
<li>For bytes, the default value is empty bytes.</li>
<li>For bools, the default value is false.</li>
<li>For numeric types, the default value is zero.</li>
<li>For enums, the default value is the first defined enum value, which must be 0.</li>
</ul>
<h3 id="标记序号"><a href="#标记序号" class="headerlink" title="标记序号"></a>标记序号</h3><p>如您所见，消息定义中的每个字段都有一个唯一的编号。这些字段号用于标识消息二进制格式的字段，一旦使用了消息类型，就不应更改它们。</p>
<h2 id="定义Service"><a href="#定义Service" class="headerlink" title="定义Service"></a>定义Service</h2><pre><code class="hljs proto">service SearchService &#123;
  rpc Search(SearchRequest) returns (SearchResponse);
&#125;</code></pre>

<p>可以将他看作一个rpc的接口，里面有一个名字为Search的方法，入参为SearchRequest，相应结果为SearchResponse。可以定义多个，格式相同，SearchRequest也就是message类型的</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;

option java_multiple_files &#x3D; true;
option java_package &#x3D; &quot;com.unclezs&quot;;
option java_outer_classname &#x3D; &quot;MyGrpcService&quot;;
option objc_class_prefix &#x3D; &quot;HLW&quot;;

&#x2F;&#x2F; The greeting service definition.
service MyGrpcServer &#123;
  &#x2F;&#x2F; Sends a greeting
  rpc handle (Request) returns (Response) &#123;&#125;
&#125;

&#x2F;&#x2F; The request message containing the user&#39;s name.
message Request &#123;
  string name &#x3D; 1;
  repeated string list &#x3D; 2;
&#125;

&#x2F;&#x2F; The response message containing the greetings
message Response &#123;
  string message &#x3D; 1;
  string test&#x3D;2;
&#125;</code></pre>

<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://developers.google.cn/protocol-buffers/docs/proto3#">Language Guide (proto3)</a></p>
]]></content>
      <categories>
        <category>后端研发</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper一文入门</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/Zookeeper%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<p>上面的解释有点抽象，简单来说zookeeper=文件系统+监听通知机制。</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>Zookeeper维护一个类似文件系统的数据结构：<br><img src="https://gitee.com/unclezs/image-blog/raw/master///20201117184457.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201117184457.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/><br>每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。</p>
<p>有四种类型的znode：</p>
<ul>
<li>PERSISTENT-持久化目录节点<br>客户端与zookeeper断开连接后，该节点依旧存在</li>
<li>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点<br>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</li>
<li>EPHEMERAL-临时目录节点<br>客户端与zookeeper断开连接后，该节点被删除</li>
<li>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点<br>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
<h3 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h3><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p>
<p>就这么简单，下面我们看看Zookeeper能做点什么呢？</p>
<h2 id="Zookeeper能做什么"><a href="#Zookeeper能做什么" class="headerlink" title="Zookeeper能做什么"></a>Zookeeper能做什么</h2><p>zookeeper功能非常强大，可以实现诸如分布式应用配置管理、统一命名服务、状态同步服务、集群管理等功能，我们这里拿比较简单的分布式应用配置管理为例来说明。</p>
<p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20201117184435.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201117184435.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>如上，你大致应该了解zookeeper是个什么东西，大概能做些什么了，我们马上来学习下zookeeper的安装及使用，并开发一个小程序来实现zookeeper这个分布式配置管理的功能。</p>
<h2 id="Zookeeper单机模式安装"><a href="#Zookeeper单机模式安装" class="headerlink" title="Zookeeper单机模式安装"></a>Zookeeper单机模式安装</h2><ol>
<li>配置JAVA环境，检验环境：java -version</li>
<li>下载并解压zookeeper <pre><code class="hljs shell">cd /usr/local
wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz
tar -zxvf zookeeper-3.4.12.tar.gz
cd zookeeper-3.4.12</code></pre></li>
<li>重命名配置文件zoo_sample.cfg <pre><code class="hljs shell">cp conf/zoo_sample.cfg conf/zoo.cfg</code></pre></li>
<li>启动zookeeper <pre><code class="hljs shell">bin/zkServer.sh start</code></pre></li>
<li>检测是否成功启动，用zookeeper客户端连接下服务端 <pre><code class="hljs shell">bin/zk-Cli.sh</code></pre></li>
<li>安装完成，测试  </li>
</ol>
<h2 id="Zookeeper使用"><a href="#Zookeeper使用" class="headerlink" title="Zookeeper使用"></a>Zookeeper使用</h2><p>使用客户端命令操作zookeeper</p>
<ol>
<li>使用 ls 命令来查看当前 ZooKeeper 中所包含的内容</li>
<li>创建一个新的 znode ，使用 create /zkPro myData</li>
<li>再次使用 ls 命令来查看现在 zookeeper 中所包含的内容：</li>
<li>下面我们运行 get 命令来确认第二步中所创建的 znode 是否包含我们所创建的字符串：</li>
<li>下面我们通过 set 命令来对 zk 所关联的字符串进行设置：</li>
<li>下面我们将刚才创建的 znode 删除</li>
</ol>
<h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhanghongguo@sensorsdata.cn</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2020/11/17 17:40</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CrudTest</span> </span>&#123;
  <span class="hljs-keyword">static</span> ZooKeeper zooKeeper = <span class="hljs-keyword">null</span>;
  <span class="hljs-keyword">static</span> Stat stat = <span class="hljs-keyword">new</span> Stat();
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;                                 
    CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);
    zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(<span class="hljs-string">&quot;10.120.194.170:2181&quot;</span>, <span class="hljs-number">4000</span>, event -&gt; &#123;
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">if</span> (Watcher.Event.KeeperState.SyncConnected == event.getState()&amp;&amp;<span class="hljs-keyword">null</span>==event.getPath()) &#123;
          <span class="hljs-comment">//如果收到了服务端的响应事件，连接成功</span>
          System.out.println(zooKeeper.getState());
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.getType() == Watcher.Event.EventType.NodeDataChanged) &#123;
          System.out.println(<span class="hljs-keyword">new</span> String(zooKeeper.getData(event.getPath(), <span class="hljs-keyword">true</span>, stat)));
        &#125;
      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        e.printStackTrace();
      &#125;
    &#125;);
    System.out.println(<span class="hljs-keyword">new</span> String(zooKeeper.getData(<span class="hljs-string">&quot;/uncle&quot;</span>, <span class="hljs-keyword">true</span>, stat)));
    countDownLatch.await();
  &#125;
&#125;</code></pre>


<p>参考 <a href="https://blog.csdn.net/java_66666/article/details/81015302">Zookeeper入门看这篇就够了</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx的日志模块</title>
    <url>/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/nginx%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天看到了我司用nginx日志来进行原始数据采集，感觉十分有趣，并且平时对这个模块了解不多。所以便了解了解。</p>
<p>nginx日志模块的作用就是存储访问日志，而且可以高度控制日志的格式、压缩类型等等</p>
<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><pre><code class="hljs ini">access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];
access_log off;</code></pre>

<h2 id="格式化记录日志"><a href="#格式化记录日志" class="headerlink" title="格式化记录日志"></a>格式化记录日志</h2><h3 id="先给一个例子"><a href="#先给一个例子" class="headerlink" title="先给一个例子"></a>先给一个例子</h3><pre><code class="hljs plain">log_format custom &#39;$remote_addr - [$time_local] &#39;
                       &#39;&quot;$request&quot; $status $bytes_sent &#39;
                       &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&#39;;

access_log &#x2F;logs&#x2F;custom-access.log custom;</code></pre>
<p>这个例子就是定义了一个format custom记录了访问的IP及访问时间，状态码、防盗链、UA、及压缩格式等等，并且在访问日志出设置。</p>
<h3 id="log-format"><a href="#log-format" class="headerlink" title="log_format"></a>log_format</h3><p>log_format的一些参数，具体可以查看文末官网链接<br><img src="https://gitee.com/unclezs/image-blog/raw/master///20201109143033.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20201109143033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<p>语法</p>
<pre><code class="hljs ini">Syntax:	log_format name [escape=default|json|none] string ...;
Default:	log_format combined &quot;...&quot;;
Context:	http</code></pre>

<h3 id="按照条件打日志"><a href="#按照条件打日志" class="headerlink" title="按照条件打日志"></a>按照条件打日志</h3><p>如果access_log设置了条件，则会在满足条件的请求才会打日志,当条件结果为0或者空字符串的时候则不会记录日志。</p>
<p>比如我们只记录状态码5xx的日志，可以这么做</p>
<pre><code class="hljs plain">map $status $loggable &#123;
    ~^[5]  1;
    default 0;
&#125;

access_log &#x2F;path&#x2F;to&#x2F;access.log combined if&#x3D;$loggable;</code></pre>
<p>其中combinded为默认格式化格式</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>还有几个点没有说，比如日志用到的变量可以缓存，日志压缩，文件缓冲区，日志刷新间隔时间，更多内容参考</p>
<ol>
<li><a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">Module ngx_http_log_module</a></li>
</ol>
]]></content>
      <categories>
        <category>服务器</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL之组内排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E4%B9%8B%E7%BB%84%E5%86%85%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h2 id="rank-over-order-by"><a href="#rank-over-order-by" class="headerlink" title="rank() over(order by)"></a>rank() over(order by)</h2><h3 id="建立表"><a href="#建立表" class="headerlink" title="建立表"></a>建立表</h3><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`players`</span> (
  <span class="hljs-string">`pid`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,
  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`pid`</span>),
  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`name`</span> (<span class="hljs-string">`name`</span>)
) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=latin1;

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`players`</span> (<span class="hljs-string">`pid`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`age`</span>) <span class="hljs-keyword">VALUES</span>
(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Samual&#x27;</span>, <span class="hljs-number">25</span>),
(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Vino&#x27;</span>, <span class="hljs-number">20</span>),
(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">20</span>),
(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Andy&#x27;</span>, <span class="hljs-number">22</span>),
(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Brian&#x27;</span>, <span class="hljs-number">21</span>),
(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Dew&#x27;</span>, <span class="hljs-number">24</span>),
(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Kris&#x27;</span>, <span class="hljs-number">25</span>),
(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;William&#x27;</span>, <span class="hljs-number">26</span>),
(<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;George&#x27;</span>, <span class="hljs-number">23</span>),
(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;Peter&#x27;</span>, <span class="hljs-number">19</span>),
(<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">20</span>),
(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;Andre&#x27;</span>, <span class="hljs-number">20</span>);
</code></pre>

<h3 id="按age升序给运动员排名"><a href="#按age升序给运动员排名" class="headerlink" title="按age升序给运动员排名?"></a>按age升序给运动员排名?</h3><p>注意：rank的over子句中排序字段值相同的给的排名一样</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> pid,<span class="hljs-keyword">name</span>,age,<span class="hljs-keyword">rank</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age) <span class="hljs-keyword">as</span> rank_num 
<span class="hljs-keyword">from</span> players;</code></pre>

<img src="https://gitee.com/unclezs/image-blog/raw/master/20201105112521.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201105112521.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>可以看到有好几个age相同的运动员，他们并列排在第2。</p>
<h3 id="查询排名为第10的学生的姓名，年龄"><a href="#查询排名为第10的学生的姓名，年龄" class="headerlink" title="查询排名为第10的学生的姓名，年龄?"></a>查询排名为第10的学生的姓名，年龄?</h3><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,age
<span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> pid,<span class="hljs-keyword">name</span>,age,<span class="hljs-keyword">rank</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age) <span class="hljs-keyword">as</span> rank_num <span class="hljs-keyword">from</span> players) <span class="hljs-keyword">as</span> rank_table <span class="hljs-comment">--临时表rank_table</span>
<span class="hljs-keyword">where</span> rank_num= <span class="hljs-number">10</span>;</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201105112711.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201105112711.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="rank-over-partition-by-order-by"><a href="#rank-over-partition-by-order-by" class="headerlink" title="rank over(partition by,order by)"></a>rank over(partition by,order by)</h2><p>语法 rank over(partition by 列名,order by 列名)</p>
<p>partition by用于给结果集分组。<br>rank在每个分组内进行排名。</p>
<h3 id="改一下表"><a href="#改一下表" class="headerlink" title="改一下表"></a>改一下表</h3><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> players 
<span class="hljs-keyword">add</span> score <span class="hljs-built_in">int</span>;

<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">98</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">1</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">96</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">2</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">92</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">3</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">96</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">4</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">97</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">5</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">92</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">6</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">88</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">7</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">89</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">8</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">88</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">9</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">88</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">10</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">92</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">11</span>;
<span class="hljs-keyword">update</span> players <span class="hljs-keyword">set</span> score=<span class="hljs-number">91</span> <span class="hljs-keyword">where</span> pid=<span class="hljs-number">12</span>;

<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> players;
</code></pre>

<img src="https://gitee.com/unclezs/image-blog/raw/master/20201105112812.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201105112812.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h3 id="按年龄分组，组内按分数降序排名"><a href="#按年龄分组，组内按分数降序排名" class="headerlink" title="按年龄分组，组内按分数降序排名?"></a>按年龄分组，组内按分数降序排名?</h3><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,age,score,<span class="hljs-keyword">rank</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> rank_num
<span class="hljs-keyword">from</span> players;
</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20201105112851.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20201105112851.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LDAP概念和原理介绍</title>
    <url>/%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/LDAP%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html</url>
    <content><![CDATA[<h2 id="什么是LDAP？"><a href="#什么是LDAP？" class="headerlink" title="什么是LDAP？"></a>什么是LDAP？</h2><p>LDAP（Light Directory Access Portocol），它是基于X.500标准的轻量级目录访问协议。</p>
<p>目录是一个为查询、浏览和搜索而优化的数据库，它成树状结构组织数据，类似文件目录一样。</p>
<p>目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。</p>
<p>LDAP目录服务是由目录数据库和一套访问协议组成的系统。</p>
<h3 id="什么是目录服务？"><a href="#什么是目录服务？" class="headerlink" title="什么是目录服务？"></a>什么是目录服务？</h3><ol>
<li>目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。</li>
<li>是动态的，灵活的，易扩展的。<br>如：人员组织管理，电话簿，地址簿。</li>
</ol>
<h2 id="LDAP的基本模型"><a href="#LDAP的基本模型" class="headerlink" title="LDAP的基本模型"></a>LDAP的基本模型</h2><p>每一个系统、协议都会有属于自己的模型，LDAP也不例外，在了解LDAP的基本模型之前我们需要先了解几个LDAP的目录树概念：</p>
<h3 id="目录树概念"><a href="#目录树概念" class="headerlink" title="目录树概念"></a>目录树概念</h3><ol>
<li>目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目。</li>
<li>条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）。</li>
<li>对象类：与某个实体类型对应的一组属性，对象类是可以继承的，这样父类的必须属性也会被继承下来。</li>
<li>属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。</li>
</ol>
<h3 id="LDAP的特点"><a href="#LDAP的特点" class="headerlink" title="LDAP的特点"></a>LDAP的特点</h3><ul>
<li>LDAP的结构用树来表示，而不是用表格。正因为这样，就不能用SQL语句了</li>
<li>LDAP可以很快地得到查询结果，不过在写方面，就慢得多</li>
<li>LDAP提供了静态数据的快速查询方式</li>
<li>Client/server模型，Server 用于存储数据，Client提供操作目录信息树的工具</li>
<li>这些工具可以将数据库的内容以文本格式（LDAP 数据交换格式，LDIF）呈现在您的面前</li>
<li>LDAP是一种开放Internet标准，LDAP协议是跨平台的Interent协议</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wilburxu/p/9174353.html">LDAP概念和原理介绍</a><br><a href="https://segmentfault.com/a/1190000002607140">LDAP服务器的概念和原理简单介绍</a></p>
]]></content>
      <categories>
        <category>后端研发</category>
      </categories>
      <tags>
        <tag>单点登陆</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL不同隔离级别下的加锁情况</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>InnoDB的四个事务隔离级别：1992标准： READ UNCOMMITTED， READ COMMITTED， REPEATABLE READ，和 SERIALIZABLE。默认隔离级别InnoDB是 REPEATABLE READ。</p>
<p>那么在各个隔离级别的加锁情况也略有不同。</p>
<h2 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h2><p>这是的默认隔离级别 , 同一事务中的一致读取将读取第一次读取建立的快照。这意味着，如果您SELECT 在同一事务中发出多个普通（非锁定）语句，则这些 SELECT语句彼此之间也是一致的。</p>
<p>对于锁定读取 （SELECT使用FOR UPDATE或FOR SHARE）， UPDATE和 DELETE语句，锁定取决于该语句使用的是具有唯一搜索条件的唯一索引还是范围类型搜索条件。</p>
<ul>
<li>对于具有等值查询的条件的唯一索引，InnoDB仅锁定找到的索引记录，而不锁定其前的间隙，也就行是只加行级锁不加间隙锁。</li>
<li>对于其他查询条件（不管索引类型），使用间隙锁和next-key lock来进行锁定。</li>
</ul>
<h2 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h2><p>因为READ COMMITTED在执行锁定读取（SELECT 使用FOR UPDATE或FOR SHARE），UPDATE 语句和DELETE 语句的时候，InnoDB仅锁定索引记录，而不锁定它们之间的间隙。所以可以在这条锁定记录旁边插入数据，导致幻读。</p>
<p>加锁情况：</p>
<ul>
<li>对于UPDATE或 DELETE语句， InnoDB仅对其更新或删除的行加锁。MySQL评估WHERE条件后，将释放不匹配行的行级锁 。这大大降低了死锁的可能性，但是仍然可以发生。</li>
<li>对于UPDATE语句，如果某行已被锁定，则InnoDB 执行 <strong>“semi-consistent”</strong> 读取，也就是说将事务A中修改后提交的最新数据反馈给MySQL，让事务B拿到事务A一句提交的最新数据进行比较where匹配情况。也就是读已经提交的数据进行比较。而RR隔离级别就是会直接阻塞等待，不会拿最新提交的数据比较。<pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t (a <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, b <span class="hljs-built_in">INT</span>) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>);
<span class="hljs-keyword">COMMIT</span>;

<span class="hljs-comment"># Session A</span>
<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;
<span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> b = <span class="hljs-number">5</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">3</span>;

<span class="hljs-comment"># Session B</span>
<span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> b = <span class="hljs-number">4</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">2</span>;</code></pre></li>
<li>但是对于等值查询的唯一索引，即使有第二个update来之后，也不会进行semi-consistent读取，而是阻塞住，等待第一个update结束后才进行。<pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t (a <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, b <span class="hljs-built_in">INT</span>, c <span class="hljs-built_in">INT</span>, <span class="hljs-keyword">INDEX</span> (b)) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);
<span class="hljs-keyword">COMMIT</span>;

<span class="hljs-comment"># Session A</span>
<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;
<span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> b = <span class="hljs-number">3</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> c = <span class="hljs-number">3</span>;

<span class="hljs-comment"># Session B</span>
<span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> b = <span class="hljs-number">4</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> c = <span class="hljs-number">4</span>;</code></pre>

</li>
</ul>
<h2 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ UNCOMMITTED"></a>READ UNCOMMITTED</h2><p>SELECT语句以非锁定方式执行，但可能使用行的早期版本。因此，使用这个隔离级别，这样的读取是不一致的。这也叫脏读。否则，此隔离级别的工作方式与READ COMMITTED类似。</p>
<h2 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h2><p>这个级别类似于RR，但是InnoDB隐式地将所有纯SELECT语句转换为SELECT   … FOR SHARE 如果禁用自动提交，则为共享。如果启用了自动提交，则选择是它自己的事务。因此，已知它是只读的，如果作为一致（非锁定）读取执行，则可以序列化它，并且不需要阻塞其他事务。（若要强制普通选择阻止其他事务已修改选定行，请禁用自动提交。）</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">Transaction Isolation Levels</a></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html">Locks Set by Different SQL Statements in InnoDB</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>隔离级别</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC工具类之CyclicBarrier</title>
    <url>/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BCyclicBarrier.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。 </p>
</li>
<li><p>对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。</p>
</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="hljs java">
<span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierTest</span> </span>&#123;

    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
        <span class="hljs-keyword">private</span> CyclicBarrier cb;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name, CyclicBarrier cb)</span> </span>&#123;
            <span class="hljs-keyword">super</span>(name);
            <span class="hljs-keyword">this</span>.cb = cb;
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;第一步&quot;</span>);
                cb.await();
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;第二步&quot;</span>);
                cb.await();
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        CyclicBarrier cb = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>, () -&gt; &#123;
            System.out.println(<span class="hljs-string">&quot;进入下一阶段&quot;</span>);
        &#125;);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;
            <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;thread-&quot;</span> + i, cb).start();
        &#125;
    &#125;
&#125;</code></pre>

<p>其中一次输出：</p>
<pre><code class="hljs plain">thread-0第一步
thread-1第一步
进入下一阶段
thread-1第二步
thread-0第二步
进入下一阶段
thread-0结束
thread-1结束</code></pre>


<h2 id="和CountDonwLatch对比"><a href="#和CountDonwLatch对比" class="headerlink" title="和CountDonwLatch对比"></a>和CountDonwLatch对比</h2><ul>
<li>CountDownLatch减计数，CyclicBarrier加计数。 </li>
<li>CountDownLatch是一次性的，CyclicBarrier可以重用。 </li>
<li>CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是Coun tDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC工具类之CountDownLatch</title>
    <url>/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8BCountDownLatch.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CountDownLatch底层也是由AQS，用来同步一个或多个任务的常用并发工具类，强制它们等待由其他任务执行的一组操作完成。</p>
<p>从源码可知，其底层是由AQS提供支持，所以其数据结构可以参考AQS的数据结构，而AQS的数据结构核心就是两个虚拟队列: 同步队列sync queue 和条件队列condition queue，不同的条件会有不同的条件队列。CountDownLatch典型的用法是将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。当每一个任务完成时，都会在这个锁存器上调用countDown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束。</p>
<h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name, CountDownLatch countDownLatch)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(name);
        <span class="hljs-keyword">this</span>.countDownLatch = countDownLatch;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; doing something&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">1000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; finish&quot;</span>);
        countDownLatch.countDown();
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);
        MyThread t1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;t1&quot;</span>, countDownLatch);
        MyThread t2 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;t2&quot;</span>, countDownLatch);
        t1.start();
        t2.start();
        System.out.println(<span class="hljs-string">&quot;Waiting for t1 thread and t2 thread to finish&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            countDownLatch.await();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;            
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; continue&quot;</span>);        
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html</url>
    <content><![CDATA[<h2 id="举例现实场景来理解"><a href="#举例现实场景来理解" class="headerlink" title="举例现实场景来理解"></a>举例现实场景来理解</h2><p>我们试想一下这样的现实场景: </p>
<p>一个餐厅同时有100位客人到店，当然到店后第一件要做的事情就是点菜。但是问题来了，餐厅老板为了节约人力成本目前只有一位大堂服务员拿着唯一的一本菜单等待客人进行服务。</p>
<ul>
<li><p><strong>方法A</strong>.无论有多少客人等待点餐，服务员都把仅有的一份菜单递给其中一位客人，然后站在客人身旁等待这个客人完成点菜过程。在记录客人点菜内容后，把点菜记录交给后堂厨师。然后是第二位客人。。。。然后是第三位客人。很明显，只有脑袋被门夹过的老板，才会这样设置服务流程。因为随后的80位客人，再等待超时后就会离店(还会给差评)。</p>
</li>
<li><p><strong>方法B</strong>.老板马上新雇佣99名服务员，同时印制99本新的菜单。每一名服务员手持一本菜单负责一位客人(关键不只在于服务员，还在于菜单。因为没有菜单客人也无法点菜)。在客人点完菜后，记录点菜内容交给后堂厨师(当然为了更高效，后堂厨师最好也有100名)。这样每一位客人享受的就是VIP服务咯，当然客人不会走，但是人力成本可是一个大头哦(亏死你)。</p>
</li>
<li><p><strong>方法C</strong>.当客人到店后，自己申请一本菜单。想好自己要点的才后，就呼叫服务员。服务员站在自己身边后记录客人的菜单内容。将菜单递给厨师的过程也要进行改进，并不是每一份菜单记录好以后，都要交给后堂厨师。服务员可以记录号多份菜单后，同时交给厨师就行了。那么这种方式，对于老板来说人力成本是最低的；对于客人来说，虽然不再享受VIP服务并且要进行一定的等待，但是这些都是可接受的；对于服务员来说，基本上她的时间都没有浪费，基本上被老板压杆了最后一滴油水。</p>
</li>
</ul>
<p>到店情况: 并发量。到店情况不理想时，一个服务员一本菜单，当然是足够了。所以不同的老板在不同的场合下，将会灵活选择服务员和菜单的配置。</p>
<ul>
<li>客人: 客户端请求 </li>
<li>点餐内容: 客户端发送的实际数据 </li>
<li>老板: 操作系统 </li>
<li>人力成本: 系统资源 </li>
<li>菜单: 文件状态描述符。操作系统对于一个进程能够同时持有的文件状态描述符的个数是有限制的，在linux系统中$ulimit -n查看这个限制值，当然也是可以(并且应该)进行内核参数调整的。 </li>
<li>服务员: 操作系统内核用于IO操作的线程(内核线程) </li>
<li>厨师: 应用程序线程(当然厨房就是应用程序进程咯)</li>
<li>餐单传递方式: 包括了阻塞式和非阻塞式两种。<ul>
<li>方法A: 阻塞式/非阻塞式 同步IO</li>
<li>方法B: 使用线程进行处理的 阻塞式/非阻塞式 同步IO</li>
<li>方法C: 阻塞式/非阻塞式 多路复用IO</li>
</ul>
</li>
</ul>
<h2 id="多路复用IO实现"><a href="#多路复用IO实现" class="headerlink" title="多路复用IO实现"></a>多路复用IO实现</h2><p>目前流程的多路复用IO实现主要包括四种: select、poll、epoll、kqueue。下表是他们的一些重要特性的比较:</p>
<table>
<thead>
<tr>
<th>IO模型</th>
<th>相对性能</th>
<th>关键思路</th>
<th>操作系统</th>
<th align="left">JAVA支持情况</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>较高</td>
<td>Reactor</td>
<td>windows/Linux</td>
<td align="left">支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td>
</tr>
<tr>
<td>poll</td>
<td>较高</td>
<td>Reactor</td>
<td>Linux</td>
<td align="left">Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td>
</tr>
<tr>
<td>epoll</td>
<td>高</td>
<td>Reactor/Proactor</td>
<td>Linux</td>
<td align="left">Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td>
</tr>
<tr>
<td>kqueue</td>
<td>高</td>
<td>Proactor</td>
<td>Linux</td>
<td align="left">目前JAVA的版本不支持</td>
</tr>
</tbody></table>
<p>多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用IO技术发挥不出来它的优势。另一方面，使用JAVA NIO进行功能实现，相对于传统的Socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。</p>
<h2 id="IO多路复用工作模式"><a href="#IO多路复用工作模式" class="headerlink" title="IO多路复用工作模式"></a>IO多路复用工作模式</h2><p>epoll 的描述符事件有两种触发模式: LT(level trigger)和 ET(edge trigger)。</p>
<h3 id="LT-模式"><a href="#LT-模式" class="headerlink" title="LT 模式"></a>LT 模式</h3><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。 </p>
<h3 id="ET-模式"><a href="#ET-模式" class="headerlink" title="ET 模式"></a>ET 模式</h3><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。 </p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 </p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。 </p>
<h3 id="select-应用场景"><a href="#select-应用场景" class="headerlink" title="select 应用场景"></a>select 应用场景</h3><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。 select 可移植性更好，几乎被所有主流平台所支持。 </p>
<h3 id="poll-应用场景"><a href="#poll-应用场景" class="headerlink" title="poll 应用场景"></a>poll 应用场景</h3><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。 </p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。 </p>
<h3 id="epoll-应用场景"><a href="#epoll-应用场景" class="headerlink" title="epoll 应用场景"></a>epoll 应用场景</h3><p>只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发之Unsafe类</title>
    <url>/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E4%B9%8BUnsafe%E7%B1%BB.html</url>
    <content><![CDATA[<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p>
<p> 这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>
 <img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20201001201514.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20201001201514.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC核心之AQS原理</title>
    <url>/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E6%A0%B8%E5%BF%83%E4%B9%8BAQS%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<span class="hljs-comment">//共享变量，使用volatile修饰保证线程可见性</span>

<span class="hljs-comment">//返回同步状态的当前值</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;  
        <span class="hljs-keyword">return</span> state;
&#125;
 <span class="hljs-comment">// 设置同步状态的值</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newState)</span> </span>&#123; 
        state = newState;
&#125;
<span class="hljs-comment">//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;
        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, stateOffset, expect, update);
&#125;</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200918133447.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200918133447.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h2><p>AQS定义两种资源共享方式<br>Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 </li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 </li>
</ul>
<p>Share(共享)：多个线程可同时执行</p>
<p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。 不同的自定义同步器争用共享资源的方式也不同。</p>
<p>自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了。</p>
<h2 id="AQS底层使用了模板方法模式"><a href="#AQS底层使用了模板方法模式" class="headerlink" title="AQS底层使用了模板方法模式"></a>AQS底层使用了模板方法模式</h2><pre><code class="hljs java">isHeldExclusively()<span class="hljs-comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
tryAcquire(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
tryRelease(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
tryAcquireShared(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
tryReleaseShared(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></code></pre>

<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p> 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>AbstractQueuedSynchronizer类底层的数据结构是使用<strong>CLH(Craig,Landin,and Hagersten)</strong>队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。</p>
<p>AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。其中Sync queue，即同步队列，是<strong>双向链表</strong>，包括head结点和tail结点，head结点主要用作后续的调度。</p>
<p>而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此<strong>单向链表</strong>。并且可能会有多个Condition queue。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200918143405.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200918143405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="AbstractQueuedSynchronizer源码分析"><a href="#AbstractQueuedSynchronizer源码分析" class="headerlink" title="AbstractQueuedSynchronizer源码分析"></a>AbstractQueuedSynchronizer源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><p>AbstractQueuedSynchronizer继承自AbstractOwnableSynchronizer抽象类，并且实现了Serializable接口，可以进行序列化。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></code></pre>
<p>其中AbstractOwnableSynchronizer抽象类主要用于存储独占模式下当前的线程是哪一个，源码如下:</p>
<pre><code class="hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">// 版本序列号</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3737899427754241961L</span>;
    <span class="hljs-comment">// 构造方法</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> </span>&#123; &#125;
    <span class="hljs-comment">// 独占模式下的线程</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;
    
    <span class="hljs-comment">// 设置独占线程 </span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> </span>&#123;
        exclusiveOwnerThread = thread;
    &#125;
    
    <span class="hljs-comment">// 获取独占线程 </span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title">getExclusiveOwnerThread</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> exclusiveOwnerThread;
    &#125;
&#125;</code></pre>
<h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><p>有两个内部类，Node和ConditionObject</p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><pre><code class="hljs java">
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
    <span class="hljs-comment">// 模式，分为共享与独占</span>
    <span class="hljs-comment">// 共享模式</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();
    <span class="hljs-comment">// 独占模式</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;        
    <span class="hljs-comment">// 结点状态</span>
    <span class="hljs-comment">// CANCELLED，值为1，表示当前的线程被取消</span>
    <span class="hljs-comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span>
    <span class="hljs-comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span>
    <span class="hljs-comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span>
    <span class="hljs-comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;        
    <span class="hljs-comment">// 结点状态</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;        
    <span class="hljs-comment">// 前驱结点</span>
    <span class="hljs-keyword">volatile</span> Node prev;    
    <span class="hljs-comment">// 后继结点</span>
    <span class="hljs-keyword">volatile</span> Node next;        
    <span class="hljs-comment">// 结点所对应的线程</span>
    <span class="hljs-keyword">volatile</span> Thread thread;        
    <span class="hljs-comment">// 下一个等待者</span>
    Node nextWaiter;
    
    <span class="hljs-comment">// 结点是否在共享模式下等待</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> nextWaiter == SHARED;
    &#125;
    
    <span class="hljs-comment">// 获取前驱结点，若前驱结点为空，抛出异常</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;
        <span class="hljs-comment">// 保存前驱结点</span>
        Node p = prev; 
        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 前驱结点为空，抛出异常</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 前驱结点不为空，返回</span>
            <span class="hljs-keyword">return</span> p;
    &#125;
    
    <span class="hljs-comment">// 无参构造方法</span>
    Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span>
    &#125;
    
    <span class="hljs-comment">// 构造方法</span>
        Node(Thread thread, Node mode) &#123;    <span class="hljs-comment">// Used by addWaiter</span>
        <span class="hljs-keyword">this</span>.nextWaiter = mode;
        <span class="hljs-keyword">this</span>.thread = thread;
    &#125;
    
    <span class="hljs-comment">// 构造方法</span>
    Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span>
        <span class="hljs-keyword">this</span>.waitStatus = waitStatus;
        <span class="hljs-keyword">this</span>.thread = thread;
    &#125;
&#125;</code></pre>


<h4 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">// 版本号</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1173984872572414699L</span>;
    <span class="hljs-comment">/** First node of condition queue. */</span>
    <span class="hljs-comment">// condition队列的头结点</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;
    <span class="hljs-comment">/** Last node of condition queue. */</span>
    <span class="hljs-comment">// condition队列的尾结点</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;

    <span class="hljs-comment">// 构造方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConditionObject</span><span class="hljs-params">()</span> </span>&#123; &#125;


    <span class="hljs-comment">// 添加新的waiter到wait队列</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 保存尾结点</span>
        Node t = lastWaiter;
        <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span>
        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123; <span class="hljs-comment">// 尾结点不为空，并且尾结点的状态不为CONDITION</span>
            <span class="hljs-comment">// 清除状态为CONDITION的结点</span>
            unlinkCancelledWaiters(); 
            <span class="hljs-comment">// 将最后一个结点重新赋值给t</span>
            t = lastWaiter;
        &#125;
        <span class="hljs-comment">// 新建一个结点</span>
        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);
        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 尾结点为空</span>
            <span class="hljs-comment">// 设置condition队列的头结点</span>
            firstWaiter = node;
        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 尾结点不为空</span>
            <span class="hljs-comment">// 设置为节点的nextWaiter域为node结点</span>
            t.nextWaiter = node;
        <span class="hljs-comment">// 更新condition队列的尾结点</span>
        lastWaiter = node;
        <span class="hljs-keyword">return</span> node;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;
        <span class="hljs-comment">// 循环</span>
        <span class="hljs-keyword">do</span> &#123;
            <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 该节点的nextWaiter为空</span>
                <span class="hljs-comment">// 设置尾结点为空</span>
                lastWaiter = <span class="hljs-keyword">null</span>;
            <span class="hljs-comment">// 设置first结点的nextWaiter域</span>
            first.nextWaiter = <span class="hljs-keyword">null</span>;
        &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;
                    (first = firstWaiter) != <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 将结点从condition队列转移到sync队列失败并且condition队列中的头结点不为空，一直循环</span>
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>&#123;
        <span class="hljs-comment">// condition队列的头结点尾结点都设置为空</span>
        lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 循环</span>
        <span class="hljs-keyword">do</span> &#123;
            <span class="hljs-comment">// 获取first结点的nextWaiter域结点</span>
            Node next = first.nextWaiter;
            <span class="hljs-comment">// 设置first结点的nextWaiter域为空</span>
            first.nextWaiter = <span class="hljs-keyword">null</span>;
            <span class="hljs-comment">// 将first结点从condition队列转移到sync队列</span>
            transferForSignal(first);
            <span class="hljs-comment">// 重新设置first</span>
            first = next;
        &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);
    &#125;

    <span class="hljs-comment">// 从condition队列中清除状态为CANCEL的结点</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlinkCancelledWaiters</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 保存condition队列头结点</span>
        Node t = firstWaiter;
        Node trail = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t不为空</span>
            <span class="hljs-comment">// 下一个结点</span>
            Node next = t.nextWaiter;
            <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123; <span class="hljs-comment">// t结点的状态不为CONDTION状态</span>
                <span class="hljs-comment">// 设置t节点的额nextWaiter域为空</span>
                t.nextWaiter = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">if</span> (trail == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// trail为空</span>
                    <span class="hljs-comment">// 重新设置condition队列的头结点</span>
                    firstWaiter = next;
                <span class="hljs-keyword">else</span> <span class="hljs-comment">// trail不为空</span>
                    <span class="hljs-comment">// 设置trail结点的nextWaiter域为next结点</span>
                    trail.nextWaiter = next;
                <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// next结点为空</span>
                    <span class="hljs-comment">// 设置condition队列的尾结点</span>
                    lastWaiter = trail;
            &#125;
            <span class="hljs-keyword">else</span> <span class="hljs-comment">// t结点的状态为CONDTION状态</span>
                <span class="hljs-comment">// 设置trail结点</span>
                trail = t;
            <span class="hljs-comment">// 设置t结点</span>
            t = next;
        &#125;
    &#125;

    <span class="hljs-comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!isHeldExclusively()) <span class="hljs-comment">// 不被当前线程独占，抛出异常</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
        <span class="hljs-comment">// 保存condition队列头结点</span>
        Node first = firstWaiter;
        <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 头结点不为空</span>
            <span class="hljs-comment">// 唤醒一个等待线程</span>
            doSignal(first);
    &#125;


    <span class="hljs-comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!isHeldExclusively()) <span class="hljs-comment">// 不被当前线程独占，抛出异常</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
        <span class="hljs-comment">// 保存condition队列头结点</span>
        Node first = firstWaiter;
        <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 头结点不为空</span>
            <span class="hljs-comment">// 唤醒所有等待线程</span>
            doSignalAll(first);
    &#125;

    <span class="hljs-comment">// 等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 添加一个结点到等待队列</span>
        Node node = addConditionWaiter();
        <span class="hljs-comment">// 获取释放的状态</span>
        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);
        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="hljs-comment">// </span>
            <span class="hljs-comment">// 阻塞当前线程</span>
            LockSupport.park(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">if</span> (Thread.interrupted()) <span class="hljs-comment">// 当前线程被中断</span>
                <span class="hljs-comment">// 设置interrupted状态</span>
                interrupted = <span class="hljs-keyword">true</span>; 
        &#125;
        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="hljs-comment">// </span>
            selfInterrupt();
    &#125;

    <span class="hljs-comment">/** Mode meaning to reinterrupt on exit from wait */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REINTERRUPT =  <span class="hljs-number">1</span>;
    <span class="hljs-comment">/** Mode meaning to throw InterruptedException on exit from wait */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THROW_IE    = -<span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> </span>&#123;
        <span class="hljs-keyword">return</span> Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            <span class="hljs-number">0</span>; 
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interruptMode)</span></span>
<span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)
            selfInterrupt();
    &#125;

    <span class="hljs-comment">// 等待，当前线程在接到信号或被中断之前一直处于等待状态</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">if</span> (Thread.interrupted()) <span class="hljs-comment">// 当前线程被中断，抛出异常</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        <span class="hljs-comment">// 在wait队列上添加一个结点</span>
        Node node = addConditionWaiter();
        <span class="hljs-comment">// </span>
        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);
        <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;
            <span class="hljs-comment">// 阻塞当前线程</span>
            LockSupport.park(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>) <span class="hljs-comment">// 检查结点等待时的中断类型</span>
                <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span>
            unlinkCancelledWaiters();
        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)
            reportInterruptAfterWait(interruptMode);
    &#125;

    <span class="hljs-comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span></span>
<span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">if</span> (Thread.interrupted())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        Node node = addConditionWaiter();
        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;
        <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;
            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;
                transferAfterCancelledWait(node);
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)
                LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);
            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)
                <span class="hljs-keyword">break</span>;
            nanosTimeout = deadline - System.nanoTime();
        &#125;
        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)
            unlinkCancelledWaiters();
        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)
            reportInterruptAfterWait(interruptMode);
        <span class="hljs-keyword">return</span> deadline - System.nanoTime();
    &#125;

    <span class="hljs-comment">// 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span></span>
<span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">long</span> abstime = deadline.getTime();
        <span class="hljs-keyword">if</span> (Thread.interrupted())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        Node node = addConditionWaiter();
        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);
        <span class="hljs-keyword">boolean</span> timedout = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;
            <span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt; abstime) &#123;
                timedout = transferAfterCancelledWait(node);
                <span class="hljs-keyword">break</span>;
            &#125;
            LockSupport.parkUntil(<span class="hljs-keyword">this</span>, abstime);
            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)
                <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)
            unlinkCancelledWaiters();
        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)
            reportInterruptAfterWait(interruptMode);
        <span class="hljs-keyword">return</span> !timedout;
    &#125;

    <span class="hljs-comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) &gt; 0</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span></span>
<span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">long</span> nanosTimeout = unit.toNanos(time);
        <span class="hljs-keyword">if</span> (Thread.interrupted())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        Node node = addConditionWaiter();
        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;
        <span class="hljs-keyword">boolean</span> timedout = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;
            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;
                timedout = transferAfterCancelledWait(node);
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)
                LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);
            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)
                <span class="hljs-keyword">break</span>;
            nanosTimeout = deadline - System.nanoTime();
        &#125;
        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)
            unlinkCancelledWaiters();
        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)
            reportInterruptAfterWait(interruptMode);
        <span class="hljs-keyword">return</span> !timedout;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOwnedBy</span><span class="hljs-params">(AbstractQueuedSynchronizer sync)</span> </span>&#123;
        <span class="hljs-keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-comment">//  查询是否有正在等待此条件的任何线程</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasWaiters</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!isHeldExclusively())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
        <span class="hljs-keyword">for</span> (Node w = firstWaiter; w != <span class="hljs-keyword">null</span>; w = w.nextWaiter) &#123;
            <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;

    <span class="hljs-comment">// 返回正在等待此条件的线程数估计值</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWaitQueueLength</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!isHeldExclusively())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (Node w = firstWaiter; w != <span class="hljs-keyword">null</span>; w = w.nextWaiter) &#123;
            <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION)
                ++n;
        &#125;
        <span class="hljs-keyword">return</span> n;
    &#125;

    <span class="hljs-comment">// 返回包含那些可能正在等待此条件的线程集合</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title">getWaitingThreads</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!isHeldExclusively())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
        ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Thread&gt;();
        <span class="hljs-keyword">for</span> (Node w = firstWaiter; w != <span class="hljs-keyword">null</span>; w = w.nextWaiter) &#123;
            <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION) &#123;
                Thread t = w.thread;
                <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)
                    list.add(t);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;
&#125;
</code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS底层是通过一个状态量State记录当前同步器的状态，这个状态量的更改是通过CAS方式更新，同时维护了一个等待队列，如果新的任务进来的时候发现AQS是独占模式并且状态为0，则表示可以直接执行，如果状态为1则加入等待队列（双向链表），当调用unlock的时候唤醒等待队列中没有被取消的线程。</p>
<p>如果为非公平模式，当AQS已经被使用完成，从等待队列中唤醒一个任务的时候同时有一个任务也正加入进来，则两个任务直接竞争。如果是公平模式则直接将新加的任务放入队尾。</p>
<p>而AQS中还有Condition，也就是一个锁可以有多个条件来保证并发</p>
<p>推荐阅读：<a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html">JUC：AQS详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP与HTTPS详解</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E4%B8%8EHTTPS%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全</p>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h2 id="HTTPS和HTTP的主要区别"><a href="#HTTPS和HTTP的主要区别" class="headerlink" title="HTTPS和HTTP的主要区别"></a>HTTPS和HTTP的主要区别</h2><ol>
<li>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<h2 id="HTTPS的传输过程"><a href="#HTTPS的传输过程" class="headerlink" title="HTTPS的传输过程"></a>HTTPS的传输过程</h2><ol>
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li>
<li>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li>
<li>客户端拿到证书，证书校验通过后，用系统内置的CA证书，进行对证书解密，拿到公钥。</li>
<li>客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。</li>
<li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥对数据进行对称加密，再与客户端进程通讯。</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200917102430.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200917102430.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="CA证书作用"><a href="#CA证书作用" class="headerlink" title="CA证书作用"></a>CA证书作用</h2><p>CA证书就是服务端自己有一份公钥私钥，把公钥给CA证书，获得一份数字证书，当客户端来请求时，就拿这个数字证书给客户端，客户端再通过CA认证算法拿到公钥，再进行后续操作。</p>
<h2 id="SSL与TLS的区别？"><a href="#SSL与TLS的区别？" class="headerlink" title="SSL与TLS的区别？"></a>SSL与TLS的区别？</h2><p><strong>SSL</strong>：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p>
<p><strong>TLS</strong>：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</p>
<h2 id="SSL-TLS协议的基本过程"><a href="#SSL-TLS协议的基本过程" class="headerlink" title="SSL/TLS协议的基本过程"></a>SSL/TLS协议的基本过程</h2><h3 id="客户端发出请求（ClientHello）"><a href="#客户端发出请求（ClientHello）" class="headerlink" title="客户端发出请求（ClientHello）"></a>客户端发出请求（ClientHello）</h3><ol>
<li>支持的协议版本，比如TLS 1.0版。</li>
<li>一个客户端生成的随机数，稍后用于生成”对话密钥”。</li>
<li>支持的加密方法，比如RSA公钥加密。</li>
<li>支持的压缩方法。</li>
</ol>
<h3 id="服务器回应（SeverHello）"><a href="#服务器回应（SeverHello）" class="headerlink" title="服务器回应（SeverHello）"></a>服务器回应（SeverHello）</h3><ol>
<li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>
<li>一个服务器生成的随机数，稍后用于生成”对话密钥”。</li>
<li>确认使用的加密方法，比如RSA公钥加密，此时带有公钥信息。</li>
<li>服务器证书。</li>
</ol>
<h3 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h3><ol>
<li>一个随机数pre-master key。该随机数用服务器公钥加密，防止被窃听。</li>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</li>
</ol>
<p>上面客户端回应中第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="那么为什么一定要用三个随机数，来生成”会话密钥”呢？"><a href="#那么为什么一定要用三个随机数，来生成”会话密钥”呢？" class="headerlink" title="那么为什么一定要用三个随机数，来生成”会话密钥”呢？"></a>那么为什么一定要用三个随机数，来生成”会话密钥”呢？</h3><p>为了保证绝对随机，不相信服务器或者客户端的随机数，而是才用三个随机数再进行一定算法计算出真正的 会话密钥(对称加密)</p>
<h3 id="为什么不都使用对称加密而是才有非对称与对称加密组合？"><a href="#为什么不都使用对称加密而是才有非对称与对称加密组合？" class="headerlink" title="为什么不都使用对称加密而是才有非对称与对称加密组合？"></a>为什么不都使用对称加密而是才有非对称与对称加密组合？</h3><p>因为非对称加密比较耗费性能，比对称加密慢了几倍甚至几百倍，所以才有了对称加密进行最终的数据加密。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性哈希算法</title>
    <url>/%E7%AE%97%E6%B3%95/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常见的负载均衡方法有很多，但是它们的优缺点也都很明显：</p>
<ul>
<li><strong>随机访问策略</strong>。系统随机访问，缺点：可能造成服务器负载压力不均衡，俗话讲就是撑的撑死，饿的饿死。</li>
<li><strong>轮询策略</strong>。请求均匀分配，如果服务器有性能差异，则无法实现性能好的服务器能够多承担一部分。</li>
<li><strong>权重轮询策略</strong>。权值需要静态配置，无法自动调节，不适合对长连接和命中率有要求的场景。</li>
<li><strong>Hash取模策略</strong>。不稳定，如果列表中某台服务器宕机，则会导致路由算法产生变化，由此导致命中率的急剧下降。</li>
<li><strong>一致性哈希策略</strong>。</li>
</ul>
<p>以上几个策略，排除本篇介绍的一致性哈希，可能使用最多的就是 Hash取模策略了。Hash取模策略的缺点也是很明显的，这种缺点也许在负载均衡的时候不是很明显，但是在涉及数据访问的主从备份和分库分表中就体现明显了。</p>
<h2 id="一致性Hash性质"><a href="#一致性Hash性质" class="headerlink" title="一致性Hash性质"></a>一致性Hash性质</h2><p>　　考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要，良好的分布式cahce系统中的一致性hash算法应该满足以下几个方面：</p>
<h3 id="平衡性-Balance"><a href="#平衡性-Balance" class="headerlink" title="平衡性(Balance)"></a>平衡性(Balance)</h3><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
<h3 id="单调性-Monotonicity"><a href="#单调性-Monotonicity" class="headerlink" title="单调性(Monotonicity)"></a>单调性(Monotonicity)</h3><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。简单的哈希算法往往不能满足单调性的要求，如最简单的线性哈希：x = (ax + b) mod (P)，在上式中，P表示全部缓冲的大小。不难看出，当缓冲大小发生变化时(从P1到P2)，原来所有的哈希结果均会发生变化，从而不满足单调性的要求。哈希结果的变化意味着当缓冲空间发生变化时，所有的映射关系需要在系统内全部更新。而在P2P系统内，缓冲的变化等价于Peer加入或退出系统，这一情况在P2P系统中会频繁发生，因此会带来极大计算和传输负荷。单调性就是要求哈希算法能够应对这种情况。</p>
<h3 id="分散性-Spread"><a href="#分散性-Spread" class="headerlink" title="分散性(Spread)"></a>分散性(Spread)</h3><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
<h3 id="负载-Load"><a href="#负载-Load" class="headerlink" title="负载(Load)"></a>负载(Load)</h3><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
<h3 id="平滑性-Smoothness"><a href="#平滑性-Smoothness" class="headerlink" title="平滑性(Smoothness)"></a>平滑性(Smoothness)</h3><p>平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>首先求出memcached服务器（节点）的哈希值，并将其配置到0～23^2的圆上。</li>
<li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过23^2仍然找不到服务器，就会保存到第一台服务器上。</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200915100138.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200915100138.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>当我们添加一台机器的时候，只会将一部分节点分配到新加入的节点，如图所示，Node2-Node5之间的数据应该是存储在Node3上，加上新节点Node5之后，只需要将Node2-Node5之间的数据从Node3重分布到Node5就行了，不会全部重分布。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200915100206.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200915100206.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>不过这个有一个问题，就是数据分布的不均匀了。</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200915101206.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200915101206.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>为了解决节点过少数据分部不均匀的问题，引入了虚拟节点，增加hash分布的均匀性。hash环上不再存在物理节点，而是存虚拟节点，虚拟节点对应对应的物理机器。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200915101050.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200915101050.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一致性哈希解决了数据迁移的时候全量重新分布的问题，只用重新分布一部分。还有就是哈希冲突问题还是会有的，但是冲突的概率很低，而且就算冲突了也影响不大。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语法级常见面试题</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/Java%E8%AF%AD%E6%B3%95%E7%BA%A7%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="重载和重写区别"><a href="#重载和重写区别" class="headerlink" title="重载和重写区别"></a>重载和重写区别</h2><h3 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h3><p>发生在运行时期。</p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<h3 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h3><p>发生在编译时期</p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<h2 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h2><ol>
<li>一个子类只能继承一个抽象类,但能实现多个接口 </li>
<li>抽象类可以有构造方法,接口没有构造方法 </li>
<li>抽象类可以有普通成员变量,接口没有普通成员变量 </li>
<li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认) </li>
<li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法 </li>
<li>抽象类可以有静态方法，接口不能有静态方法 （1.8中可以有静态方法，但是必须实现）</li>
<li>抽象类中的方法可以是public、protected;接口方法只有public abstract</li>
</ol>
<h2 id="重载的一些问题"><a href="#重载的一些问题" class="headerlink" title="重载的一些问题"></a>重载的一些问题</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        b(<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>);  <span class="hljs-comment">//A行</span>
        a(<span class="hljs-keyword">null</span>);  <span class="hljs-comment">//B行</span>
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(Object a)</span> </span>&#123;

    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(String a)</span> </span>&#123;

    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">(Integer ab,String a)</span> </span>&#123;

    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">(Integer ab,String... a)</span> </span>&#123;

    &#125;
&#125;</code></pre>

<p>其中A行报错，因为找到了两个方法。<br>B行调用的是a(String a)方法，也就代表优先选择子类。</p>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try_catch_finally"></a>try_catch_finally</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinallyTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(test());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            System.out.println(<span class="hljs-string">&quot;catch&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
        &#125;
    &#125;
&#125;
运行打印
<span class="hljs-keyword">catch</span>
<span class="hljs-keyword">finally</span>
<span class="hljs-number">3</span></code></pre>

<p>finally不管有没有异常都要处理当try和catch中有return时，finally仍然会执行，finally比return先执行不管有木有异常抛出, finally在return返回前执行finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在finally执行前确定的</p>
<p>注意: finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值 finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ISP中的网络层</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ISP%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B1%82.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h2 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905191849.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905191849.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<ul>
<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<h2 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905192157.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905192157.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905192755.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905192755.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p><strong>192.168.10.32/28</strong><br>前面的数字是我们的网络地址，后面的28表示用28位来表示网络位，用32-28=4位来表示主机位。通过这种记法，我们能明确两个信息：<br>网络地址：192.168.10.32<br>子网掩码：255.255.255.240</p>
<p>所以，/8-/15只能用于A类网络，/16-/23可用于A类和B类网络，而/24-/30可用于A类、B类和C类网络。这就是大多数公司都使用A类网络地址的一大原因，因为它们可使用所有的子网掩码，进行网络设计时的灵活性最大。</p>
<h4 id="子网划分常见问题"><a href="#子网划分常见问题" class="headerlink" title="子网划分常见问题"></a>子网划分常见问题</h4><ol>
<li>选定的子网掩码将创建多少个子网?</li>
</ol>
<p>2^x个，其中x是子网掩码借用的主机位数，比如/28，主机位数为4.</p>
<p>比如/28，即为255.255.255.240 ，256 -192 = 64，所以子网的步长增量为64，因此子网为0、64、128和192；</p>
<ol start="2">
<li>每个子网可包含多少台主机?</li>
</ol>
<p>(2^y)-2台，其中y是没被借用的主机位的位数。-2是因为，主机位全为0的部分是这个子网的网段号（Net_id），全为1的部分是这个网段的广播地址。</p>
<ol start="3">
<li>每个子网的广播地址是什么?</li>
</ol>
<p>主机位全为1就是该子网的广播地址。</p>
<ol start="4">
<li>每个子网可包含哪些主机地址?</li>
</ol>
<p>合法的主机地址位于两个子网之间，但全为0和全为1的地址除外。例如，如果子网号（网段号）为64，而广播地址为127，则合法的主机地址范围为65-126，即子网地址和广播地址之间的数字。</p>
<h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。ARP 实现由 IP 地址得到 MAC 地址。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905200952.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905200952.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905201057.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905201057.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905201554.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905201554.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>ICMP 报文分为差错报告报文和询问报文。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905201623.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905201623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h3><ol>
<li><p>Ping<br>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
</li>
<li><p>Traceroute<br> Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p> Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ISP</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈DNS协议</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88DNS%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住IP。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<h2 id="DNS查找过程"><a href="#DNS查找过程" class="headerlink" title="DNS查找过程"></a>DNS查找过程</h2><ol>
<li>浏览器访问 <a href="http://www.baidu.com">www.baidu.com</a></li>
<li>查找浏览器缓存</li>
<li>查找dns解析器缓存host</li>
<li>查找本地dns服务器缓存</li>
<li>查找根dns服务器缓存，找到了返回对应后缀的dns服务器地址ip（比如com DNS服务器）</li>
<li>查找com dns服务器，返回baidu.com的dns服务器ip</li>
<li>查找baidu.com dns服务器ip</li>
<li>得到baidu.com服务器ip，写入缓存。</li>
<li>浏览器拿到ip进行访问。</li>
</ol>
<h2 id="DNS的记录类型"><a href="#DNS的记录类型" class="headerlink" title="DNS的记录类型"></a>DNS的记录类型</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905185337.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905185337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>其中CNAME解析就是将域名解析到另一个域名。</p>
<h2 id="DNS劫持与污染"><a href="#DNS劫持与污染" class="headerlink" title="DNS劫持与污染"></a>DNS劫持与污染</h2><h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS决定的是我们的域名将解析到哪一个IP地址的记录，是基于UDP协议的一种应用层协议。这种攻击的前提是攻击者掌控了你的本地DNS服务器</p>
<p>攻击者劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致用户对该域名地址进行访问的时候，由原来的IP地址转入到修改后的IP地址。结果就是让正确的网址不能解析或者是被解析到另一个网址的IP，实现获取用户资料或者破坏原有网址正常服务的目的。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905190458.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200905190458.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>简单来说就是就是ip解析请求发送到了其他DNS服务器了，给你返回了一个错误的ip</p>
<h3 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h3><p>又称域名服务器缓存投毒（DNS cache poisoning），它和DNS劫持的不同之处，在于污染针对的是DNS缓存，是在查询信息到达目标DNS服务器前，经过的节点上做手脚，而劫持是DNS服务器中记录的是错误的内容。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/anyhoo/p/10369589.html">一篇你看了就懂的DNS详解</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>五大I/O模型</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%94%E5%A4%A7I-O%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个输入操作通常包括两个阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I/O 模型：</p>
<p>阻塞式 I/O<br>非阻塞式 I/O<br>I/O 复用（select 和 poll）<br>信号驱动式 I/O（SIGIO）<br>异步 I/O（AIO）</p>
<h2 id="阻塞式-I-O"><a href="#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a>阻塞式 I/O</h2><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002200454.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002200454.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h2><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002200544.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002200544.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="I-O-复用"><a href="#I-O-复用" class="headerlink" title="I/O 复用"></a>I/O 复用</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002200636.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002200636.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p><strong>强调：</strong></p>
<ol>
<li><p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
</li>
<li><p>在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
</li>
</ol>
<p>结论: select的优势在于可以处理多个连接，不适用于单个连接 </p>
<h2 id="信号驱动-I-O"><a href="#信号驱动-I-O" class="headerlink" title="信号驱动 I/O"></a>信号驱动 I/O</h2><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002200837.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002200837.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002201000.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20201002201000.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="五大-I-O-模型比较"><a href="#五大-I-O-模型比较" class="headerlink" title="五大 I/O 模型比较"></a>五大 I/O 模型比较</h2><ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。</li>
<li>异步 I/O：不会阻塞。</li>
</ul>
<p>阻塞式 I/O、非阻塞式 I/O、I/O 复用、信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200829175622.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200829175622.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="同步异步与阻塞与非阻塞"><a href="#同步异步与阻塞与非阻塞" class="headerlink" title="同步异步与阻塞与非阻塞"></a>同步异步与阻塞与非阻塞</h2><h3 id="阻塞IO-和-非阻塞IO"><a href="#阻塞IO-和-非阻塞IO" class="headerlink" title="阻塞IO 和 非阻塞IO"></a>阻塞IO 和 非阻塞IO</h3><p>这两个概念是<strong>程序级别</strong>的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)</p>
<h3 id="同步IO-和-非同步IO"><a href="#同步IO-和-非同步IO" class="headerlink" title="同步IO 和 非同步IO"></a>同步IO 和 非同步IO</h3><p>这两个概念是操作<strong>系统级别</strong>的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何相应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的哨兵</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis%E7%9A%84%E5%93%A8%E5%85%B5.html</url>
    <content><![CDATA[<h2 id="哨兵介绍"><a href="#哨兵介绍" class="headerlink" title="哨兵介绍"></a>哨兵介绍</h2><p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。<br>哨兵用于实现 Redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</li>
</ul>
<p>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。<br>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>转自：<a href="https://doocs.gitee.io/advanced-java/#/docs/high-concurrency/redis-sentinel">Redis 哨兵集群实现高可用</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>哨兵</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的主从架构</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单机的 Redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200822133333.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200822133333.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>Redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<h2 id="Redis-replication-的核心机制"><a href="#Redis-replication-的核心机制" class="headerlink" title="Redis replication 的核心机制"></a>Redis replication 的核心机制</h2><ul>
<li>Redis 采用异步方式复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<h2 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a>Redis 主从复制的核心原理</h2><p>当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200822163418.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200822163418.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h2><p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p>
<p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 resynchronization 。</p>
<blockquote>
<p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</p>
</blockquote>
<h2 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h2><p>master 在内存中直接创建 RDB ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 repl-diskless-sync yes 即可。</p>
<pre><code class="hljs ini">repl-diskless-sync yes

<span class="hljs-comment"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span>
repl-diskless-sync-delay 5</code></pre>

<h2 id="过期-key-处理"><a href="#过期-key-处理" class="headerlink" title="过期 key 处理"></a>过期 key 处理</h2><p>slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p>
<h2 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a>复制的完整流程</h2><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 host 和 ip ，但是复制流程没开始。</p>
<p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 ping 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200822164622.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200822164622.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><ul>
<li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li>
<li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li>
<li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li>
<li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。<pre><code class="hljs ini">client-output-buffer-limit slave 256MB 64MB 60</code></pre></li>
<li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时基于旧的数据版本对外提供服务。</li>
<li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</li>
</ul>
<h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><ul>
<li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li>
<li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</li>
<li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li>
</ul>
<h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>主从节点互相都会发送 heartbeat 信息。</p>
<p>master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat。</p>
<h2 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h2><p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p>
<p>转自：<a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/redis-master-slave">Redis 主从架构</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的数据类型详解</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。</p>
<pre><code class="hljs redis">set key sth</code></pre>

<h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>Redis中为了实现方便的扩展、安全和性能，自己定义了一个结构用来存储字符串。<br>我们叫它SDS（simple dynamic string）</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821162635.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821162635.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821162925.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821162925.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>推荐阅读 <a href="https://blog.csdn.net/dazhu233/article/details/80072471">Redis底层之String</a></p>
<h2 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段。</p>
<pre><code class="hljs redis">hset person name bingo
hset person age 20
hset person id 1
hget person name

person &#x3D; &#123;
    &quot;name&quot;: &quot;bingo&quot;,
    &quot;age&quot;: 20,
    &quot;id&quot;: 1
&#125;</code></pre>
<h3 id="底层-1"><a href="#底层-1" class="headerlink" title="底层"></a>底层</h3><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span>
    dictEntry **table;             <span class="hljs-comment">// 哈希表数组</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;            <span class="hljs-comment">// 哈希表数组的大小</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;        <span class="hljs-comment">// 用于映射位置的掩码，值永远等于(size-1)</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;            <span class="hljs-comment">// 哈希表已有节点的数量</span>
&#125; dictht;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span>
    <span class="hljs-keyword">void</span> *key;                  <span class="hljs-comment">// 键</span>
    <span class="hljs-keyword">union</span> &#123;                     <span class="hljs-comment">// 值</span>
        <span class="hljs-keyword">void</span> *val;
        <span class="hljs-keyword">uint64_t</span> u64;
        <span class="hljs-keyword">int64_t</span> s64;
        <span class="hljs-keyword">double</span> d;
    &#125; v;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">// 指向下一个哈希表节点，形成单向链表</span>
&#125; dictEntry;</code></pre>

<p>总体结构图</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821164048.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821164048.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>是不是很眼熟，就是Java的HashMap一样的，使用的拉链法解决冲突。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>hash类型是一个dict，一个dict有两张hash表，其中一张表是用来做rehash的</p>
<p>与Java的HashMap不同的是:</p>
<ul>
<li>Redis的字典只能是字符串，</li>
<li>rehash的方式不一样：Java是一次性rehash全部；Redis为了追求高性能，不能堵塞服务，所以采用了渐进式rehash策略。</li>
</ul>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>Lists 是有序列表，这个可以玩儿出很多花样。</p>
<p>比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</p>
<p>比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 list 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p>
<pre><code class="hljs redis"># 0开始位置，-1结束位置，结束位置为-1时，表示列表的最后一个位置，即查看所有。
lrange mylist 0 -1

#比如可以搞个简单的消息队列，从 list 头怼进去，从 list 尾巴那里弄出来。
lpush mylist 1
lpush mylist 2
lpush mylist 3 4 5

# 1
rpop mylist</code></pre>

<h3 id="底层-2"><a href="#底层-2" class="headerlink" title="底层"></a>底层</h3><h4 id="3-2版本之前"><a href="#3-2版本之前" class="headerlink" title="3.2版本之前"></a>3.2版本之前</h4><p>3.2版本之前的 使用压缩列表（zipList）和双向链表（linkedlist）</p>
<p>初始为zipList，当链表entry数据超过512、或单个value 长度超过64，底层就会转化成linkedlist编码</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821175826.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821175826.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>优缺点：</p>
<p>双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。<br>ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。</p>
<h4 id="3-2版本之后"><a href="#3-2版本之后" class="headerlink" title="3.2版本之后"></a>3.2版本之后</h4><p>使用quickList实现。可以认为quickList，是ziplist和linkedlist二者的结合；quickList将二者的优点结合起来。</p>
<p>quickList是一个ziplist组成的双向链表。每个节点使用ziplist来保存数据。<br>本质上来说，quicklist里面保存着一个一个小的ziplist。结构如下：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821215829.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821215829.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>



<p>推荐阅读 <a href="https://www.jianshu.com/p/d9ac7074f10e">Redis列表list底层原理</a></p>
<h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>Sets 是无序集合，自动去重。</p>
<p>直接基于 set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 Redis 进行全局的 set 去重。</p>
<p>可以基于 set 玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧。</p>
<p>把两个大 V 的粉丝都放在两个 set 中，对两个 set 做交集。</p>
<pre><code class="hljs redis">#-------操作一个set-------
# 添加元素
sadd mySet 1
# 查看全部元素
smembers mySet
# 判断是否包含某个值
sismember mySet 3
# 删除某个&#x2F;些元素
srem mySet 1
srem mySet 2 4
# 查看元素个数
scard mySet
# 随机删除一个元素
spop mySet

#-------操作多个set-------
# 将一个set的元素移动到另外一个set
smove yourSet mySet 2
# 求两set的交集
sinter yourSet mySet
# 求两set的并集
sunion yourSet mySet
# 求在yourSet中而不在mySet中的元素
sdiff yourSet mySet
</code></pre>

<h3 id="底层-3"><a href="#底层-3" class="headerlink" title="底层"></a>底层</h3><p>与Java中的HashSet一样，无序且存储元素不重复。其底层有两种实现方式，当value是整数值时，且数据量不大时使用inset来存储，其他情况都是用字典dict来存储。</p>
<pre><code class="hljs c">typedf <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inset</span>&#123;</span>
    <span class="hljs-keyword">uint32_t</span> encoding;<span class="hljs-comment">//编码方式 有三种 默认 INSET_ENC_INT16</span>
    <span class="hljs-keyword">uint32_t</span> length;<span class="hljs-comment">//集合元素个数</span>
    <span class="hljs-keyword">int8_t</span> contents[];<span class="hljs-comment">//实际存储元素的数组 </span>
                      <span class="hljs-comment">//元素类型并不一定是ini8_t类型，柔性数组不占intset结构体大小，并且数组中的元</span>
                      <span class="hljs-comment">//素从小到大排列</span>
&#125;inset;
<span class="hljs-comment">//16位，2个字节，表示范围-32,768~32,767</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))  </span>
<span class="hljs-comment">//32位，4个字节，表示范围-2,147,483,648~2,147,483,647</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))   </span>
<span class="hljs-comment">//64位，8个字节，表示范围-9,223,372,036,854,775,808~9,223,372,036,854,775,807</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))   </span></code></pre>

<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821221025.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821221025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<p>推荐阅读：<a href="https://www.cnblogs.com/reecelin/p/13364089.html">Redis底层数据结构之set</a></p>
<h2 id="Sorted-Sets"><a href="#Sorted-Sets" class="headerlink" title="Sorted Sets"></a>Sorted Sets</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>Sorted Sets 是排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。</p>
<pre><code class="hljs redis">zadd board 85 zhangsan
zadd board 72 lisi
zadd board 96 wangwu
zadd board 63 zhaoliu

# 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）
zrevrange board 0 3

# 获取某用户的排名
zrank board zhaoliu</code></pre>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>sortedset同时会由两种数据结构支持,ziplist和skiplist.</p>
<p>只有同时满足如下条件是,使用的是ziplist,其他时候则是使用skiplist</p>
<ul>
<li>有序集合保存的元素数量小于128个</li>
<li>有序集合保存的所有元素的长度小于64字节</li>
</ul>
<p>当ziplist作为存储结构时候,每个集合元素使用两个紧挨在一起的压缩列表结点来保存,第一个节点保存元素的成员,第二个元素保存元素的分值.</p>
<p>当使用skiplist作为存储结构时,使用skiplist按序保存元素分值,使用dict来保存元素和分值的对应关系</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821223145.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200821223145.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Redis的一些面试题</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%85%B3%E4%BA%8ERedis%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ol>
<li>纯内存操作。</li>
<li>核心是基于非阻塞的 IO 多路复用机制。</li>
<li>C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。</li>
<li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MySQL的一些面试题</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%85%B3%E4%BA%8EMySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="为什么说B-树比B树更合适做索引？"><a href="#为什么说B-树比B树更合适做索引？" class="headerlink" title="为什么说B+树比B树更合适做索引？"></a>为什么说B+树比B树更合适做索引？</h3><ol>
<li>单一结点存储更多的关键字，使得查询的IO次数减少；</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于区间查询以及全结点遍历更快。</li>
<li>支持范围查询</li>
</ol>
<h3 id="什么是索引覆盖？"><a href="#什么是索引覆盖？" class="headerlink" title="什么是索引覆盖？"></a>什么是索引覆盖？</h3><p>索引覆盖就是查询的字段都是索引字段。</p>
<p>实现索引覆盖：将被查询的字段，建立到联合索引里去。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="数据库事务隔离级别及实现？"><a href="#数据库事务隔离级别及实现？" class="headerlink" title="数据库事务隔离级别及实现？"></a>数据库事务隔离级别及实现？</h3><p>隔离级别：读未提交，读已提交，可重复读，串行化。</p>
<p>实现：</p>
<ul>
<li>读未提交：不加锁的方式。</li>
<li>读已提交：只加记录锁，不加 gap locks 。</li>
<li>可重复度：对于唯一索引，只加记录锁。对于其他搜索，gap locks 或者 next-key locks</li>
<li>串行化：InnoDB 默默的把所有纯 SELECT 语句都转成了 SELECT … FOR SHARE </li>
</ul>
<p>参考<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">Transaction Isolation Levels</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-责任链</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p>JDK中的责链接：</p>
<ul>
<li>java.util.logging.Logger#log()</li>
<li>Apache Commons Chain</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
<h2 id="优缺点及应用场景"><a href="#优缺点及应用场景" class="headerlink" title="优缺点及应用场景"></a>优缺点及应用场景</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>降低耦合度。它将请求的发送者和接收者解耦。</li>
<li>简化了对象。使得对象不需要知道链的结构。 </li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 </li>
<li>增加新的请求处理类很方便。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>不能保证请求一定被接收。 </li>
<li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 </li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ol>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol>
<li>JS 中的事件冒泡。 </li>
<li>AVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;
    <span class="hljs-keyword">protected</span> Handler successor;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Handler successor)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.successor = successor;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(Request request)</span></span>;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteHandler1</span><span class="hljs-params">(Handler successor)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(successor);
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(Request request)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (request.getType() == RequestType.TYPE1) &#123;
            System.out.println(request.getName() + <span class="hljs-string">&quot; is handle by ConcreteHandler1&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (successor != <span class="hljs-keyword">null</span>) &#123;
            successor.handleRequest(request);
        &#125;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteHandler2</span><span class="hljs-params">(Handler successor)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(successor);
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(Request request)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (request.getType() == RequestType.TYPE2) &#123;
            System.out.println(request.getName() + <span class="hljs-string">&quot; is handle by ConcreteHandler2&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (successor != <span class="hljs-keyword">null</span>) &#123;
            successor.handleRequest(request);
        &#125;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;

    <span class="hljs-keyword">private</span> RequestType type;
    <span class="hljs-keyword">private</span> String name;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Request</span><span class="hljs-params">(RequestType type, String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.type = type;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> RequestType <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> type;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RequestType</span> </span>&#123;
    TYPE1, TYPE2
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        Handler handler1 = <span class="hljs-keyword">new</span> ConcreteHandler1(<span class="hljs-keyword">null</span>);
        Handler handler2 = <span class="hljs-keyword">new</span> ConcreteHandler2(handler1);

        Request request1 = <span class="hljs-keyword">new</span> Request(RequestType.TYPE1, <span class="hljs-string">&quot;request1&quot;</span>);
        handler2.handleRequest(request1);

        Request request2 = <span class="hljs-keyword">new</span> Request(RequestType.TYPE2, <span class="hljs-string">&quot;request2&quot;</span>);
        handler2.handleRequest(request2);
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>责任链</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL死锁的调试</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%AD%BB%E9%94%81%E7%9A%84%E8%B0%83%E8%AF%95.html</url>
    <content><![CDATA[<h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>死锁是指由于每个事务都持有对方需要的锁而无法进行其他事务的情况。因为这两个事务都在等待资源变得可用，所以两个都不会释放它持有的锁。</p>
<p>数据库死锁，是最难调试与追踪的。所以本文记录一些死锁调试的思路。</p>
<h2 id="死锁例子"><a href="#死锁例子" class="headerlink" title="死锁例子"></a>死锁例子</h2><p>以下示例说明了锁定请求将导致死锁时如何发生错误。该示例涉及两个事务A和B。</p>
<p>首先，创建一个包含一行的表，然后开始事务A。在事务中，A事务中对i=1的行加上S锁：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t (i <span class="hljs-built_in">INT</span>) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t (i) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment">#A事务</span>
<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> i = <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SHARE</span>;</code></pre>

<p>B事务删除 i=1 的行，删除操作需要一个X锁。无法授予该行的S锁，因为它与事务A持有的锁不兼容 ，因此事务B阻塞</p>
<pre><code class="hljs sql"><span class="hljs-comment">#B事务</span>
<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> i = <span class="hljs-number">1</span>;</code></pre>

<p>最后，事务A还尝试从表中删除该行：</p>
<pre><code class="hljs sql"><span class="hljs-comment">#A事务</span>
 <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> i = <span class="hljs-number">1</span>;</code></pre>

<p>此处发生死锁，因为事务A需要 X锁才能删除该行。但是事务B已经有一个X锁定请求，并且正在等待客户端A释放其S锁定。所以进入了互相等待的死锁结果， InnoDB为其中一个客户端生成错误并释放其锁。客户端返回此错误：</p>
<pre><code class="hljs sql">ERROR 1213 (40001): Deadlock found when trying to get <span class="hljs-keyword">lock</span>;
try restarting transaction</code></pre>

<p>因为MySQL的死锁检查机制，自动回滚影响最小的事务（事务中插入、更新或删除的行数确定），解除死锁。</p>
<h2 id="死锁检测机制"><a href="#死锁检测机制" class="headerlink" title="死锁检测机制"></a>死锁检测机制</h2><p> InnoDB自动检测事务的死锁和回退事务解决死锁问题。 InnoDB尝试选择要回滚的小事务，其中事务的大小由插入，更新或删除的行数确定。</p>
<pre><code class="hljs sql"><span class="hljs-comment">#查看事务阻塞时间</span>
<span class="hljs-keyword">show</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_lock_wait_timeout&#x27;</span>
<span class="hljs-comment">#设置等待锁时间</span>
<span class="hljs-keyword">SET</span> innodb_lock_wait_timeout= some_number
<span class="hljs-comment">#查看死锁是否自动回滚</span>
<span class="hljs-keyword">show</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_deadlock_detect&#x27;</span>
<span class="hljs-comment"># 启动关闭死锁检测</span>
<span class="hljs-keyword">SET</span> innodb_deadlock_detect=<span class="hljs-number">0</span>/<span class="hljs-number">1</span></code></pre>

<h2 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h2><h3 id="查找死锁"><a href="#查找死锁" class="headerlink" title="查找死锁"></a>查找死锁</h3><ol>
<li>最近一次死锁<br>在任何时候，发出以下命令以确定最近死锁的原因。然后调整代码以避免死锁。</li>
</ol>
<pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">ENGINE</span> <span class="hljs-keyword">INNODB</span> <span class="hljs-keyword">STATUS</span></code></pre>

<ol start="2">
<li>所有死锁<br>通过启用innodb_print_all_deadlocks 配置选项来收集更广泛的调试信息 。有关每个死锁的信息，而不仅仅是最新的死锁，都记录在MySQL 错误日志中。完成调试后，请应该禁用此选项。</li>
</ol>
<pre><code class="hljs sql"><span class="hljs-comment">#查询是否启用所有死锁信息保存到日志</span>
<span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_print_all_deadlocks&#x27;</span>;
<span class="hljs-keyword">set</span> innodb_print_all_deadlocks=<span class="hljs-number">0</span>/<span class="hljs-number">1</span>;</code></pre>
<h3 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h3><p>比如上面那个死锁例子，通过<code>SHOW ENGINE INNODB STATUS</code>命令拿到最近的死锁信息得到以下结果。</p>
<pre><code class="hljs sql"><span class="hljs-comment">------------------------</span>
LATEST DETECTED DEADLOCK
<span class="hljs-comment">------------------------</span>
2020-08-19 18:46:57 0x1ee0
*** (1) TRANSACTION:
TRANSACTION 87305, ACTIVE 3 sec starting index read
mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">locked</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">WAIT</span> <span class="hljs-number">2</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">struct</span>(s), <span class="hljs-keyword">heap</span> <span class="hljs-keyword">size</span> <span class="hljs-number">1136</span>, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">lock</span>(s)
MySQL <span class="hljs-keyword">thread</span> <span class="hljs-keyword">id</span> <span class="hljs-number">9</span>, OS <span class="hljs-keyword">thread</span> handle <span class="hljs-number">15096</span>, <span class="hljs-keyword">query</span> <span class="hljs-keyword">id</span> <span class="hljs-number">154</span> localhost ::<span class="hljs-number">1</span> root updating
<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> i = <span class="hljs-number">1</span>

*** (<span class="hljs-number">1</span>) HOLDS THE <span class="hljs-keyword">LOCK</span>(S):
<span class="hljs-built_in">RECORD</span> LOCKS <span class="hljs-keyword">space</span> <span class="hljs-keyword">id</span> <span class="hljs-number">163</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> GEN_CLUST_INDEX <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`area_data`</span>.<span class="hljs-string">`t`</span> trx <span class="hljs-keyword">id</span> <span class="hljs-number">87305</span> lock_mode X waiting
<span class="hljs-built_in">Record</span> <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">4</span>; compact format; info bits 0
 0: len 6; hex 000000000200; asc       ;;
 1: len 6; hex 000000015348; asc     SH;;
 2: len 7; hex 820000008b0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;


*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 163 page no 4 n bits 72 index GEN_CLUST_INDEX of table `area_data`.`t` trx id 87305 lock_mode X waiting
Record <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">4</span>; compact format; info bits 0
 0: len 6; hex 000000000200; asc       ;;
 1: len 6; hex 000000015348; asc     SH;;
 2: len 7; hex 820000008b0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;


*** (2) TRANSACTION:
TRANSACTION 87306, ACTIVE 6 sec starting index read
mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">locked</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">WAIT</span> <span class="hljs-number">4</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">struct</span>(s), <span class="hljs-keyword">heap</span> <span class="hljs-keyword">size</span> <span class="hljs-number">1136</span>, <span class="hljs-number">3</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">lock</span>(s)
MySQL <span class="hljs-keyword">thread</span> <span class="hljs-keyword">id</span> <span class="hljs-number">8</span>, OS <span class="hljs-keyword">thread</span> handle <span class="hljs-number">6104</span>, <span class="hljs-keyword">query</span> <span class="hljs-keyword">id</span> <span class="hljs-number">158</span> localhost ::<span class="hljs-number">1</span> root updating
<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> i = <span class="hljs-number">1</span>

*** (<span class="hljs-number">2</span>) HOLDS THE <span class="hljs-keyword">LOCK</span>(S):
<span class="hljs-built_in">RECORD</span> LOCKS <span class="hljs-keyword">space</span> <span class="hljs-keyword">id</span> <span class="hljs-number">163</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> GEN_CLUST_INDEX <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`area_data`</span>.<span class="hljs-string">`t`</span> trx <span class="hljs-keyword">id</span> <span class="hljs-number">87306</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">mode</span> S
<span class="hljs-built_in">Record</span> <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">1</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">1</span>; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">4</span>; compact format; info bits 0
 0: len 6; hex 000000000200; asc       ;;
 1: len 6; hex 000000015348; asc     SH;;
 2: len 7; hex 820000008b0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;


*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 163 page no 4 n bits 72 index GEN_CLUST_INDEX of table `area_data`.`t` trx id 87306 lock_mode X waiting
Record <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">4</span>; compact format; info bits 0
 0: len 6; hex 000000000200; asc       ;;
 1: len 6; hex 000000015348; asc     SH;;
 2: len 7; hex 820000008b0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;

*** WE ROLL BACK TRANSACTION (1)</code></pre>

<p>主题流程可以看到，事务2持有S锁，然后事务1请求X锁，然后事务2也去请求X锁，结果失败了执行回滚了</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html">官方文档-Deadlocks in InnoDB</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL调优利器Explain</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E8%B0%83%E4%BC%98%E5%88%A9%E5%99%A8Explain.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Expalin是用于获取SQL语句的执行计划的一个指令，比如是否走的索引，走的哪个索引之类的。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>官方定义语法：</p>
<pre><code class="hljs sql">&#123;EXPLAIN | DESCRIBE | DESC&#125;
    表名 [col_name | wild]

&#123;EXPLAIN | DESCRIBE | DESC&#125;
    [explain_type]
    &#123;explainable_stmt | FOR CONNECTION connection_id&#125;

&#123;EXPLAIN | DESCRIBE | DESC&#125; ANALYZE [FORMAT = TREE] select_statement

explain_type: &#123;
    FORMAT = format_name
&#125;

format_name: &#123;
    TRADITIONAL
  | JSON
  | TREE
&#125;

explainable_stmt: &#123;
    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">statement</span>
  | <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">statement</span>
  | <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">statement</span>
  | <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">statement</span>
  | <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">statement</span>
  | <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">statement</span>
&#125;</code></pre>
<p>可以看出来，explain/desc/describe 三个有同样的功能，MySQL也把他们当作同义词，但是describe通常用来查询表结构，explain通常用来查询SQL执行的计划。</p>
<p>比如</p>
<pre><code class="hljs sql"><span class="hljs-comment"># 表格形式显示结果</span>
<span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> xxxTable;
<span class="hljs-comment"># json格式显示结果</span>
<span class="hljs-keyword">explain</span> <span class="hljs-keyword">FORMAT</span> = <span class="hljs-keyword">JSON</span>  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> xxxTable;
<span class="hljs-comment"># 分析SQL的执行时间与实际耗时</span>
<span class="hljs-keyword">EXPLAIN</span>  <span class="hljs-keyword">ANALYZE</span>  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> xxxTable;</code></pre>

<h2 id="输出格式的解释"><a href="#输出格式的解释" class="headerlink" title="输出格式的解释"></a>输出格式的解释</h2><h3 id="输出列的解释"><a href="#输出列的解释" class="headerlink" title="输出列的解释"></a>输出列的解释</h3><table>
<thead>
<tr>
<th>行</th>
<th>JSON Name</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select_id</td>
<td>该SELECT标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>None</td>
<td>该SELECT类型</td>
</tr>
<tr>
<td>table</td>
<td>table_name</td>
<td>操作的表</td>
</tr>
<tr>
<td>partitions</td>
<td>partitions</td>
<td>匹配的分区</td>
</tr>
<tr>
<td>type</td>
<td>access_type</td>
<td>联接类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>possible_keys</td>
<td>可能的索引选择</td>
</tr>
<tr>
<td>key</td>
<td>key</td>
<td>实际选择的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>key_length</td>
<td>所选键的长度</td>
</tr>
<tr>
<td>ref</td>
<td>ref</td>
<td>与索引比较的列</td>
</tr>
<tr>
<td>rows</td>
<td>rows</td>
<td>估计要检查的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>filtered</td>
<td>按表条件过滤的行百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>None</td>
<td>附加信息</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：如果Format格式为JSON，那么不会显示为NULL的行</p>
</blockquote>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><table>
<thead>
<tr>
<th>select_type</th>
<th>JSON名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>simple</td>
<td>没有</td>
<td>简单select（不使用 union或子查询）</td>
</tr>
<tr>
<td>primary</td>
<td>没有</td>
<td>最外层 select</td>
</tr>
<tr>
<td>union</td>
<td>没有</td>
<td>第二个或之后的select陈述 union</td>
</tr>
<tr>
<td>dependent</td>
<td>union</td>
<td>dependent（true）</td>
</tr>
<tr>
<td>union RESULT</td>
<td>union_result</td>
<td>的结果union。</td>
</tr>
<tr>
<td>subquery</td>
<td>没有</td>
<td>首先select在子查询</td>
</tr>
<tr>
<td>dependent subquery</td>
<td>dependent（true）</td>
<td>首先select在子查询中，取决于外部查询</td>
</tr>
<tr>
<td>derived</td>
<td>没有</td>
<td>派生表</td>
</tr>
<tr>
<td>dependent</td>
<td>derived    dependent（true）</td>
<td>派生表依赖于另一个表</td>
</tr>
<tr>
<td>materialized</td>
<td>materialized_from_subquery</td>
<td>物化子查询</td>
</tr>
<tr>
<td>uncacheable subquery</td>
<td>cacheable（false）</td>
<td>子查询，其结果无法缓存，必须针对外部查询的每一行重新进行评估</td>
</tr>
<tr>
<td>uncacheable union</td>
<td>cacheable（false）</td>
<td>union 属于不可缓存子查询的中的第二个或更高版本的选择（请参阅uncacheable subquery</td>
</tr>
</tbody></table>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><ol>
<li><strong>system</strong>：该表只有一行（=系统表）。这是const联接类型的特例 。</li>
<li><strong>const</strong>：该表最多具有一个匹配行，该行在查询开始时读取。因为只有一行，所以优化器的其余部分可以将这一行中列的值视为常量。 const表非常快，因为它们只能读取一次。比如我们通过唯一索引等值查询的时候就是const</li>
<li><strong>eq_ref</strong>：唯一索引单值扫描；</li>
<li><strong>ref</strong>：非唯一索引单值扫描；</li>
<li><strong>fulltext</strong>：使用FULLTEXT 索引执行联接。</li>
<li><strong>ref_or_null</strong>：这种连接类型类似于 ref，但是MySQL会额外搜索包含NULL值的行。此联接类型优化最常用于解析子查询。</li>
<li><strong>index_merge</strong>：此联接类型指示使用索引合并优化。在这种情况下，key输出行中的列包含使用的索引列表，并key_len包含使用的索引 的最长键部分的列表。</li>
<li><strong>unique_subquery</strong>：只是一个索引查找函数，它完全替代了子查询以提高效率，此类型替换以下形式的eq_ref某些IN子查询：<pre><code class="hljs sql">value IN (<span class="hljs-keyword">SELECT</span> primary_key <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> some_expr)</code></pre></li>
<li><strong>index_subquery</strong>：此连接类型类似于 unique_subquery。它替代IN子查询，但适用于以下形式的子查询中的非唯一索引：<pre><code class="hljs sql">value IN (<span class="hljs-keyword">SELECT</span> key_column  <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> some_expr)</code></pre></li>
<li><strong>range</strong>：命中where子句的范围索引扫描；</li>
<li><strong>index</strong>：走索引的全表扫描，当查询仅使用属于单个索引一部分的列时，MySQL可以使用此联接类型。两种方式：<ul>
<li>如果索引是查询的覆盖索引，并且可用于满足表中所需的所有数据，则仅扫描索引树。在这种情况下，Extra列显示为 Using index。仅索引扫描通常比索引扫描更快， ALL因为索引的大小通常小于表数据。</li>
<li>使用对索引的读取执行全表扫描，以按索引顺序查找数据行。 Uses index没有出现在 Extra列中。</li>
</ul>
</li>
<li><strong>all</strong>：全表扫描</li>
</ol>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>可能在哪个索引找到记录。</p>
<p>要查看表具有哪些索引，请使用。 </p>
<pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> table_name</code></pre>

<p>要强制MySQL使用或忽略列出的索引possible_keys列，使用 FORCE INDEX，USE INDEX或IGNORE INDEX在查询里。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">USE</span> <span class="hljs-keyword">INDEX</span> (col1_index,col2_index) <span class="hljs-keyword">WHERE</span> col1=<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> col2=<span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> col3=<span class="hljs-number">3</span>;

<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">IGNORE</span> <span class="hljs-keyword">INDEX</span> (col3_index) <span class="hljs-keyword">WHERE</span> col1=<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> col2=<span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> col3=<span class="hljs-number">3</span>;</code></pre>

<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>该key列指示MySQL实际决定使用的键（索引）。如果MySQL决定使用possible_keys 索引之一来查找行，则将该索引列为键值。</p>
<p>key中的值不一定会出现在possible_keys中，这个情况出现在查询的所有列都是其他索引的列。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span>;</code></pre>
<p>比如这个情况下，即使没有使用索引当作查询条件，也会走索引。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">官方文档 - EXPLAIN Statement</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Class类字节码详解</title>
    <url>/Java/Jvm/Class%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为什么jvm不能直接运行java代码呢，这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的，所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。</p>
<ul>
<li>Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li>
<li>Jvm也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</li>
</ul>
<h2 id="Java字节码文件"><a href="#Java字节码文件" class="headerlink" title="Java字节码文件"></a>Java字节码文件</h2><p>class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。 </p>
<p>class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。这里暂不详细的讲。 </p>
<p>本文将通过简单的java例子编译后的文件来理解。</p>
<h2 id="Class文件的结构属性"><a href="#Class文件的结构属性" class="headerlink" title="Class文件的结构属性"></a>Class文件的结构属性</h2><p>在理解之前先从整体看下java字节码文件包含了哪些类型的数据：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20201007224735.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20201007224735.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="反编译一个Demo"><a href="#反编译一个Demo" class="headerlink" title="反编译一个Demo"></a>反编译一个Demo</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> m + <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<p>用WinHex查看Main.class 16进制文件</p>
<pre><code class="hljs plain">cafe babe 0000 0034 0013 0a00 0400 0f09
0003 0010 0700 1107 0012 0100 016d 0100
0149 0100 063c 696e 6974 3e01 0003 2829
5601 0004 436f 6465 0100 0f4c 696e 654e
756d 6265 7254 6162 6c65 0100 0369 6e63
0100 0328 2949 0100 0a53 6f75 7263 6546
696c 6501 0009 4d61 696e 2e6a 6176 610c
0007 0008 0c00 0500 0601 0010 636f 6d2f
7268 7974 686d 372f 4d61 696e 0100 106a
6176 612f 6c61 6e67 2f4f 626a 6563 7400
2100 0300 0400 0000 0100 0200 0500 0600
0000 0200 0100 0700 0800 0100 0900 0000
1d00 0100 0100 0000 052a b700 01b1 0000
0001 000a 0000 0006 0001 0000 0003 0001
000b 000c 0001 0009 0000 001f 0002 0001
0000 0007 2ab4 0002 0460 ac00 0000 0100
0a00 0000 0600 0100 0000 0800 0100 0d00
0000 0200 0e</code></pre>

<ul>
<li>文件开头的4个字节(“cafe babe”)称之为 魔数，唯有以”cafe babe”开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。 </li>
<li>0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis中的跳越表</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%B6%8A%E8%A1%A8.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h3 id="什么是跳跃表"><a href="#什么是跳跃表" class="headerlink" title="什么是跳跃表"></a>什么是跳跃表</h3><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816211323.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816211323.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816211339.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816211339.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为 7 的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。我们下降到链表层继续遍历就找到了8这个节点。原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。</p>
<p>从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍的结点个数减少了，也就是说查找效率提高了，同理再加一级索引。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816211550.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816211550.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>这次次数更少了，只需要3次即可查找到数字8，可以看出来，增加更多的索引可以增加查找速度。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816211741.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816211741.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>上面就是跳跃表了。</p>
<h3 id="时间复杂度O-logn"><a href="#时间复杂度O-logn" class="headerlink" title="时间复杂度O(logn)"></a>时间复杂度O(logn)</h3><p>有n个结点的链表，假设每两个链表构建一个索引，那么：<br>第一级索引个数为：n/2；<br>第二级索引个数为：n/4；<br>···<br>第h级索引个数为：n/2^h；<br>现在假设最后一级索引的个数为2 ，则h +1 = logn，算上最底下的一层链表，那么这个跳表的高度H= logn。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816212630.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816212630.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>在图里，我们想查找x，在第k级，遍历到y结点，发现x大于y，但x小于y后面的结点z，所以先顺着y往下到第k-1级，发现y，z之间有三个节点，所以我们在k-1级索引中，遍历3个节点找到x，以此类推，在每一层需要通过3个节点找目标数，那么总的时间复杂度就为O(3<em>logn)，因为3是常数，所以最后的时间复杂度为*</em>O(logn)**。<br>这一结构相当于让跳表实现了二分查找，只是建立这么多的索引是否会浪费空间呢？我们来看一下跳表的空间复杂度。</p>
<h3 id="跳表的空间复杂度O-n"><a href="#跳表的空间复杂度O-n" class="headerlink" title="跳表的空间复杂度O(n)"></a>跳表的空间复杂度O(n)</h3><p>还是回到刚刚的例子，我们可以发现，链表上的索引数目按第一层，第二层，···，倒数第二层，最后一层的顺序排列下来分别为：n/2，n/4，···，4，2，观察到了吗？就是一个等比数列，计算该跳表的空间复杂度，相当于给等比数列求和，等比数列求和公式：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816213348.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816213348.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>顺着公式依次带入：a1=n/2，an= 2，q=1/2，求得Sn= n-2，所以空间复杂度为O(n)，与此同时，我们顺便考虑一下每三个节点抽取一个索引的情况，还是依据刚刚的思路，发现Sn= n-1/2，空间复杂度将近缩减了一半。<br>总之，跳表就是空间换时间的那个思路，但如果链表中存储的对象很大时，其实索引占用的这些空间对整个来说是可以忽略不计的。</p>
<h3 id="跳表的高效插入和删除"><a href="#跳表的高效插入和删除" class="headerlink" title="跳表的高效插入和删除"></a>跳表的高效插入和删除</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>单链表在知道删除的节点是谁时，时间复杂度为O(1)，因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除的节点要分两种情况：</p>
<ul>
<li>删除的节点还在索引中，那删除时不仅要删除单链表中的节点，还要删除索引中的节点；</li>
<li>删除的节点只在链表中，不在索引中，那只需要删除链表中的节点即可。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>时间换空间</li>
<li>基于单链表加索引方式提升查找性能</li>
</ul>
<h2 id="Redis中的跳跃表"><a href="#Redis中的跳跃表" class="headerlink" title="Redis中的跳跃表"></a>Redis中的跳跃表</h2><p>Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的元素数量比较多,又或者有序集合中元素的成员是比较长的字符串时, Redis就会使用跳跃表来作为有序集合健的底层实现。</p>
<p>这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？</p>
<p>从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。</p>
<h3 id="Redis中跳跃表的实现"><a href="#Redis中跳跃表的实现" class="headerlink" title="Redis中跳跃表的实现"></a>Redis中跳跃表的实现</h3><p> Redis的跳跃表由zskiplistNode和skiplist两个结构定义,其中 zskiplistNode结构用于表示跳跃表节点,而 zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816214531.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816214531.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="skiplist结构"><a href="#skiplist结构" class="headerlink" title="skiplist结构"></a>skiplist结构</h4><p>图左边第一个就是。</p>
<ul>
<li>header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)</li>
<li>tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)</li>
<li>level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。</li>
<li>length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</li>
</ul>
<h4 id="zskiplistNode结构"><a href="#zskiplistNode结构" class="headerlink" title="zskiplistNode结构"></a>zskiplistNode结构</h4><p>图右边四个</p>
<ul>
<li><p>层(level):<br>节点中用L1、L2、L3等字样标记节点的各个层,L1代表第一层,L代表第二层,以此类推。<br>每个层都带有两个属性:前进指针和跨度。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。<br>每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。</p>
</li>
<li><p>后退(backward)指针：<br>节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。</p>
</li>
<li><p>分值(score):<br>各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。</p>
</li>
<li><p>成员对象(oj):<br>各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p>
</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816215336.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200816215336.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/> 

<h2 id="与红黑树对比"><a href="#与红黑树对比" class="headerlink" title="与红黑树对比"></a>与红黑树对比</h2><ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性</li>
<li>更容易实现</li>
<li>支持范围查找</li>
<li>跳表更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跳跃表就是一个单链表存储数据，多个链表当作索引，不断进行2分建立索引，这样有点类似二分查找的样子。效率比较高。</p>
<p>推荐阅读: <a href="https://zhuanlan.zhihu.com/p/53975333">漫画：什么是跳表？</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>跳跃表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型JMM</title>
    <url>/Java/Jvm/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Java内存模型（Java Memery Model）用来屏蔽掉各种硬件和操作系统的内存访问差异。以至于让Java在各中平台下都能达到一致的内存访问效果。</p>
<p>简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障.</p>
<p>从硬件角度来看。因为处理器的运算速度很快，比如做一个递增操作，就需要从内存中拿值，操作后再放回内存。这样的I/O是无法避免的，但这I/O速度和处理器的运算速度就不是一个数量级，所以为了解决这个问题，就对每个处理器加一个高速缓存（Cache）来作为处理器与内存之间的缓冲。把需要使用的数据复制到缓存中，运算完成之后在从缓存同步到内存。这样处理器就不用等待缓慢的内存读写了。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200815215453.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200815215453.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="800"/>

<h2 id="Java内存模型图"><a href="#Java内存模型图" class="headerlink" title="Java内存模型图"></a>Java内存模型图</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200815220528.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200815220528.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="800"/>

<h2 id="主存与工作内存的一些交互指令"><a href="#主存与工作内存的一些交互指令" class="headerlink" title="主存与工作内存的一些交互指令"></a>主存与工作内存的一些交互指令</h2><table>
<thead>
<tr>
<th>操作</th>
<th>作用对象</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>主内存</td>
<td>把一个变量标识为一条线程独占的状态</td>
</tr>
<tr>
<td>unlock</td>
<td>主内存</td>
<td>把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td>
</tr>
<tr>
<td>read</td>
<td>主内存</td>
<td>把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td>
</tr>
<tr>
<td>load</td>
<td>工作内存</td>
<td>把 read 操作从主内存中得到的变量值放入工作内存中</td>
</tr>
<tr>
<td>use</td>
<td>工作内存</td>
<td>把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td>
</tr>
<tr>
<td>assign</td>
<td>工作内存</td>
<td>把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td>
</tr>
<tr>
<td>store</td>
<td>工作内存</td>
<td>把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td>
</tr>
<tr>
<td>write</td>
<td>工作内存</td>
<td>把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td>
</tr>
</tbody></table>
<p>例子：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200918165459.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200918165459.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h2><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。保存了线程可见性与防止指令重排。</p>
<h3 id="一个变量被定义为volatile的特性"><a href="#一个变量被定义为volatile的特性" class="headerlink" title="一个变量被定义为volatile的特性"></a>一个变量被定义为volatile的特性</h3><p>1.保证此变量对所有线程的可见性。但是对变量的操作如果不是原子操作，那么并发情况下不安全。如果<strong>不满足</strong>以下条件就，需要加锁保证并发安全。</p>
<ul>
<li>运算结果并不依赖变量当前值</li>
<li>能够确保只有单一的线程修改变量的值 </li>
<li>变量不需要与其他的状态变量共同参与不变约束 </li>
</ul>
<p>2.禁止指令重排序优化。通过插入内存屏障保证一致性。</p>
<h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p>
<h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p>
<h4 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h4><p>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p>
<h4 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h4><p>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p>
<p>天然的先行发生关系</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>程序次序规则</td>
<td>在一个线程内，代码按照书写的控制流顺序执行</td>
</tr>
<tr>
<td>管程锁定规则</td>
<td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td>
</tr>
<tr>
<td>volatile 变量规则</td>
<td>volatile 变量的写操作先行发生于后面对这个变量的读操作</td>
</tr>
<tr>
<td>线程启动规则</td>
<td>Thread 对象的 start() 方法先行发生于此线程的每一个动作</td>
</tr>
<tr>
<td>线程终止规则</td>
<td>线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td>
</tr>
<tr>
<td>线程中断规则</td>
<td>对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生 (通过 Thread.interrupted() 方法检测)</td>
</tr>
<tr>
<td>对象终结规则</td>
<td>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td>
</tr>
<tr>
<td>传递性</td>
<td>如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>JMM</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据持久化的两种方式</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(AOF)里面(这称为“全持久化模式”)。 </p>
<p>由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，</p>
<ul>
<li>一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），</li>
<li>一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="使用RDB"><a href="#使用RDB" class="headerlink" title="使用RDB"></a>使用RDB</h3><p>1.<strong>自动</strong>RDB快照备份，在配置文件中编辑</p>
<pre><code class="hljs ini"><span class="hljs-comment">#指定保存备份周期下面这个就是 60秒之后至少有10000个key发生改变则执行bgsave进行快照保存</span>
save 60  10000
<span class="hljs-comment">#启用RDB文件压缩</span>
rdbcompression yes
<span class="hljs-comment">#指定文件名称</span>
dbfilename dump.rdb
<span class="hljs-comment">#指定文件存储位置</span>
dir ./</code></pre>

<p>2.<strong>手动</strong>保存快照</p>
<pre><code class="hljs ini"><span class="hljs-comment">#异步保存数据</span>
bgsave
<span class="hljs-comment">#同步保存数据，不常用，多用于redis收到shutdown、term命令后执行这个指令保存后进行快照备份,然后关闭服务器</span>
save</code></pre>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>RDB就是一个二进制的单文件，非常适合备份，比如24小时保存一次RDB文件，这样如果想回滚到某天的数据也是很轻松。</li>
<li>与AOF相比，RDB允许大型数据集更快地重启。</li>
<li>RDB最大限度地提高了Redis的性能，因为Redis父进程为了持久化所需要做的唯一工作就是fork一个子进程，后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>可能会丢失数据，如果保存时间间隔设置的比较长，如果出现服务崩溃，那么最近的数据还没有保存快照则丢失了。</li>
<li>如果数据量很大，并且CPU性能不佳，那fork出一个子进程可能会很耗时，则可能导致父进程暂停几毫米甚至一秒钟。</li>
</ol>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>简单来说，AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。因此，Redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。</p>
<h3 id="使用AOF"><a href="#使用AOF" class="headerlink" title="使用AOF"></a>使用AOF</h3><p>配置文件中编辑</p>
<pre><code class="hljs ini"><span class="hljs-comment">#启用AOF</span>
appendonly yes
<span class="hljs-comment">#设置文件名称，文件夹同RDB的一样，也是dir指定</span>
appendfilename appendonly.aof
<span class="hljs-comment">#执行同步到文件的三种频率，如果不知道就使用erverysec</span>
<span class="hljs-comment"># appendfsync always</span>
appendfsync everysec
<span class="hljs-comment"># appendfsync no</span>
<span class="hljs-comment">#当AOF文件的体积大于64MB，并且AOF文件的体积比上一次重写之后的体积大了至少一倍（100%）的时候，Redis将执行bgrewriteaof命令。</span>
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb</code></pre>
<p>注意：</p>
<ul>
<li>如果使用了 appendfsync always，那么每次执行指令都会写入文件，这样可能照成大量的磁盘IO。</li>
<li>如果使用了appendfsync no，那么Redis将不对AOF文件执行任何显式的同步操作，而是由操作系统来决定应该在何时对AOF文件进行同步。这个选项在一般情况下不会对Redis的性能带来影响，但系统崩溃将导致使用这种选项的Redis服务器丢失不定数量的数据。另外，如果用户的硬盘处理写入操作的速度不够快的话，那么当缓冲区被等待写入硬盘的数据填满时，Redis的写入操作将被阻塞，并导致Redis处理命令请求的速度变慢。因为这个原因，一般来说并不推荐使用。</li>
</ul>
<p>手动重写AOF，会删除冗余命令，减少文件大小。</p>
<pre><code class="hljs ini">bgrewriteaof</code></pre>

<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>服务崩溃时候数据丢失比较小，只丢失1秒钟。</li>
<li>AOF日志是仅追加的日志，因此，如果断电，则不会出现寻道或损坏问题。即使由于某种原因（磁盘已满或其他原因）以半写命令结束日志，redis-check-aof工具也可以轻松修复它。</li>
<li>AOF以易于理解和解析的格式包含所有操作的日志。您甚至可以轻松导出AOF文件。</li>
<li>误删恢复，比如执行了flushall命令则可以用这个aof文件恢复</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>文件体积比RDB大。也会导致数据还原时间会很长。</li>
<li>因为AOF重写也会fork子进程，那么耗时问题还是存在，这个时候如果去rewrite一个很大的AOF文件，那么删除文件可能就会导致操作系统挂起数秒。</li>
<li>根据确切的fsync策略，AOF可能比RDB慢。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>RDB持久性按指定的时间间隔保存内存中这个时间点的数据快照</li>
<li>AOF就是记录每次写命令到文件，下次启动的时候从文件中读取再重新执行一次。</li>
</ul>
<p>RDB和AOF可以同时工作，但是启动的时候会使用AOF文件来重建数据集。根据特性选择合适的策略。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redis.io/topics/persistence">官方文档</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>使用场景：按职责来划分，通常有以下使用场景：</p>
<ol>
<li>远程代理。 </li>
<li>虚拟代理。 </li>
<li>Copy-on-Write 代理。 </li>
<li>保护（Protect or Access）代理。 </li>
<li>Cache代理。 </li>
<li>防火墙（Firewall）代理。</li>
<li>同步化（Synchronization）代理。</li>
<li>智能引用（Smart Reference）代理。</li>
</ol>
<p><strong>JDK中的代理模式</strong></p>
<ul>
<li>java.lang.reflect.Proxy</li>
<li>RMI</li>
</ul>
<h2 id="优缺点及注意"><a href="#优缺点及注意" class="headerlink" title="优缺点及注意"></a>优缺点及注意</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>职责清晰。 </li>
<li>高扩展性。 </li>
<li>智能化。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 </li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li>
<li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个Cache代理的实现</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Image</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span> </span>&#123;
 
   <span class="hljs-keyword">private</span> String fileName;
 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RealImage</span><span class="hljs-params">(String fileName)</span></span>&#123;
      <span class="hljs-keyword">this</span>.fileName = fileName;
      loadFromDisk(fileName);
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Displaying &quot;</span> + fileName);
   &#125;
 
   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadFromDisk</span><span class="hljs-params">(String fileName)</span></span>&#123;
      System.out.println(<span class="hljs-string">&quot;Loading &quot;</span> + fileName);
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span></span>&#123;
 
   <span class="hljs-keyword">private</span> RealImage realImage;
   <span class="hljs-keyword">private</span> String fileName;
 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxyImage</span><span class="hljs-params">(String fileName)</span></span>&#123;
      <span class="hljs-keyword">this</span>.fileName = fileName;
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">if</span>(realImage == <span class="hljs-keyword">null</span>)&#123;
         realImage = <span class="hljs-keyword">new</span> RealImage(fileName);
      &#125;
      realImage.display();
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyPatternDemo</span> </span>&#123;
   
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      Image image = <span class="hljs-keyword">new</span> ProxyImage(<span class="hljs-string">&quot;test_10mb.jpg&quot;</span>);
      <span class="hljs-comment">// 图像将从磁盘加载</span>
      image.display(); 
      System.out.println(<span class="hljs-string">&quot;&quot;</span>);
      <span class="hljs-comment">// 图像不需要从磁盘加载</span>
      image.display();  
   &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰器</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<p>使用场景： </p>
<ol>
<li>扩展一个类的功能。 </li>
<li>动态增加功能，动态撤销。</li>
</ol>
<p>JDK中的装饰模式：</p>
<ul>
<li>java.io.BufferedInputStream(InputStream)</li>
<li>java.io.DataInputStream(InputStream)</li>
<li>java.io.BufferedOutputStream(OutputStream)</li>
<li>java.util.zip.ZipOutputStream(OutputStream)</li>
<li>java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap</li>
</ul>
<h2 id="优缺点及注意"><a href="#优缺点及注意" class="headerlink" title="优缺点及注意"></a>优缺点及注意</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>多层装饰比较复杂。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>可代替继承。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打LOL了&quot;</span>);
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayGameDecorator</span> </span>&#123;
    Person person;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;用顶配外星人&quot;</span>);
        person.playGame();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PlayGameDecorator</span><span class="hljs-params">(Person person)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.person = person;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        PlayGameDecorator decorator = <span class="hljs-keyword">new</span> PlayGameDecorator(<span class="hljs-keyword">new</span> Person());
        decorator.playGame();
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-适配器</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p>
<p>使用场景：<br>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p>JDK中的适配器模式：</p>
<ul>
<li>java.util.Arrays#asList()</li>
<li>java.util.Collections#list()</li>
<li>java.util.Collections#enumeration()</li>
<li>javax.xml.bind.annotation.adapters.XMLAdapter</li>
</ul>
<h2 id="优缺点及注意"><a href="#优缺点及注意" class="headerlink" title="优缺点及注意"></a>优缺点及注意</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>可以让任何两个没有关联的类一起运行。</li>
<li>提高了类的复用。 </li>
<li>增加了类的透明度。 </li>
<li>灵活性好。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 </li>
<li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MediaPlayer</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String audioType, String fileName)</span></span>;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AdvancedMediaPlayer</span> </span>&#123; 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playVlc</span><span class="hljs-params">(String fileName)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playMp4</span><span class="hljs-params">(String fileName)</span></span>;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VlcPlayer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AdvancedMediaPlayer</span></span>&#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playVlc</span><span class="hljs-params">(String fileName)</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Playing vlc file. Name: &quot;</span>+ fileName);      
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playMp4</span><span class="hljs-params">(String fileName)</span> </span>&#123;
      <span class="hljs-comment">//什么也不做</span>
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mp4Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AdvancedMediaPlayer</span></span>&#123;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playVlc</span><span class="hljs-params">(String fileName)</span> </span>&#123;
      <span class="hljs-comment">//什么也不做</span>
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playMp4</span><span class="hljs-params">(String fileName)</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Playing mp4 file. Name: &quot;</span>+ fileName);      
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MediaPlayer</span> </span>&#123;
 
   AdvancedMediaPlayer advancedMusicPlayer;
 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MediaAdapter</span><span class="hljs-params">(String audioType)</span></span>&#123;
      <span class="hljs-keyword">if</span>(audioType.equalsIgnoreCase(<span class="hljs-string">&quot;vlc&quot;</span>) )&#123;
         advancedMusicPlayer = <span class="hljs-keyword">new</span> VlcPlayer();       
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp4&quot;</span>))&#123;
         advancedMusicPlayer = <span class="hljs-keyword">new</span> Mp4Player();
      &#125;  
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String audioType, String fileName)</span> </span>&#123;
      <span class="hljs-keyword">if</span>(audioType.equalsIgnoreCase(<span class="hljs-string">&quot;vlc&quot;</span>))&#123;
         advancedMusicPlayer.playVlc(fileName);
      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp4&quot;</span>))&#123;
         advancedMusicPlayer.playMp4(fileName);
      &#125;
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AudioPlayer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MediaPlayer</span> </span>&#123;
   MediaAdapter mediaAdapter; 
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String audioType, String fileName)</span> </span>&#123;    
 
      <span class="hljs-comment">//播放 mp3 音乐文件的内置支持</span>
      <span class="hljs-keyword">if</span>(audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp3&quot;</span>))&#123;
         System.out.println(<span class="hljs-string">&quot;Playing mp3 file. Name: &quot;</span>+ fileName);         
      &#125; 
      <span class="hljs-comment">//mediaAdapter 提供了播放其他文件格式的支持</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(audioType.equalsIgnoreCase(<span class="hljs-string">&quot;vlc&quot;</span>) 
         || audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp4&quot;</span>))&#123;
         mediaAdapter = <span class="hljs-keyword">new</span> MediaAdapter(audioType);
         mediaAdapter.play(audioType, fileName);
      &#125;
      <span class="hljs-keyword">else</span>&#123;
         System.out.println(<span class="hljs-string">&quot;Invalid media. &quot;</span>+
            audioType + <span class="hljs-string">&quot; format not supported&quot;</span>);
      &#125;
   &#125;   
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterPatternDemo</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      AudioPlayer audioPlayer = <span class="hljs-keyword">new</span> AudioPlayer();
 
      audioPlayer.play(<span class="hljs-string">&quot;mp3&quot;</span>, <span class="hljs-string">&quot;beyond the horizon.mp3&quot;</span>);
      audioPlayer.play(<span class="hljs-string">&quot;mp4&quot;</span>, <span class="hljs-string">&quot;alone.mp4&quot;</span>);
      audioPlayer.play(<span class="hljs-string">&quot;vlc&quot;</span>, <span class="hljs-string">&quot;far far away.vlc&quot;</span>);
      audioPlayer.play(<span class="hljs-string">&quot;avi&quot;</span>, <span class="hljs-string">&quot;mind me.avi&quot;</span>);
   &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>适配器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p>
<p>在GUI编程中这个模式很常见，数据更新后视图也会跟着改变<br>比如JavaFX里面的 <strong>javafx.collections.ObservableList</strong></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p>
<ol>
<li>观察者和被观察者是抽象耦合的。</li>
<li>建立一套触发机制。</li>
</ol>
<p>缺点： </p>
<ol>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 </li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 </li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ol>
<p>注意事项：</p>
<ol>
<li>JAVA 中已经有了对观察者模式的支持类。 </li>
<li>避免循环引用。 </li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPriceUpdate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> price)</span></span>;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;
    <span class="hljs-keyword">int</span> price = <span class="hljs-number">10</span>;
    List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> price;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> price)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.price = price;
        notifyAllObserver();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAllObserver</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">for</span> (Observer observer : list) &#123;
            observer.onPriceUpdate(price);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerPriceObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;
        list.add(observer);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removePriceObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;
        list.remove(o);
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Subject subject = <span class="hljs-keyword">new</span> Subject();
        subject.registerPriceObserver(System.out::println);
        subject.registerPriceObserver(o -&gt; System.out.println(<span class="hljs-string">&quot;我是2：&quot;</span> + o));
        subject.setPrice(<span class="hljs-number">3</span>);
        subject.setPrice(<span class="hljs-number">4</span>);
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>观察者</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-迭代器</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>迭代器模式属于行为型模式。</p>
<p>在JDK的集合类中都实现了迭代器Iterable接口。<br>java.util.Iterator<br>java.util.Enumeration</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Aggregate</span> </span>&#123;
    <span class="hljs-function">Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Aggregate</span> </span>&#123;

    <span class="hljs-keyword">private</span> Integer[] items;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteAggregate</span><span class="hljs-params">()</span> </span>&#123;
        items = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;
            items[i] = i;
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteIterator&lt;Integer&gt;(items);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;
    <span class="hljs-function">Item <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;
&#125;
 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span>&lt;<span class="hljs-title">Item</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;

    <span class="hljs-keyword">private</span> Item[] items;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteIterator</span><span class="hljs-params">(Item[] items)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.items = items;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> items[position++];
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> position &lt; items.length;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Aggregate aggregate = <span class="hljs-keyword">new</span> ConcreteAggregate();
        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();
        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
            System.out.println(iterator.next());
        &#125;
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板方法</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
<p>主要解决一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p>jdk中使用模板方法的：</p>
<ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
<p>使用场景： </p>
<ol>
<li>有多个子类共有的方法，且逻辑相同。 </li>
<li>重要的、复杂的方法，可以考虑作为模板方法。</li>
</ol>
<h2 id="优缺点及注意"><a href="#优缺点及注意" class="headerlink" title="优缺点及注意"></a>优缺点及注意</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>封装不变部分，扩展可变部分。 </li>
<li>提取公共代码，便于维护。 3、行为由父类控制，子类实现。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>为防止恶意操作，一般模板方法都加上 final 关键词。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>;
 
   <span class="hljs-comment">//模板</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;
 
      <span class="hljs-comment">//初始化游戏</span>
      initialize();
 
      <span class="hljs-comment">//开始游戏</span>
      startPlay();
 
      <span class="hljs-comment">//结束游戏</span>
      endPlay();
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cricket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Game</span> </span>&#123;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Cricket Game Finished!&quot;</span>);
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Cricket Game Initialized! Start playing.&quot;</span>);
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Cricket Game Started. Enjoy the game!&quot;</span>);
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Football</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Game</span> </span>&#123;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Football Game Finished!&quot;</span>);
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Football Game Initialized! Start playing.&quot;</span>);
   &#125;
 
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span> </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Football Game Started. Enjoy the game!&quot;</span>);
   &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplatePatternDemo</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
 
      Game game = <span class="hljs-keyword">new</span> Cricket();
      game.play();
      System.out.println();
      game = <span class="hljs-keyword">new</span> Football();
      game.play();      
   &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-原型</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>JDK的Object.clone()是一实例。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProtoType</span> </span>&#123;
    <span class="hljs-function">ProtoType <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputerProtoType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProtoType</span> </span>&#123;
    <span class="hljs-keyword">int</span> bigData;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComputerProtoType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bigData)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.bigData = bigData;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ProtoType <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ComputerProtoType(bigData);
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoTypeTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ComputerProtoType protoType = <span class="hljs-keyword">new</span> ComputerProtoType(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>);
        ProtoType clone = protoType.clone();
    &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-生成器</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一个对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>可以用于编译器词法分析器指导生成抽象语法树、构造迷宫等。</p>
<p>和工厂模式不同的是，Builder模式需要详细的指导产品的生产。指导者（Director）使用Construct方法构造产品BuilderProduct，但是它不直接参与构造过程，而是把构造的任务交给生成器（Builder）。Builder提供了产品每一个部件构造的实现方法（可以是默认实现），但是如果要获得最终的产品，需要派生Builder的子类，添加getResult方法返回最终的产品对象。BuildPart方法正是被指导者调用指挥产品生产流程的接口。</p>
<p>在JDK中StringBuilder就是用法的生成器模式。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ol>
<p>生成器模式优点：</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>将一个复杂对象的创建过程封装起来。这里我们将每一个对象“可能”的创建过程封装在具体生成器实现类中。</li>
<li>允许对象通过多个步骤来创建，并且可以改变过程。这里我们可以通过Client来改变（自由搭配）对象的创建步骤，而不是像其它工厂模式一样只有一个步骤。这也就是定义中提到的同样的创建过程可以创建不同的表示。</li>
<li>向客户隐藏产品的内部实现。（这一点是所有创建型模式都有的）</li>
<li>产品的实现可以被替换，因为客户（注意这里的客户是指调用者）只看到一个抽象的接口。（所有的抽象都是用来干这个事的，呵呵）</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Builder</span> </span>&#123;
    <span class="hljs-function">Builder <span class="hljs-title">buildBody</span><span class="hljs-params">(String s)</span></span>;

    <span class="hljs-function">Builder <span class="hljs-title">buildHead</span><span class="hljs-params">(String s)</span></span>;

    <span class="hljs-function">Builder <span class="hljs-title">buildTail</span><span class="hljs-params">(String s)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HtmlBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Builder</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">buildBody</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">buildHead</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">buildTail</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Builder</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">buildBody</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">buildHead</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">buildTail</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Editer</span> </span>&#123;
    <span class="hljs-keyword">private</span> Builder builder;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Editer</span><span class="hljs-params">(Builder builder)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.builder = builder;
        <span class="hljs-comment">//do something</span>
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Editer(<span class="hljs-keyword">new</span> TxtBuilder());
        <span class="hljs-keyword">new</span> Editer(<span class="hljs-keyword">new</span> HtmlBuilder());
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>生成器</tag>
        <tag>Builder</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82.html</url>
    <content><![CDATA[<h2 id="简单工厂-Simple-Factory"><a href="#简单工厂-Simple-Factory" class="headerlink" title="简单工厂(Simple Factory)"></a>简单工厂(Simple Factory)</h2><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Computer</span> </span>&#123;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacComputer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span></span>&#123;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowsComputer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span></span>&#123;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputerFactory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Computer <span class="hljs-title">createComputer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;
        <span class="hljs-keyword">switch</span> (type) &#123;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WindowsComputer();
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MacComputer();
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Not Support Type &quot;</span> + type);
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="工厂方法-Factory-Method）"><a href="#工厂方法-Factory-Method）" class="headerlink" title="工厂方法(Factory Method）"></a>工厂方法(Factory Method）</h2><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<p>Calendar类就是采用这种。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Computer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSystemType</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacComputer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSystemType</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowsComputer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSystemType</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputerFactory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Computer <span class="hljs-title">getComputer</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printSystemType</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(getComputer().getSystemType());
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacComputerFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComputerFactory</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Computer <span class="hljs-title">getComputer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MacComputer();
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowsComputerFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComputerFactory</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Computer <span class="hljs-title">getComputer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WindowsComputer();
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> WindowsComputerFactory().printSystemType();
    &#125;
&#125;</code></pre>

<h2 id="抽象工厂-Abstract-Factory）"><a href="#抽象工厂-Abstract-Factory）" class="headerlink" title="抽象工厂(Abstract Factory）"></a>抽象工厂(Abstract Factory）</h2><p>提供一个接口，用于创建 相关的对象家族 。</p>
<p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractProductA</span> </span>&#123;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractProductB</span> </span>&#123;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProductA</span> </span>&#123;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProductA</span> </span>&#123;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProductB</span> </span>&#123;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProductB</span> </span>&#123;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;
    <span class="hljs-function">AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA1();
    &#125;

    <span class="hljs-function">AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB1();
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;
    <span class="hljs-function">AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA2();
    &#125;

    <span class="hljs-function">AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB2();
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        AbstractFactory abstractFactory = <span class="hljs-keyword">new</span> ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        <span class="hljs-comment">// do something with productA and productB</span>
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU算法的Java实现</title>
    <url>/%E7%AE%97%E6%B3%95/LRU%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>LRU（Least Recently Used）最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p>
<h2 id="基于LinkedHashMap实现"><a href="#基于LinkedHashMap实现" class="headerlink" title="基于LinkedHashMap实现"></a>基于LinkedHashMap实现</h2><p>LinkedHashMap为LRU其实做了一些准备，在构造中提供了一个accessOrder变量，默认false，如果设置为true，get方法会有额外操作保证链表顺序按访问顺序逆序排列。再通过removeEldestEntry方法来限定链表长度，到了最大容量自动删除头部，而头部也是最少被访问的。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/8/14 12:16</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRU</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;
    <span class="hljs-keyword">int</span> maxCapacity;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.size() &gt;= maxCapacity;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRU</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxCapacity)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(maxCapacity,<span class="hljs-number">0.75f</span>,<span class="hljs-keyword">true</span>)
        <span class="hljs-keyword">this</span>.maxCapacity = maxCapacity;
    &#125;
&#125;</code></pre>

<h2 id="链表-HashMap实现"><a href="#链表-HashMap实现" class="headerlink" title="链表+HashMap实现"></a>链表+HashMap实现</h2><p>基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p>
<ul>
<li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li>
<li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRU</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;

    <span class="hljs-keyword">private</span> Node head;
    <span class="hljs-keyword">private</span> Node tail;
    <span class="hljs-keyword">private</span> HashMap&lt;K, Node&gt; map;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize;

    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;

        Node pre;
        Node next;
        K k;
        V v;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(K k, V v)</span> </span>&#123;
            <span class="hljs-keyword">this</span>.k = k;
            <span class="hljs-keyword">this</span>.v = v;
        &#125;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRU</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;

        <span class="hljs-keyword">this</span>.maxSize = maxSize;
        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(maxSize * <span class="hljs-number">4</span> / <span class="hljs-number">3</span>);

        head = <span class="hljs-keyword">new</span> Node(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
        tail = <span class="hljs-keyword">new</span> Node(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);

        head.next = tail;
        tail.pre = head;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;

        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;

        Node node = map.get(key);
        unlink(node);
        appendHead(node);

        <span class="hljs-keyword">return</span> node.v;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;

        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;
            Node node = map.get(key);
            unlink(node);
        &#125;

        Node node = <span class="hljs-keyword">new</span> Node(key, value);
        map.put(key, node);
        appendHead(node);

        <span class="hljs-keyword">if</span> (map.size() &gt; maxSize) &#123;
            Node toRemove = removeTail();
            map.remove(toRemove.k);
        &#125;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlink</span><span class="hljs-params">(Node node)</span> </span>&#123;

        Node pre = node.pre;
        Node next = node.next;

        pre.next = next;
        next.pre = pre;

        node.pre = <span class="hljs-keyword">null</span>;
        node.next = <span class="hljs-keyword">null</span>;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendHead</span><span class="hljs-params">(Node node)</span> </span>&#123;
        Node next = head.next;
        node.next = next;
        next.pre = node;
        node.pre = head;
        head.next = node;
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;

        Node node = tail.pre;

        Node pre = node.pre;
        tail.pre = pre;
        pre.next = tail;

        node.pre = <span class="hljs-keyword">null</span>;
        node.next = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">return</span> node;
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;K&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;K&gt;() &#123;
            <span class="hljs-keyword">private</span> Node cur = head.next;

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">return</span> cur != tail;
            &#125;

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;
                Node node = cur;
                cur = cur.next;
                <span class="hljs-keyword">return</span> node.k;
            &#125;
        &#125;;
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存穿透、击穿、雪崩问题及解决方案</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>缓存穿透是指请求的数据在缓存中没有，并且数据库里面也没有。比如用户请求一个不存在的数据的时候，比如ID为-1之类的，这个时候就会直接访问数据库，如果用户是攻击者，这也就会导致数据库压力过大。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol>
<li>存一个空值的缓存，比如-1，就存个（-1，NULL）到缓存，这样就不会到达数据库了，但是注意缓存时间不能太长，免得影响正常业务。</li>
<li>对这类请求进行过滤。比如对接口增加权限鉴定之类的。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，保证不会有多个请求去刷新缓存，保证缓存key只被一个请求更新</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p>
<p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p>
<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ol>
<li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li>
<li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li>
<li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>设置热点数据永远不过期。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之Gap Locks与Next-key Locks</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E4%B9%8BGap-Locks%E4%B8%8ENext-key-Locks.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。而Next-Key就是行锁+Gap锁的组合。</p>
<h2 id="InnoBD的三种行级锁"><a href="#InnoBD的三种行级锁" class="headerlink" title="InnoBD的三种行级锁"></a>InnoBD的三种行级锁</h2><ol>
<li>Record Lock：锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks依然可以使用。</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</li>
<li>Next-Key Lock：1、2组合，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</li>
</ol>
<h2 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h2><p>Gap Lock，又称为间隙锁。存在的主要目的就是为了防止在<strong>可重复读</strong>的事务级别下，出现幻读问题。</p>
<p>在可重复读的事务级别下面，普通的select读的是快照，不存在幻读情况，但是如果加上for update的话，读取是已提交事务数据，gap锁保证for update情况下，不出现幻读。</p>
<p>以下都是在可重读隔离级别情况下。</p>
<p>test表如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>d</td>
<td>3</td>
</tr>
<tr>
<td>g</td>
<td>6</td>
</tr>
<tr>
<td>j</td>
<td>8</td>
</tr>
</tbody></table>
<p>其中id是主键，value是非唯一索引</p>
<pre><code class="hljs sql"><span class="hljs-comment"># T1</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">num</span>=<span class="hljs-number">6</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;
<span class="hljs-comment"># T2</span>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">test</span> (<span class="hljs-keyword">id</span>, <span class="hljs-keyword">value</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>);</code></pre>

<p>T1这样的操作会锁定（3,6]，(6,8]，但是会发现插入操作依旧可以成功，因为虽然Value的区间是锁住了，但是根据id=‘a’这一条让排序在a前面去了</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200810133247.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200810133247.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>总的来说，锁的间隙是根据B+树排序后的叶子节点之间的区间，不但要看非索引，也会看主键。</p>
<ul>
<li>假如是非索引列，那么将会全表间隙加上gap锁。</li>
<li>条件是唯一索引等值检索且记录不存在的情况，我们要考虑，gap lock是防止幻读，那么尝试思考，使用唯一索引所谓条件查找数据for update，如果对应的记录不存在的话，是无法使用行锁的。这时候，会使用gap lock来锁住区间，保证记录不会插入，防止出现幻读。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Next-Locks就是结合行锁和间隙锁进行的，主要是用于MVCC出现幻读的情况。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/qq_20597727/article/details/87308709">深入了解mysql–gap locks,Next-Key Locks</a></li>
<li><a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html">Innodb锁机制：Next-Key Lock 浅谈</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Next-Key</tag>
        <tag>间隙锁</tag>
        <tag>幻读</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库之事务与实现原理</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h2 id="为什么需要事务"><a href="#为什么需要事务" class="headerlink" title="为什么需要事务"></a>为什么需要事务</h2><p>典型的就是转账问题了，转账是生活中常见的操作，比如从A账户转账100元到B账号。站在用户角度而言,这是一个逻辑上的单一操作，然而在数据库系统中，至少会分成两个步骤来完成:</p>
<ul>
<li>将A账户的金额减少100元</li>
<li>将B账户的金额增加100元。</li>
</ul>
<p>这个时候可能会出现问题：</p>
<ol>
<li>转账操作的第一步执行成功,A账户上的钱减少了100元,但是第二步执行失败或者未执行便发生系统崩溃,导致B账户并没有相应增加100元。</li>
<li>转账操作刚完成就发生系统崩溃,系统重启恢复时丢失了崩溃前的转账记录。</li>
<li>同时又另一个用户转账给B账户，由于同时对B账户进行操作，导致B账户金额出现异常。</li>
</ol>
<h2 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">TRANSACTION</span>  //事务开始
SQL1
SQL2
<span class="hljs-keyword">COMMIT</span>/<span class="hljs-keyword">ROLLBACK</span>   //事务提交或回滚</code></pre>

<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。<br>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。并发执行的事务不会相互影响，其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账，最后账户的结果应该和他们按先后次序转账的结果一样。</p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。</p>
<h3 id="事务中的ACID"><a href="#事务中的ACID" class="headerlink" title="事务中的ACID"></a>事务中的ACID</h3><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况。</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808222606.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808222606.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>丢失更新是指事务覆盖了其他事务对数据的已提交修改,导致这些修改好像丢失了一样。</p>
<p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808230453.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808230453.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="300"/>

<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读是指一个事务读取了另一个事务未提交的数据，在事务1对A的处理过程中,事务2读取了A的值,但之后事务1回滚,导致事务2读取的A是未提交的脏数据。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808230630.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808230630.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="300"/>

<h3 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h3><p>脏写是指事务回滚了其他事务对数据项的已提交修改,比如下面这种情况，在事务1对数据A的回滚,导致事务2对A的已提交修改也被回滚了。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808231618.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808231618.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="300"/>

<h3 id="不可重读读"><a href="#不可重读读" class="headerlink" title="不可重读读"></a>不可重读读</h3><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808230949.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808230949.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="300"/>

<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808231134.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808231134.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="300"/>

<p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。<br>事务的隔离级别越低,可能出现的并发异常越多,但是通常而言系统能提供的并发能力越强。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务具有隔离性，理论上来说事务之间的执行不应该相互产生影响,其对数据库的影响应该和它们串行执行时一样。<br>然而完全的隔离性会导致系统并发性能很低，降低对资源的利用率，因而实际上对隔离性的要求会有所放宽，这也会一定程度造成对数据库一致性要求降低。</p>
<p>SQL标准为事务定义了不同的隔离级别,从低到高依次是：</p>
<ol>
<li>读未提交(READ UNCOMMITTED)</li>
<li>读已提交(READ COMMITTED)</li>
<li>可重复读(REPEATABLE READ)</li>
<li>串行化(SERIALIZABLE)</li>
</ol>
<h3 id="读未提交-READ-UNCOMMITTED"><a href="#读未提交-READ-UNCOMMITTED" class="headerlink" title="读未提交(READ UNCOMMITTED)"></a>读未提交(READ UNCOMMITTED)</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h3 id="读已提交-READ-COMMITTED"><a href="#读已提交-READ-COMMITTED" class="headerlink" title="读已提交(READ COMMITTED)"></a>读已提交(READ COMMITTED)</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h3 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读(REPEATABLE READ)"></a>可重复读(REPEATABLE READ)</h3><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p>
<h3 id="串行化-SERIALIZABLE"><a href="#串行化-SERIALIZABLE" class="headerlink" title="串行化(SERIALIZABLE)"></a>串行化(SERIALIZABLE)</h3><p>强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要。</p>
<h3 id="MySQL中的事务隔离级别的操作"><a href="#MySQL中的事务隔离级别的操作" class="headerlink" title="MySQL中的事务隔离级别的操作"></a>MySQL中的事务隔离级别的操作</h3><pre><code class="hljs sql"><span class="hljs-comment">#查询隔离级别</span>
<span class="hljs-keyword">SELECT</span> @@transaction_isolation
<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%transaction_isolation%&#x27;</span>;
<span class="hljs-comment">#设置隔离级别</span>
<span class="hljs-keyword">SET</span> transaction_isolation=<span class="hljs-string">&#x27;READ-UNCOMMITTED&#x27;</span>;<span class="hljs-comment">#读未提交</span>
<span class="hljs-keyword">SET</span> transaction_isolation=<span class="hljs-string">&#x27;READ-COMMITTED&#x27;</span>;<span class="hljs-comment">#读已提交</span>
<span class="hljs-keyword">SET</span> transaction_isolation=<span class="hljs-string">&#x27;REPEATABLE-READ&#x27;</span>;<span class="hljs-comment">#可重复读</span>
<span class="hljs-keyword">SET</span> transaction_isolation=<span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>;<span class="hljs-comment">#串行化</span></code></pre>

<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808232230.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200808232230.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="600"/>

<h2 id="事务隔离级别的实现-并发控制技术"><a href="#事务隔离级别的实现-并发控制技术" class="headerlink" title="事务隔离级别的实现-并发控制技术"></a>事务隔离级别的实现-并发控制技术</h2><p>并发控制技术是实现事务隔离性的关键，实现方式有多种，并发控制策略可以分为两类：</p>
<ul>
<li>乐观并发控制：对于并发执行可能冲突的操作，假定其不会真的冲突，允许并发执行，直到真正发生冲突时才去解决冲突，比如让事务回滚。</li>
<li>悲观并发控制：对于并发执行可能冲突的操作，假定其必定发生冲突，通过让事务等待(锁)或者中止(时间戳排序)的方式使并行的操作串行执行。</li>
</ul>
<h3 id="基于封锁的并发控制"><a href="#基于封锁的并发控制" class="headerlink" title="基于封锁的并发控制"></a>基于封锁的并发控制</h3><h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。<br>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h4 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h4><p><strong>1.读写锁</strong></p>
<ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁。加了X锁，其他事务什么锁都不能加。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。加了S锁其他事务可以加S锁，不能加X锁。</li>
</ul>
<p><strong>2.意向锁（Intention Locks）</strong></p>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>IX</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>S</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>IS</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li>
<li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li>
</ul>
<h4 id="三级锁与两段锁协议"><a href="#三级锁与两段锁协议" class="headerlink" title="三级锁与两段锁协议"></a>三级锁与两段锁协议</h4><h5 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h5><p>三级封锁协议就是对锁使用的规定，来解决事务并发一致性问题。</p>
<p><strong>a.一级封锁-解决丢失更新</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。<br>可以解决丢失更新问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<p><strong>b.二级封锁-解决脏读</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<p><strong>c.三级封锁-解决不可重复读</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<h5 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h5><p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<pre><code class="hljs plain">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</code></pre>

<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<pre><code class="hljs plain">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</code></pre>
<h4 id="MySQL隐式与显示锁定"><a href="#MySQL隐式与显示锁定" class="headerlink" title="MySQL隐式与显示锁定"></a>MySQL隐式与显示锁定</h4><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">In</span> <span class="hljs-keyword">SHARE</span> <span class="hljs-keyword">MODE</span>; <span class="hljs-comment">#S锁</span>
<span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>; <span class="hljs-comment">#X锁</span></code></pre>

<h3 id="基于时间戳的并发控制"><a href="#基于时间戳的并发控制" class="headerlink" title="基于时间戳的并发控制"></a>基于时间戳的并发控制</h3><p>核心思想：对于并发可能冲突的操作，基于时间戳排序规则选定某事务继续执行,其他事务回滚。</p>
<p>系统会在每个事务开始时赋予其一个时间戳,这个时间戳可以是系统时钟也可以是一个不断累加的计数器值,当事务回滚时会为其赋予一个新的时间戳，先开始的事务时间戳小于后开始事务的时间戳。</p>
<p>每一个数据项Q有两个时间戳相关的字段:<br>W-timestamp(Q):成功执行write(Q)的所有事务的最大时间戳<br>R-timestamp(Q):成功执行read(Q)的所有事务的最大时间戳</p>
<p>具体排序方式就是：</p>
<ol>
<li>假设事务T发出read(Q),T的时间戳为TS<br> a. 若TS(T)&lt;W-timestamp(Q),则T需要读入的Q已被覆盖。此<br> read操作将被拒绝,T回滚。<br> b. 若TS(T)&gt;=W-timestamp(Q),则执行read操作,同时把<br> R-timestamp(Q)设置为TS(T)与R-timestamp(Q)中的最大值</li>
<li>假设事务T发出write(Q)<br> a.若TS(T)&lt;R-timestamp(Q),write操作被拒绝,T回滚。<br> b.若TS(T)&lt;W-timestamp(Q),则write操作被拒绝,T回滚。<br> c.其他情况:系统执行write操作,将W-timestamp(Q)设置<br> 为TS(T)。</li>
</ol>
<p>基于时间戳排序和基于锁实现的本质一样:对于可能冲突的并发操作,以串行的方式取代并发执行,因而它也是一种悲观并发控制。它们的区别主要有两点:</p>
<ul>
<li>基于锁是让冲突的事务进行等待，而基于时间戳排序是让冲突的事务回滚。</li>
<li>基于锁冲突事务的执行次序是根据它们申请锁的顺序,先申请的先执行;而基于时间戳排序是根据特定的时间戳排序规则。</li>
</ul>
<h3 id="基于有效性检查的并发控制"><a href="#基于有效性检查的并发控制" class="headerlink" title="基于有效性检查的并发控制"></a>基于有效性检查的并发控制</h3><p>核心思想：事务对数据的更新首先在自己的工作空间进行，等到要写回数据库时才进行有效性检查，对不符合要求的事务进行回滚。</p>
<p>基于有效性检查的事务执行过程会被分为三个阶段:</p>
<ol>
<li><strong>读阶段：</strong> 数据项被读入并保存在事务的局部变量中。所有write操作都是对局部变量进行，并不对数据库进行真正的更新。</li>
<li><strong>有效性检查阶段：</strong> 对事务进行有效性检查，判断是否可以执行write操作而不违反可串行性。如果失败，则回滚该事务。</li>
<li><strong>写阶段：</strong> 事务已通过有效性检查，则将临时变量中的结果更新到数据库中。</li>
</ol>
<p>有效性检查通常也是通过对事务的时间戳进行比较完成的，不过和基于时间戳排序的规则不一样。</p>
<p>该方法允许可能冲突的操作并发执行,因为每个事务操作的都是自己工作空间的局部变量,直到有效性检查阶段发现了冲突才回滚。因而这是一种乐观的并发策略。</p>
<h3 id="基于多版本并发控制（MVCC）与快照隔离"><a href="#基于多版本并发控制（MVCC）与快照隔离" class="headerlink" title="基于多版本并发控制（MVCC）与快照隔离"></a>基于多版本并发控制（MVCC）与快照隔离</h3><h4 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h4><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p>可以认为MVCC是行级锁的一个变种，但是在很多情况下又避免了加锁，所以效率比较高。</p>
<p>MySQL的InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列实现：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
<p>其中系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。事务版本号：事务开始时的系统版本号。</p>
<p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200809163944.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200809163944.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>以下实现过程针对可重复读隔离级别。</p>
<p>当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p>
<p>1.SELECT</p>
<p>①只查找版本早于当前事务版本的数据行（行的系统版本号小于等于事务的系统版本号），这样可以保证要么数据行是之前存在的，要么就是自己这个事务自己修改的。</p>
<p>②查找行的删除版本号要么大于当前事务版本号，要么未定义。这样可以保证这个数据行没有被删除的。</p>
<p>2.INSERT</p>
<p>将当前系统版本号作为数据行快照的创建版本号。</p>
<p>3.DELETE</p>
<p>将当前系统版本号作为数据行快照的删除版本号。</p>
<p>4.UPDATE</p>
<p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<h4 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h4><p><strong>1.快照读</strong></p>
<p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> ...;</code></pre>

<p><strong>2.当前读</strong><br>读取的是最新的数据，不去读快照，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> ? <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share</span> <span class="hljs-keyword">mode</span>;
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> ? <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;
<span class="hljs-keyword">insert</span>;
<span class="hljs-keyword">update</span>;
<span class="hljs-keyword">delete</span>;</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://cyc2018.gitee.io/cs-notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86">数据库系统原理</a></li>
<li><a href="https://www.cnblogs.com/takumicx/p/9998844.html">数据库事务的概念及其实现原理</a></li>
<li><a href="https://www.jianshu.com/p/b4175a98674b">MVCC多版本并发控制</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>ACID</tag>
        <tag>MVCC</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的字符集与校对规则</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E6%A0%A1%E5%AF%B9%E8%A7%84%E5%88%99.html</url>
    <content><![CDATA[<h2 id="什么是字符集与校对规则"><a href="#什么是字符集与校对规则" class="headerlink" title="什么是字符集与校对规则"></a>什么是字符集与校对规则</h2><p>字符集指的是⼀种从⼆进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每⼀种字符集都会对应⼀系列的校对规则。</p>
<p>MySQL采⽤的是类似继承的⽅式指定字符集的默认值，每个数据库以及每张数据表都有⾃⼰的默认值，他们逐层继承。⽐如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采⽤默认字符集）</p>
<h2 id="字符集-Character-set"><a href="#字符集-Character-set" class="headerlink" title="字符集(Character set)"></a>字符集(Character set)</h2><p>是多个字符(英文字符，汉字字符，或者其他国家语言字符)的集合，字符集种类较多，每个字符集包含的字符个数不同。</p>
<p>特点：</p>
<ol>
<li>字符编码方式是用一个或多个字节表示字符集中的一个字符</li>
<li>每种字符集都有自己特有的编码方式，因此同一个字符，在不同字符集的编码方式下，会产生不同的二进制</li>
</ol>
<p>常见字符集：</p>
<ul>
<li>ASCII字符集：基于罗马字母表的一套字符集，它采用1个字节的低7位表示字符，高位始终为0。</li>
<li>LATIN1字符集：相对于ASCII字符集做了扩展，仍然使用一个字节表示字符，但启用了高位，扩展了字符集的表示范围。</li>
<li>GBK字符集：支持中文，字符有一字节编码和两字节编码方式。</li>
<li>UTF8字符集：Unicode字符集的一种，是计算机科学领域里的一项业界标准，支持了所有国家的文字字符，utf8采用1-4个字节表示字符。</li>
</ul>
<h3 id="MySQL的字符集"><a href="#MySQL的字符集" class="headerlink" title="MySQL的字符集"></a>MySQL的字符集</h3><p>查看字符编码支持</p>
<pre><code class="hljs sql"><span class="hljs-comment"># 查看当前库</span>
<span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&quot;charcter_set%&quot;</span>;

<span class="hljs-comment"># 查看所有支持的</span>
<span class="hljs-keyword">show</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span>;</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802194035.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802194035.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="各种字符集的作用"><a href="#各种字符集的作用" class="headerlink" title="各种字符集的作用"></a>各种字符集的作用</h3><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802194936.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802194936.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="字符编码转换原理"><a href="#字符编码转换原理" class="headerlink" title="字符编码转换原理"></a>字符编码转换原理</h3><p>问：若character_set_client为UTF8，而character_set_database为GBK，则会出现需要进行编码转换的情况，字符集转换的原理是什么？</p>
<p>答：假设gbk字符集的字符串“你好”，需要转为utf8字符集存储，实际就是对于“你好”字符串中的每个汉字去utf8编码表里面查询对应的二进制，然后存储。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802195352.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802195352.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<ol>
<li>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection;</li>
<li>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，确定内部操作字符集步骤：<ul>
<li>使用每个数据字段的CHARACTER SET设定值；</li>
<li>若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值；</li>
<li>若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</li>
<li>若上述值不存在，则使用character_set_server设定值；</li>
</ul>
</li>
<li>将操作结果从内部操作字符集转换为character_set_results。</li>
</ol>
<h3 id="正确使用字符集"><a href="#正确使用字符集" class="headerlink" title="正确使用字符集"></a>正确使用字符集</h3><ol>
<li>对于insert来说，character_set_client、character_set_connection相同，而且正确反映客户端使用的字符集</li>
<li>对于select来说，character_set_results正确反映客户端字符集</li>
<li>数据库字符集取决于我们要存储的字符类型</li>
<li>字符集转换最多发生一次，这就要求character_set_client、character_set_connection相同</li>
<li>所有的字符集转换都发生在数据库端</li>
</ol>
<h3 id="修改MySQL的字符集"><a href="#修改MySQL的字符集" class="headerlink" title="修改MySQL的字符集"></a>修改MySQL的字符集</h3><pre><code class="hljs sql"><span class="hljs-comment">#设置所有字符集</span>
<span class="hljs-keyword">set</span> <span class="hljs-keyword">names</span> <span class="hljs-string">&#x27;utf8&#x27;</span>;

<span class="hljs-comment">#修改数据库字符集</span>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> database_name <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&quot;utf8&quot;</span>;

<span class="hljs-comment">#只修改表的字符集，影响后续该表新增列的默认定义，已有列的字符集不受影响。</span>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> xxx；

<span class="hljs-comment">#同时修改表字符集和已有列字符集，并将已有数据进行字符集编码转换。</span>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> xxx;

<span class="hljs-comment">#修改列字符集</span>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">modify</span> col_name <span class="hljs-built_in">varchar</span>(col_length) <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> xxx;</code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>建立数据库的时候注意字符集（gbk、utf8）；</li>
<li>连接数据库以后，无论是执行dml还是select，只要涉及到varchar、char列，就需要设置正确的字符集参数。</li>
</ol>
<h2 id="校对规则collation校对"><a href="#校对规则collation校对" class="headerlink" title="校对规则collation校对"></a>校对规则collation校对</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>校对规则是在字符集内用于字符比较和排序的一套规则，比如有的规则区分大小写，有的则无视。</p>
<p>校对规则特征：</p>
<ol>
<li>两个不同的字符集不能有相同的校对规则；</li>
<li>每个字符集有一个默认校对规则；</li>
<li>存在校对规则命名约定：以其相关的字符集名开始，中间包括一个语言名，并且以_ci（大小写不敏感）、_cs（大小写敏感）或_bin（二元）结束。</li>
</ol>
<h3 id="查看MySQL的校对规则"><a href="#查看MySQL的校对规则" class="headerlink" title="查看MySQL的校对规则"></a>查看MySQL的校对规则</h3><pre><code class="hljs sql"><span class="hljs-comment">#查看支持的校对规则</span>
<span class="hljs-keyword">show</span> <span class="hljs-keyword">collation</span>; 
<span class="hljs-comment"># 查看当前的库校对规则</span>
<span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;collation_%&#x27;</span>;</code></pre>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802204746.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802204746.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的索引</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95.html</url>
    <content><![CDATA[<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h2 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h2><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<p>索引的优点： </p>
<ul>
<li><p>大大减少了服务器需要扫描的数据行数。</p>
</li>
<li><p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p>
</li>
<li><p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</p>
</li>
</ul>
<h2 id="各类索引"><a href="#各类索引" class="headerlink" title="各类索引"></a>各类索引</h2><h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<ul>
<li>不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</li>
<li>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</li>
<li>可以指定多个列作为索引列，多个索引列共同组成键。</li>
<li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li>
</ul>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>InnoDB 的 B+Tree 索引分为<strong>主索引</strong>和<strong>辅助索引</strong>。<strong>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引</strong>。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200804211616.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200804211616.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p><strong>辅助索引</strong>的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200804211713.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200804211713.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><p>MyISAM索引文件和数据文件是分离的，索引文件的data域保存记录所在页的地址（物理存储位置），通过这些地址来读取页，进而读取被索引的行数据。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200804211555.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200804211555.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>对于二级索引，在 MyISAM存储引擎中以与上图同样的方式实现，也就是主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p>
<h4 id="B-树介绍"><a href="#B-树介绍" class="headerlink" title="B+树介绍"></a>B+树介绍</h4><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200804164453.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200804164453.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<h4 id="B-树查找过程"><a href="#B-树查找过程" class="headerlink" title="B+树查找过程"></a>B+树查找过程</h4><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<h4 id="b-树性质"><a href="#b-树性质" class="headerlink" title="b+树性质"></a>b+树性质</h4><p>1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p>
<p>2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引的实现方式就是通过散列表的方式实现的，能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。<br>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引，但是对中文支持不是很好。</p>
<h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> actor_id <span class="hljs-keyword">FROM</span> sakila.actor <span class="hljs-keyword">WHERE</span> actor_id + <span class="hljs-number">1</span> = <span class="hljs-number">5</span>;</code></pre>

<h3 id="多列索引（联合索引）"><a href="#多列索引（联合索引）" class="headerlink" title="多列索引（联合索引）"></a>多列索引（联合索引）</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引（联合索引）。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> film_id, actor_ <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> sakila.film_actor <span class="hljs-keyword">WHERE</span> actor_id = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> film_id = <span class="hljs-number">1</span>;</code></pre>

<h3 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> staff_id)/<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> staff_id_selectivity,
<span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> customer_id)/<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> customer_id_selectivity,
<span class="hljs-keyword">COUNT</span>(*)
<span class="hljs-keyword">FROM</span> payment;

<span class="hljs-comment"># 查到</span>
staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049</code></pre>

<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>索引包含所有需要查询的字段的值。即是查的字段全是索引。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统 I/O 调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id="索引的正确使用方式"><a href="#索引的正确使用方式" class="headerlink" title="索引的正确使用方式"></a>索引的正确使用方式</h2><ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MyISAM和InnoDB引擎区别</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MyISAM%E5%92%8CInnoDB%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<h2 id="MySql支持的引擎"><a href="#MySql支持的引擎" class="headerlink" title="MySql支持的引擎"></a>MySql支持的引擎</h2><p>通过命令查看</p>
<pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">engines</span>;</code></pre>

<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802174005.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802174005.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<p><font color="red">可以看到（8.0版本）是只有InnoDB 是事务性存储引擎，也就是说只有 InnoDB ⽀持事务。</font></p>
<h2 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h2><p>MySQL 5.5版之前，MyISAM是MySQL的默认数据库引擎。虽然性能极佳，⽽且提供了⼤量的特性，包括全⽂索引、压缩、空间函数等，但MyISAM不⽀持事务和⾏级锁，⽽且最⼤的缺陷就是崩溃后⽆法安全恢复。不过，5.5版本之后，MySQL引⼊了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p>
<p>⼤多数时候我们使⽤的都是 InnoDB 存储引擎，但是在某些情况下使⽤ MyISAM 也是合适的⽐如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。</p>
<h3 id="事务和外键"><a href="#事务和外键" class="headerlink" title="事务和外键"></a>事务和外键</h3><ul>
<li>InnoDB具有事务，支持4个事务隔离级别，回滚，崩溃修复能力和多版本并发的事务安全，包括ACID。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能</li>
<li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择</li>
</ul>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>Innodb不支持全文索引，如果一定要用的话，最好使用sphinx等搜索引擎。MyISAM对中文支持的不是很好，不过5.6.4版本以后的Innodb已经支持了</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>MyISAM 只支持表级锁</li>
<li>Innodb 支持表级锁，行级锁（默认）</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul>
<li>InnoDB，基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小</li>
<li>MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型， .sdi文件存储表定义，数据文件的扩展名为.MYD，  索引文件的扩展名是.MYI</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li>MyISAM（堆组织表）使用的是非聚簇索引、索引和文件分开，随机存储，只能缓存索引</li>
<li>InnoDB（索引组织表）使用的聚簇索引、索引就是数据，顺序存储，因此能缓存索引，也能缓存数据</li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li>MyISAM读写互相阻塞：不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读</li>
<li>InnoDB 读写阻塞与事务隔离级别相关</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li><strong>是否⽀持事务和崩溃后的安全恢复</strong>： MyISAM 强调的是性能，每次查询具有原⼦性,其执⾏速度⽐InnoDB类型更快，但是不提供事务⽀持。但是InnoDB 提供事务⽀持事务，外部键等⾼级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能⼒(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li><strong>是否⽀持外键</strong>： MyISAM不⽀持，⽽InnoDB⽀持。</li>
<li><strong>是否⽀持MVCC</strong> ：仅 InnoDB ⽀持。应对⾼并发事务，MVCC ( Multi-Version Concurrency Control )（多版本并发控制）⽐单纯的加锁更⾼效；MVCC只在READ COMMITTED 和 REPEATABLE READ 两个隔离级别下⼯作；MVCC可以使⽤ 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现；各数据库中MVCC实现并不统⼀。</li>
</ol>
<h2 id="为什么MyISAM会比Innodb的查询速度快"><a href="#为什么MyISAM会比Innodb的查询速度快" class="headerlink" title="为什么MyISAM会比Innodb的查询速度快"></a>为什么MyISAM会比Innodb的查询速度快</h2><p>《MySQL⾼性能》上⾯有⼀句话这样写到:</p>
<blockquote>
<p>不要轻易相信“MyISAM⽐InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是⽤到了聚簇索引，或者需要访问的数据都可以放⼊内存的应⽤。</p>
</blockquote>
<p>InnoDB 在做SELECT的时候，要维护的东西比MYISAM引擎多很多；</p>
<ol>
<li>InnoDB 要缓存数据和索引，MyISAM只缓存索引块，这中间还有换进换出的减少</li>
<li>innodb寻址要映射到块，再到行，MyISAM记录的直接是文件的OFFSET，定位比INNODB要快</li>
<li>InnoDB 还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护</li>
</ol>
<p>InnoDB ：通过为每一行记录添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。让我们来看看当隔离级别是REPEATABLE READ时这种策略是如何应用到特定的操作的</p>
<p>SELECT InnoDB必须每行数据来保证它符合两个条件</p>
<ol>
<li>InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。</li>
<li>这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。</li>
</ol>
<p>⼀般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能⼒和并发能⼒，也不需要事务⽀持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是⼀个不错的选择。但是⼀般情况下，我们都是需要考虑到这些问题的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_27607965/article/details/79925288">mysql中innodb和myisam对比及索引原理区别</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>存储引擎</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之虚拟内存</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了更加有效地管理内存并减少出错，现代操作系统提供了一种对主存的抽象概念，即是虚拟内存（Virtual Memory）。虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</p>
<p>理解不深刻的人会认为虚拟内存只是“使用硬盘空间来扩展内存“的技术，这是不对的。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，使得程序的编写难度降低。并且，把内存扩展到硬盘空间只是使用虚拟内存的必然结果，虚拟内存空间会存在硬盘中，并且会被内存缓存（按需），有的操作系统还会在内存不够的情况下，将某一进程的内存全部放入硬盘空间中，并在切换到该进程时再从硬盘读取（这也是为什么Windows会经常假死的原因…）。</p>
<p>虚拟内存主要提供了如下三个重要的能力：</p>
<ul>
<li>它把主存看作为一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中缓存活动区域（按需缓存）。</li>
<li>它为每个进程提供了一个一致的地址空间，从而降低了程序员对内存管理的复杂性。</li>
<li>它还保护了每个进程的地址空间不会被其他进程破坏。</li>
</ul>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>要想更好地理解虚拟内存技术，必须要知道计算机中著名的局部性原理。另外，局部性原理既适⽤于程序结构，也适⽤于数据结构，是⾮常重要的⼀个概念。</p>
<p>局部性原理是虚拟内存技术的基础，正是因为程序运⾏具有局部性原理，才可以只装⼊部分程序到内存就开始运⾏。</p>
<p>早在 1968 年的时候，就有⼈指出我们的程序在执⾏的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执⾏局限于某⼀⼩部分，程序访问的存储空间也局限于某个区域。</p>
<p>局部性原理表现在以下两个⽅⾯：</p>
<ol>
<li>时间局部性 ：如果程序中的某条指令⼀旦执⾏，不久以后该指令可能再次执⾏；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着⼤量的循环操作。</li>
<li>空间局部性 ：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执⾏的，数据也⼀般是以向量、数组、表等形式簇聚存储的。时间局部性是通过将近来使⽤的指令和数据保存到⾼速缓存存储器中，并使⽤⾼速缓存的层次结构实现。空间局部性通常是使⽤较⼤的⾼速缓存，并将预取机制集成到⾼速缓存控制逻辑中实现。虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利⽤局部性原理实现髙速缓存。</li>
</ol>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>基于局部性原理，在程序装⼊时，可以将程序的⼀部分装⼊内存，⽽将其他部分留在外存，就可以启动程序执⾏。由于外存往往⽐内存⼤很多，所以我们运⾏的软件的内存⼤⼩实际上是可以⽐计算机系统实际的内存⼤⼩⼤的。在程序执⾏过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调⼊内存，然后继续执⾏程序。另⼀⽅⾯，操作系统将内存中暂时不使⽤的内容换到外存上，从⽽腾出空间存放将要调⼊内存的信息。这样，计算机好像为⽤户提供了⼀个⽐实际内存⼤的多的存储器——虚拟存储器。</p>
<p>实际上，我觉得虚拟内存同样是⼀种时间换空间的策略，你⽤ CPU 的计算时间，⻚的调⼊调出花费的时间，换来了⼀个虚拟的更⼤的空间来⽀持程序的运⾏。不得不感叹，程序世界⼏乎不是时间换空间就是空间换时间。</p>
<p>推荐阅读<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/14.html">王道考研操作系统知识点整理</a></p>
<h2 id="虚拟内存的技术实现"><a href="#虚拟内存的技术实现" class="headerlink" title="虚拟内存的技术实现"></a>虚拟内存的技术实现</h2><p>虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有三种⽅式：请求分页储存管理，请求分段储存管理，请求段页式存储管理。</p>
<h3 id="请求分页储存管理"><a href="#请求分页储存管理" class="headerlink" title="请求分页储存管理"></a>请求分页储存管理</h3><p>建⽴在分⻚管理之上，为了⽀持虚拟存储器功能⽽增加了请求调⻚功能和⻚⾯置换功能。请求分⻚是⽬前最常⽤的⼀种实现虚拟存储器的⽅法。请求分⻚存储管理系统中，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏。假如在作业运⾏的过程中发现要访问的⻚⾯不在内存，则由处理器通知操作系统按照对应的⻚⾯置换算法将相应的⻚⾯调⼊到主存，同时操作系统也可以将暂时不⽤的⻚⾯置换到外存中。</p>
<h3 id="请求分段储存管理"><a href="#请求分段储存管理" class="headerlink" title="请求分段储存管理"></a>请求分段储存管理</h3><p>建⽴在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理⽅式就如同请求分⻚储存管理⽅式⼀样，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏；在执⾏过程中，可使⽤请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，⽽⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间⽽装⼊新的段。</p>
<h3 id="请求段页式存储管理"><a href="#请求段页式存储管理" class="headerlink" title="请求段页式存储管理"></a>请求段页式存储管理</h3><p>请求段页式管理方式只要求将作业若干页或段装入内存就可以开始运行作业，作业的其他部分别放在外存中，等待运行需要的时候才被调入内存，</p>
<p>请求段页式管理方式要求相对程序按逻辑意义分段后再分页，所以相对于请求页式管理方式能够方便用户使用，便于共享、保护和动态链接。进程在启动的时候采取与装入模式，则可以根据段的意义装入某些进程运行开始阶段所需要的段。</p>
<h2 id="⻚⾯置换算法"><a href="#⻚⾯置换算法" class="headerlink" title="⻚⾯置换算法"></a>⻚⾯置换算法</h2><p>地址映射过程中，若在⻚⾯中发现所要访问的⻚⾯不在内存中，则发⽣缺⻚中断 。</p>
<blockquote>
<p><strong>缺⻚中断</strong> 就是要访问的⻚不在主存，需要操作系统将其调⼊主存后再进⾏访问。 在这个时候，被内存映射的⽂件实际上成了⼀个分⻚交换⽂件。</p>
</blockquote>
<p>当发⽣缺⻚中断时，如果当前内存中并没有空闲的⻚⾯，操作系统就必须在内存选择⼀个⻚⾯将其移出内存，以便为即将调⼊的⻚⾯让出空间。⽤来选择淘汰哪⼀⻚的规则叫做⻚⾯置换算法，我们可以把⻚⾯置换算法看成是淘汰⻚⾯的规则。</p>
<ul>
<li><strong>OPT ⻚⾯置换算法（最佳⻚⾯置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰⻚⾯将是以后永不使⽤的，或者是在最⻓时间内不再被访问的⻚⾯,这样可以保证获得最低的缺⻚率。但由于⼈们⽬前⽆法预知进程在内存下的若千⻚⾯中哪个是未来最⻓时间内不再被访问的，因⽽该算法⽆法实现。⼀般作为衡量其他置换算法的⽅法。</li>
<li><strong>FIFO（First In First Out） ⻚⾯置换算法（先进先出⻚⾯置换算法）</strong> : 总是淘汰最先进⼊内存的⻚⾯，即选择在内存中驻留时间最久的⻚⾯进⾏淘汰。</li>
<li><strong>LRU （Least Rently Used）⻚⾯置换算法（最近最久未使⽤⻚⾯置换算法）</strong> ：LRU算法赋予每个⻚⾯⼀个访问字段，⽤来记录⼀个⻚⾯⾃上次被访问以来所经历的时间 T，当须淘汰⼀个⻚⾯时，选择现有⻚⾯中其 T 值最⼤的，即最近最久未使⽤的⻚⾯予以淘汰。</li>
<li><strong>LFU （Least Frequently Used)(最少使⽤⻚⾯置换算法）</strong> : 该置换算法选择在之前时期使⽤最少的⻚⾯作为淘汰⻚。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>虚拟内存</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之内存管理</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢?</p>
<ol>
<li>操作系统负责内存空间的分配与回收。</li>
<li>操作系统需要提供某种技术从逻辑.上对内存空间进行扩充。</li>
<li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。</li>
<li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li>
</ol>
<h3 id="逻辑-虚拟-地址和物理地址"><a href="#逻辑-虚拟-地址和物理地址" class="headerlink" title="逻辑(虚拟)地址和物理地址"></a>逻辑(虚拟)地址和物理地址</h3><p>我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥⾯存储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h2 id="连续分配的块式管理"><a href="#连续分配的块式管理" class="headerlink" title="连续分配的块式管理"></a>连续分配的块式管理</h2><p>远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了。这些在每个块中未被利⽤的空<br>间，我们称之为碎⽚。</p>
<p>连续分配内存有一下几种算法</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应</td>
<td>从头到尾找适合的分区</td>
<td>空闲分区以地址递增次序排列</td>
<td>综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序</td>
<td></td>
</tr>
<tr>
<td>最佳适应</td>
<td>优先使用更小的分区，以保留更多大分区</td>
<td>空闲分区以容量递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片;算法开销大，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td>最坏适应</td>
<td>优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td>空闲分区以容量递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完，不利于大进程;算法开销大(原因同上)</td>
</tr>
<tr>
<td>邻近适应</td>
<td>由首次适应演变而来，每次从上次查找结束位置开始查找</td>
<td>空闲分区以地址递增次序排列(可排列成循环链表)</td>
<td>不用每次都从低地址的小分区开始检索。算法开销小(原因同首次适应算法)</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody></table>
<h2 id="⻚式管理"><a href="#⻚式管理" class="headerlink" title="⻚式管理"></a>⻚式管理</h2><p>如果允许将一个进程分散到许多不连续的空间，就可以避免内存紧缩，减少碎片。基于这一思想，通过引入进程的逻辑地址，把进程地址空间与实际存储空间分离，增加存储管理的灵活性。</p>
<p>把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚较⼩，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过⻚表对应逻辑地址和物理地址。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802150024.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802150024.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802150744.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802150744.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h3 id="快表和多级⻚表"><a href="#快表和多级⻚表" class="headerlink" title="快表和多级⻚表"></a>快表和多级⻚表</h3><p>⻚表管理机制中有两个很重要的概念：快表和多级⻚表，这两个东⻄分别解决了⻚表管理中很重要的两个问题。</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间⼤，⻚表也会很⼤的问题。</li>
</ol>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>为了解决虚拟地址到物理地址的转换速度，操作系统在⻚表⽅案基础之上引⼊了<strong>快表</strong>来加速虚拟地址到物理地址的转换。我们可以把块表理解为⼀种特殊的⾼速缓冲存储器（Cache），其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的 Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储<br>器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。</p>
<p>使⽤快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的⻚号查快表；</li>
<li>如果该⻚在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；</li>
<li>当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使⽤的缓存（⽐如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们⽇常开发使⽤的各种⼯具或者框架中找到它们的影⼦。</p>
<h4 id="多级⻚表"><a href="#多级⻚表" class="headerlink" title="多级⻚表"></a>多级⻚表</h4><p>引⼊多级⻚表的主要⽬的是为了避免把全部⻚表⼀直放在内存中占⽤过多空间，特别是那些根本就不需要的⻚表就不需要保留在内存中。多，多级⻚表属于时间换空间的典型场景。</p>
<p>推荐阅读 <a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">多级页表如何节约内存</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>为了提⾼内存的空间性能，提出了多级⻚表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级⻚表实际上都利⽤到了程序的局部性原理。</p>
<h2 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h2><p>⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意义。段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段 X、数据段 D及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</p>
<h3 id="分⻚机制和分段机制的共同点和区别"><a href="#分⻚机制和分段机制的共同点和区别" class="headerlink" title="分⻚机制和分段机制的共同点和区别"></a>分⻚机制和分段机制的共同点和区别</h3><p>共同点： </p>
<ul>
<li>分⻚机制和分段机制都是为了提⾼内存利⽤率，较少内存碎⽚。</li>
<li>⻚和段都是离散存储的，所以两者都是离散分配内存的⽅式。但是，每个⻚和段中的内存是连续的。</li>
</ul>
<p>不同点：</p>
<ul>
<li>⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏的程序。</li>
<li>分⻚仅仅是为了满⾜操作系统内存管理的需求，⽽段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满⾜⽤户的需要。</li>
</ul>
<h2 id="段⻚式管理"><a href="#段⻚式管理" class="headerlink" title="段⻚式管理"></a>段⻚式管理</h2><p>段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制中段与段之间以及段的内部的都是离散的。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>迪杰斯特拉算法</title>
    <url>/%E7%AE%97%E6%B3%95/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>迪杰斯特拉算法是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。迪杰斯特拉算法采用的是贪心策略，将Graph中的节点集分为最短路径计算完成的节点集S和未计算完成的节点集T，每次将从T中挑选V0-&gt;Vt最小的节点Vt加入S，并更新V0经由Vt到T中剩余节点的更短距离，直到T中的节点全部加入S中，它贪心就贪心在每次都选择一个距离源点最近的节点加入最短路径节点集合。迪杰斯特拉算法只支持非负权图，它计算的是单源最短路径，即单个源点到剩余节点的最短路径，时间复杂度为O(n²)。</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>本节将对算法流程进行模拟，设置Graph为包含7个顶点和9条边的有向无环图，源点为0，计算从源点0到剩余节点的最短路径，Graph如下：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223157.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223157.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>每个节点将维护shortest和visited两个数据结构，shortest存储v0到该节点的最短路径，visited存储v0到该节点的最短路径是否求出。S为已求出最短路径的节点，T为未求出最短路径的节点。源节点只允许将S中的节点作为中间节点来计算到达其它节点的最短路径，不允许将T中的节点作为中间节点来计算到达其它节点的最短路径。随着S中节点的增加，源节点可达的节点才会增加。初始状态下，源节点只可达节点1和节点3。</p>
<p>算法步骤如下：</p>
<ol>
<li>将源节点（即节点0）加入S中，对shortest和visited数组进行更新。<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223404.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223404.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>S中现有节点0，源节点可达T中的节点1和节点3，节点0-&gt;节点1距离为6，节点0-&gt;节点3距离为2，按距离从小到大排序，因此选择将节点3加入S中。更新源点将节点3作为中间节点到达其它节点的距离。<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223448.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223448.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>S中现有节点0和节点3，源节点可达T中的节点1和4，节点0-&gt;节点1距离为6，节点0-&gt;节点4距离为7，按距离从小到大排序，因此选择将节点1加入S中。更新源点将节点1作为中间节点到达其它节点的距离。<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223505.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223505.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>S中现有节点0、1、3，源节点可达T中的节点2、4、5，0-&gt;2距离为11，0-&gt;4距离为7，0-&gt;5距离为9，按距离从小到大排序，因此选择将节点4加入S中。更新源点将节点4作为中间节点到达其它节点的距离。<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223558.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223558.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>S中现有节点0、1、3、4，源节点可达T中的节点2、5、6，0-&gt;2距离为11，0-&gt;5距离为9，0-&gt;6距离为8，按距离从小到大排序，因此选择将节点6加入S中。更新源点将节点6作为中间节点到达其它节点的距离。<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223623.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>S中现有节点0、1、3、4、6，源节点可达T中的节点2、5，0-&gt;2距离为11，0-&gt;5距离为9，按距离从小到大排序，因此选择将节点5加入S中。更新源点将节点5作为中间节点到达其它节点的距离。<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223649.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223649.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>T中只剩下节点2，0-&gt;2距离为11，将节点2加入S中。<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223725.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223725.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li>算法结束，源点到其它节点的最短路径都已依次求出。      <img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223735.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200828223735.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ol>
<h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> source)</span> </span>&#123;
    <span class="hljs-comment">//最短路径长度</span>
    <span class="hljs-keyword">int</span>[] shortest = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix.length];
    <span class="hljs-comment">//判断该点的最短路径是否求出</span>
    <span class="hljs-keyword">int</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix.length];
    <span class="hljs-comment">//存储输出路径</span>
    String[] path = <span class="hljs-keyword">new</span> String[matrix.length];

    <span class="hljs-comment">//初始化输出路径</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;
        path[i] = <span class="hljs-keyword">new</span> String(source + <span class="hljs-string">&quot;-&gt;&quot;</span> + i);
    &#125;

    <span class="hljs-comment">//初始化源节点</span>
    shortest[source] = <span class="hljs-number">0</span>;
    visited[source] = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; matrix.length; i++) &#123;
        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;
        <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix.length; j++) &#123;
            <span class="hljs-comment">//已经求出最短路径的节点不需要再加入计算并判断加入节点后是否存在更短路径</span>
            <span class="hljs-keyword">if</span> (visited[j] == <span class="hljs-number">0</span> &amp;&amp; matrix[source][j] &lt; min) &#123;
                min = matrix[source][j];
                index = j;
            &#125;
        &#125;

        <span class="hljs-comment">//更新最短路径</span>
        shortest[index] = min;
        visited[index] = <span class="hljs-number">1</span>;

        <span class="hljs-comment">//更新从index跳到其它节点的较短路径</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; matrix.length; m++) &#123;
            <span class="hljs-keyword">if</span> (visited[m] == <span class="hljs-number">0</span> &amp;&amp; matrix[source][index] + matrix[index][m] &lt; matrix[source][m]) &#123;
                matrix[source][m] = matrix[source][index] + matrix[index][m];
                path[m] = path[index] + <span class="hljs-string">&quot;-&gt;&quot;</span> + m;
            &#125;
        &#125;

    &#125;

    <span class="hljs-comment">//打印最短路径</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;
        <span class="hljs-keyword">if</span> (i != source) &#123;
            <span class="hljs-keyword">if</span> (shortest[i] == MaxValue) &#123;
                System.out.println(source + <span class="hljs-string">&quot;到&quot;</span> + i + <span class="hljs-string">&quot;不可达&quot;</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                System.out.println(source + <span class="hljs-string">&quot;到&quot;</span> + i + <span class="hljs-string">&quot;的最短路径为：&quot;</span> + path[i] + <span class="hljs-string">&quot;，最短距离是：&quot;</span> + shortest[i]);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>转自：<a href="https://blog.csdn.net/qq_34842671/article/details/90083037">图解最短路径之迪杰斯特拉算法（Java实现）</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>常用查找算法及Java实现</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%8F%8AJava%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p>
<p>顺序查找的时间复杂度为O(n)。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Search</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>&#125;;
        search(arr,<span class="hljs-number">3</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 顺序查找</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">order</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
            <span class="hljs-keyword">if</span> (arr[i] == target) &#123;
                <span class="hljs-keyword">return</span> i;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p>
<p>最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">  * 常规二分查找</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">half</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;
     <span class="hljs-comment">//使数组有序</span>
     Arrays.sort(arr);
     System.out.println(String.format(<span class="hljs-string">&quot;原数组%s中查找【%s】&quot;</span>, Arrays.toString(arr), target));
     <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
     <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">1</span>;
     <span class="hljs-keyword">while</span> (left &lt;= right) &#123;
         <span class="hljs-keyword">int</span> mid = ((right - left) &gt;&gt; <span class="hljs-number">1</span>) + left;
         <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;
             left = mid + <span class="hljs-number">1</span>;
         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; arr[mid]) &#123;
             right = mid - <span class="hljs-number">1</span>;
         &#125; <span class="hljs-keyword">else</span> &#123;
             <span class="hljs-keyword">return</span> mid;
         &#125;
     &#125;
     <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
 &#125;

 <span class="hljs-comment">/**</span>
<span class="hljs-comment">  * 递归二分查找</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@param</span> high len-1</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">halfByRecurse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;
     <span class="hljs-keyword">int</span> mid = ((high - low) &gt;&gt; <span class="hljs-number">1</span>) + low;
     <span class="hljs-keyword">if</span> (low == high) &#123;
         <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
     &#125;
     <span class="hljs-keyword">if</span> (target == arr[mid]) &#123;
         <span class="hljs-keyword">return</span> mid;
     &#125;
     <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;
         <span class="hljs-keyword">return</span> halfByRecurse(arr, target, mid + <span class="hljs-number">1</span>, high);
     &#125;
     <span class="hljs-keyword">if</span> (target &lt; arr[mid]) &#123;
         <span class="hljs-keyword">return</span> halfByRecurse(arr, target, low, mid - <span class="hljs-number">1</span>);
     &#125;
     <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
 &#125;</code></pre>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找<br>代码基本上和二分查找一样，有修改的地方就是mid的获取</p>
<p>在二分查找中$mid=$$low+high \over {2}$   可改写成   $mid =low + $ $   {high-low} \over {2}$</p>
<p>也就是说我们的mid每次都是折中的取，但是对于一些均匀分布的有序表，这样做感觉有些费时，比如找字典的时候，找a这个字母，我们肯定不会从中间开始，而是偏向于字典前面一些开始。</p>
<p>插值查找就是基于这样的思想<br>我们对1/2进行改进:</p>
<p>$mid=low+$$key-a[low] \over a[high]=a[low]$$(high-low)$</p>
<p>key就是要查找的值，数组a是有序表</p>
<p>简单的理解就是计算出key所占比，然后更好地找到key所在的区间范围<br>但是对于极端分布的数组，插值查找的效率就大打折扣了<br>比如</p>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100</span>,<span class="hljs-number">102</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">10000</span>&#125;</code></pre>

<p>Java代码实现</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 插值查找</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;
    <span class="hljs-comment">//使数组有序</span>
    Arrays.sort(arr);
    System.out.println(String.format(<span class="hljs-string">&quot;原数组%s中进行插值查找【%s】&quot;</span>, Arrays.toString(arr), target));
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;
        <span class="hljs-keyword">int</span> mid = left + (right - left) * ((target - arr[left]) / (arr[right] - arr[left]));
        <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;
            left = mid + <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; arr[mid]) &#123;
            right = mid - <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> mid;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 递归插值查找</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> high len-1</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertByRecurse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;
    <span class="hljs-keyword">int</span> mid = low + (high - low) * ((target - arr[low]) / (arr[high] - arr[low]));
    <span class="hljs-keyword">if</span> (low &lt;= high) &#123;
        <span class="hljs-keyword">if</span> (target == arr[mid]) &#123;
            <span class="hljs-keyword">return</span> mid;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;
            <span class="hljs-keyword">return</span> insertByRecurse(arr, target, mid + <span class="hljs-number">1</span>, high);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> insertByRecurse(arr, target, low, mid - <span class="hljs-number">1</span>);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>斐波那契查找原理：<br>该查找原理与二分查找和插值查找类似，仅仅改变中间节点middle位置，middle位置不再是中间或插值得到，而是位于黄金分割点附近，即mid = low + F(k - 1) - 1（F，斐波那契数列）。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200731185612.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200731185612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>F(k-1)-1的说明</p>
<ul>
<li>由斐波那契数列F[k]=F[k-1] + F[k-2]，可以得到F[k]-1=(F[k-1]-1) + (F[k-2]-1)+1。说明只要顺序表的长度为F[k]-1，则可以-将顺序表分成长度为F[k-1]-1和F[k-2]-1的两段，即中间位置为：mid=low+F[k-1]-1。</li>
<li>类似的每个字段也可以用相同的方式进行分割。</li>
<li>可能顺序表长度n不一定等于F[k]-1，需要将原来的顺序表长度n增加至F[k]-1。（k值只要使得F[k]-1大于或等于n）。</li>
</ul>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/31 19:00</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibonacciSearch</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">89</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1234</span>&#125;;
        <span class="hljs-keyword">int</span> index = fibonacciSearch(array, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span>(-<span class="hljs-number">1</span> == index) &#123;
            System.err.println(<span class="hljs-string">&quot;没有找到&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">&quot;找到，位置：&quot;</span> + index);
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 斐波那契查找</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fibonacciSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> key)</span> </span>&#123;
        <span class="hljs-keyword">int</span> length = array.length;
        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> high = length - <span class="hljs-number">1</span>;
        <span class="hljs-comment">// 斐波那契分割数的索引</span>
        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 找到有序表元素个数在斐波那契数列中最接近的最大数列值</span>
        <span class="hljs-keyword">while</span>(high &gt; (fibonacci(k) - <span class="hljs-number">1</span>)) &#123;
            k++;
        &#125;
        <span class="hljs-comment">// 补齐有序表</span>
        <span class="hljs-keyword">int</span> [] tmpArray = Arrays.copyOf(array, fibonacci(k));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = length; i &lt; tmpArray.length; i++) &#123;
            tmpArray[i] = array[high];
        &#125;
        <span class="hljs-keyword">while</span>(low &lt;= high) &#123;
            mid = low + fibonacci(k - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;
            <span class="hljs-comment">// 查找值小于中值，在小的那一部分继续查找</span>
            <span class="hljs-keyword">if</span>(key &lt; tmpArray[mid]) &#123;
                high = mid - <span class="hljs-number">1</span>;
                k--;
            &#125;
            <span class="hljs-comment">// 查找值大于中值，在大的那一部分继续查找</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; tmpArray[mid]) &#123;
                low = mid + <span class="hljs-number">1</span>;
                k -= <span class="hljs-number">2</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// 可能存在补齐列表</span>
                <span class="hljs-keyword">return</span> Math.min(mid, high);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 动态规划实现斐波那契数列</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n /</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">return</span> n;
        &#125;
        <span class="hljs-keyword">int</span> pre1 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> total = pre1 + pre2;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;
            total = pre1 + pre2;
            pre1 = pre2;
            pre2 = total;
        &#125;
        <span class="hljs-keyword">return</span> total;
    &#125;

&#125;</code></pre>

<h2 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h2><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 </p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802100348.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802100348.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>对二叉查找树进行中序遍历即可得到一个有序的列表。</p>
<p>对这个方面还有升级版本的红黑树，来保证平衡</p>
<h3 id="平衡查找树之2-3查找树（2-3-Tree）"><a href="#平衡查找树之2-3查找树（2-3-Tree）" class="headerlink" title="平衡查找树之2-3查找树（2-3 Tree）"></a>平衡查找树之2-3查找树（2-3 Tree）</h3><p>和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key。</p>
<p>2-3查找树的定义如下：</p>
<ol>
<li>要么为空，要么：</li>
<li>对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。</li>
<li>对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802102126.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200802102126.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</p>
<blockquote>
<p>算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……</p>
</blockquote>
<p>算法流程：</p>
<ol>
<li>先选取各块中的最大关键字构成一个索引表；</li>
<li>查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</li>
</ol>
<h2 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h2><p>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。</p>
<p>总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用排序算法及Java实现</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AJava%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<p>选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">   * 选择排序</span>
<span class="hljs-comment">   *</span>
<span class="hljs-comment">   * <span class="hljs-doctag">@param</span> arr /</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selection</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
      <span class="hljs-keyword">int</span> len = arr.length;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;
          <span class="hljs-keyword">int</span> min = i;
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;
              <span class="hljs-keyword">if</span> (arr[min] &gt; arr[j]) &#123;
                  min = j;
              &#125;
          &#125;
          <span class="hljs-keyword">if</span>(i!=min)&#123;
              swap(arr, i, min);
          &#125;
      &#125;
      System.out.println(Arrays.toString(arr));
  &#125;</code></pre>


<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 冒泡排序</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubble</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
        <span class="hljs-keyword">int</span> len = arr.length;
        <span class="hljs-keyword">boolean</span> sorted = <span class="hljs-keyword">false</span>;
        <span class="hljs-comment">//一轮下来都没有发生交换，则已经有序了</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span> &amp;&amp; !sorted; i--) &#123;
            sorted = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;
                <span class="hljs-keyword">if</span> (arr[j + <span class="hljs-number">1</span>] &lt; arr[j]) &#123;
                    sorted = <span class="hljs-keyword">false</span>;
                    swap(arr, i, j);
                &#125;
            &#125;
        &#125;
        System.out.println(<span class="hljs-string">&quot;冒泡排序结果：&quot;</span> + Arrays.toString(arr));
    &#125;</code></pre>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><p>每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。</p>
<p>算法实现：直接插入排序是将无序序列中的数据插入到有序的序列中，在遍历无序序列时，首先拿无序序列中的首元素去与有序序列中的每一个元素比较并插入到合适的位置，一直到无序序列中的所有元素插完为止。对于一个无序序列arr{4，6，8，5，9}来说，我们首先先确定首元素4是有序的，然后在无序序列中向右遍历，6大于4则它插入到4的后面，再继续遍历到8，8大于6则插入到6的后面，这样继续直到得到有序序列{4，5，6，8，9}。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730102535.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730102535.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
    <span class="hljs-keyword">int</span> len = arr.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;
        <span class="hljs-comment">//arr[j] &lt; arr[j - 1] 如果比最后一个都大那就不用排了</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]; j--) &#123;
                swap(arr, j - <span class="hljs-number">1</span>, j);
        &#125;
    &#125;
    System.out.println(<span class="hljs-string">&quot;插入排序结果：&quot;</span> + Arrays.toString(arr));
&#125;</code></pre>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h4><p>希尔排序是把序列按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量的逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个序列恰好被分为一组，算法便终止。</p>
<p>算法实现：希尔排序需要定义一个增量，这里选择增量为gap=length/2，缩小增量以gap=gap/2的方式，这个增量可以用一个序列来表示，{n/2,(n/2)/2….1}，称为增量序列，这个增量是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。</p>
<p>也可以采用一种更复杂的增量序列</p>
<pre><code class="hljs java"><span class="hljs-comment">// 1, 4, 13, 40, ...</span>
<span class="hljs-keyword">while</span> (h &lt; lengh / <span class="hljs-number">3</span>) &#123;
            h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>; 
&#125;</code></pre>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shell</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
       <span class="hljs-keyword">int</span> len = arr.length;
       <span class="hljs-keyword">int</span> gap = <span class="hljs-number">1</span>;
       <span class="hljs-comment">//找到合适的间隙</span>
       <span class="hljs-keyword">while</span> (gap &lt; len / <span class="hljs-number">3</span>) &#123;
           gap = gap * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;
       &#125;
       <span class="hljs-keyword">while</span> (gap &gt;= <span class="hljs-number">1</span>) &#123;
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; len; i++) &#123;
               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= gap &amp;&amp; arr[j] &lt; arr[j - gap]; j -= gap) &#123;
                   swap(arr, j - gap, j);
               &#125;
           &#125;
           gap /= <span class="hljs-number">3</span>;
       &#125;
       System.out.println(<span class="hljs-string">&quot;希尔排序结果：&quot;</span> + Arrays.toString(arr));
   &#125;</code></pre>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h4><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>算法步骤</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730134757.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730134757.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730134721.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730134721.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>&#125;;
    mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
    System.out.println(<span class="hljs-string">&quot;归并排序结果：&quot;</span> + Arrays.toString(arr));
&#125;
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 归并排序(治)</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> middle, <span class="hljs-keyword">int</span> high)</span> </span>&#123;
    <span class="hljs-keyword">int</span>[] tmpArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[high - low + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> left = low;
    <span class="hljs-keyword">int</span> right = middle + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//左边或者右边的拷贝完了，则不再比较</span>
    <span class="hljs-keyword">while</span> (left &lt;= middle &amp;&amp; right &lt;= high) &#123;
        <span class="hljs-keyword">if</span> (arr[left] &lt; arr[right]) &#123;
            tmpArray[index++] = arr[left++];
        &#125; <span class="hljs-keyword">else</span> &#123;
            tmpArray[index++] = arr[right++];
        &#125;
    &#125;
    <span class="hljs-comment">//如果是左边的剩下了</span>
    <span class="hljs-keyword">if</span> (left &lt;= middle) &#123;
        System.arraycopy(arr, left, tmpArray, index, middle - left + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-comment">//如果是右边的剩下了</span>
    <span class="hljs-keyword">if</span> (right &lt;= high) &#123;
        System.arraycopy(arr, right, tmpArray, index, high - right + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-keyword">if</span> (tmpArray.length &gt;= <span class="hljs-number">0</span>) &#123;
        System.arraycopy(tmpArray, <span class="hljs-number">0</span>, arr, low, tmpArray.length);
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 归并排序(分) 自顶向上</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;
    <span class="hljs-comment">//分 完成</span>
    <span class="hljs-keyword">if</span> (low &gt;= high) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">int</span> middle = ((high - low) &gt;&gt; <span class="hljs-number">1</span>) + low;
    mergeSort(arr, low, middle);
    mergeSort(arr, middle + <span class="hljs-number">1</span>, high);
    merge(arr, low, middle, high);
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 归并排序(分) 自底向上</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
    <span class="hljs-keyword">int</span> len = arr.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> size = <span class="hljs-number">1</span>; size &lt; len; size += size) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - size; i += size + size) &#123;
            merge(arr, i, i + size - <span class="hljs-number">1</span>, Math.min(i + size + size - <span class="hljs-number">1</span>, len-<span class="hljs-number">1</span>));
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h4><p>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730180732.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730180732.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (low &lt; high) &#123;
        <span class="hljs-keyword">int</span> partition = partition(arr, low, high);
        sort(arr, low, partition);
        sort(arr, partition + <span class="hljs-number">1</span>, high);
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 切分</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;
    <span class="hljs-keyword">int</span> index = low + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt;= high; i++) &#123;
        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[low]) &#123;
            swap(arr, index++, i);
        &#125;
    &#125;
    swap(arr, --index, low);
    <span class="hljs-keyword">return</span> index;
&#125;
</code></pre>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。</p>
<p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p>
<p><strong>构建堆</strong></p>
<p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。</p>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/30 18:19</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">88</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">19</span>&#125;;
        sort(arr);
        System.out.println(Arrays.toString(arr));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
        <span class="hljs-keyword">int</span> len = arr.length;
        buildHeap(arr, len);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;
            <span class="hljs-comment">//首尾交换</span>
            swap(arr, <span class="hljs-number">0</span>, i);
            <span class="hljs-comment">//重新维护堆性质</span>
            heapify(arr, <span class="hljs-number">0</span>, --len);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">2</span>; i++) &#123;
            heapify(arr, i, len);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> len)</span> </span>&#123;
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> max = index;
        <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[max]) &#123;
            max = left;
        &#125;
        <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[max]) &#123;
            max = right;
        &#125;
        <span class="hljs-keyword">if</span> (max != index) &#123;
            swap(arr, max, index);
            heapify(arr, max, len);
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 交换</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr   数组</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> self  自身</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> other 另一个</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> self, <span class="hljs-keyword">int</span> other)</span> </span>&#123;
        <span class="hljs-keyword">int</span> tmp = arr[self];
        arr[self] = arr[other];
        arr[other] = tmp;
    &#125;
&#125;</code></pre>

<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h4><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p> 算法的步骤如下：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ol>
<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 计数排序</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/30 19:01</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountSort</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>&#125;;
        sort(arr);
        System.out.println(Arrays.toString(arr));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
        <span class="hljs-comment">//找出最大值</span>
        OptionalInt optionalInt = Arrays.stream(arr).max();
        <span class="hljs-keyword">if</span> (optionalInt.isPresent()) &#123;
            <span class="hljs-keyword">int</span> max = optionalInt.getAsInt();
            <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : arr) &#123;
                bucket[v] += <span class="hljs-number">1</span>;
            &#125;
            <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;
                <span class="hljs-keyword">while</span> (bucket[i] &gt; <span class="hljs-number">0</span>) &#123;
                    bucket[i] -= <span class="hljs-number">1</span>;
                    arr[index++] = i;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="算法思想-8"><a href="#算法思想-8" class="headerlink" title="算法思想"></a>算法思想</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<p>在额外空间充足的情况下，尽量增大桶的数量<br>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730191734.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730191734.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4> <pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/30 19:35</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BucketSort</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>&#125;;
        sort(arr, <span class="hljs-number">5</span>);
        System.out.println(Arrays.toString(arr));
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> bucketSize)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">int</span> minValue = arr[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;
            <span class="hljs-keyword">if</span> (value &lt; minValue) &#123;
                minValue = value;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; maxValue) &#123;
                maxValue = value;
            &#125;
        &#125;
        <span class="hljs-keyword">int</span> bucketCount = (maxValue - minValue) / bucketSize + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketCount][<span class="hljs-number">0</span>];
        <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> item : arr) &#123;
            <span class="hljs-keyword">int</span> index = (item - minValue) / bucketSize;
            buckets[index] = arrAppend(buckets[index], item);
        &#125;
        <span class="hljs-keyword">int</span> arrIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : buckets) &#123;
            <span class="hljs-keyword">if</span> (bucket.length &lt;= <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-comment">// 对每个桶进行排序，这里使用了归并排序</span>
            MergeSort.sort(bucket);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;
                arr[arrIndex++] = value;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 自动扩容，并保存数据</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] arrAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;
        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);
        arr[arr.length - <span class="hljs-number">1</span>] = value;
        <span class="hljs-keyword">return</span> arr;
    &#125;
&#125;</code></pre>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="算法思想-9"><a href="#算法思想-9" class="headerlink" title="算法思想"></a>算法思想</h4><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>基数排序有两种方法：</p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730195537.gif" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730195537.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 基数排序</span>
<span class="hljs-comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>&#125;;
        sort(arr);
        System.out.println(Arrays.toString(arr));
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] arr) &#123;
        <span class="hljs-keyword">int</span> maxDigit = getMaxDigit(arr);
        <span class="hljs-keyword">return</span> radixSort(arr, maxDigit);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 获取最高位数</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
        <span class="hljs-keyword">int</span> maxValue = getMaxValue(arr);
        <span class="hljs-keyword">return</span> getNumLength(maxValue);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;
        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;
            <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;
                maxValue = value;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> maxValue;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumLength</span><span class="hljs-params">(<span class="hljs-keyword">long</span> num)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">int</span> lenght = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> temp = num; temp != <span class="hljs-number">0</span>; temp /= <span class="hljs-number">10</span>) &#123;
            lenght++;
        &#125;
        <span class="hljs-keyword">return</span> lenght;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] radixSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> maxDigit) &#123;
        <span class="hljs-keyword">int</span> mod = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> dev = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;
            <span class="hljs-comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span>
            <span class="hljs-keyword">int</span>[][] counter = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mod * <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;
                <span class="hljs-keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;
                counter[bucket] = arrayAppend(counter[bucket], arr[j]);
            &#125;

            <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : counter) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;
                    arr[pos++] = value;
                &#125;
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> arr;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 自动扩容，并保存数据</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] arrayAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;
        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);
        arr[arr.length - <span class="hljs-number">1</span>] = value;
        <span class="hljs-keyword">return</span> arr;
    &#125;
&#125;</code></pre>

<h2 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730191438.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730191438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730191521.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200730191521.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/w3cnote/counting-sort.html">十大经典排序算法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之进程调度算法</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。<br>这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729212706.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729212706.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h3><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，<br>每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪<br>队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。<br>该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p>
<p>执行时间与调度之后执行顺序：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213057.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213057.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213109.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213109.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" />

<h3 id="短作业优先-SJF-的调度算法"><a href="#短作业优先-SJF-的调度算法" class="headerlink" title="短作业优先(SJF)的调度算法"></a>短作业优先(SJF)的调度算法</h3><p>从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213319.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213319.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="时间⽚轮转调度算法"><a href="#时间⽚轮转调度算法" class="headerlink" title="时间⽚轮转调度算法"></a>时间⽚轮转调度算法</h3><p> 时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜称 RR(Round robin)调度。每个进程被分配⼀个时间段，称作它的时间⽚，即该进程允许运⾏的时间。</p>
<p>时间片为4，到期后切换下一个进程：<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213336.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213336.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</p>
<p>多级反馈队列调度算法的实现思想如下：</p>
<ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</li>
<li>赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。</li>
<li>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</li>
<li>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</li>
</ol>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以 FCFS ⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先级</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213232.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729213232.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>​ 根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间）</p>
<p>　　如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。</p>
<p>​ 高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>
<p>根据公式可知：</p>
<ul>
<li>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。</li>
<li>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</li>
<li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</li>
</ul>
<h3 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h3><p>​ 最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之进程通讯IPC</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AFIPC.html</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）</p>
<h2 id="进程通讯的七种方式"><a href="#进程通讯的七种方式" class="headerlink" title="进程通讯的七种方式"></a>进程通讯的七种方式</h2><h3 id="管道-匿名管道-Pipes"><a href="#管道-匿名管道-Pipes" class="headerlink" title="管道/匿名管道(Pipes)"></a>管道/匿名管道(Pipes)</h3><h4 id="一句话介绍"><a href="#一句话介绍" class="headerlink" title="一句话介绍"></a>一句话介绍</h4><p>大白话来说，就是只能在父子间单向传递数据的方式，数据放在内核缓冲区，像FIFO的方式循环队列来存取。管道单独构成一种文件系统，并且只存在与内存中。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</li>
<li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</li>
<li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li>
<li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729180343.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729180343.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul>
<li>只支持单向数据流；</li>
<li>只能用于具有亲缘关系的进程之间；</li>
<li>没有名字；</li>
<li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<h3 id="有名管道-Names-Pipes"><a href="#有名管道-Names-Pipes" class="headerlink" title="有名管道(Names Pipes)"></a>有名管道(Names Pipes)</h3><h4 id="一句话介绍-1"><a href="#一句话介绍-1" class="headerlink" title="一句话介绍"></a>一句话介绍</h4><p>与匿名管道一样，但是存在有一个名字，这个名字就是文件路径，存在于文件系统中，但是内容还是在内存，这样就可以非父子进程通信了。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。<br>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。</p>
<h4 id="匿名管道和有名管道总结"><a href="#匿名管道和有名管道总结" class="headerlink" title="匿名管道和有名管道总结"></a>匿名管道和有名管道总结</h4><p>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br>（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br>（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br>（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。<br>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。<br>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p>
<p>SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。</p>
<h3 id="消息队列-Message-Queuing"><a href="#消息队列-Message-Queuing" class="headerlink" title="消息队列(Message Queuing)"></a>消息队列(Message Queuing)</h3><ul>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li>
<li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.</li>
<li>消息队列允许一个或多个进程向它写入与读取消息.</li>
<li>管道和消息队列的通信数据都是先进先出的原则。</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</li>
<li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ol>
<h3 id="信号量-Semaphores"><a href="#信号量-Semaphores" class="headerlink" title="信号量(Semaphores)"></a>信号量(Semaphores)</h3><h4 id="一句话介绍-2"><a href="#一句话介绍-2" class="headerlink" title="一句话介绍"></a>一句话介绍</h4><p>信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</p>
<h4 id="实际过程"><a href="#实际过程" class="headerlink" title="实际过程"></a>实际过程</h4><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p>
<p>为了获得共享资源，进程需要执行下列操作：</p>
<ol>
<li>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li>
<li>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li>
<li>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li>
</ol>
<p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。</p>
<h4 id="信号量与普通整型变量的区别"><a href="#信号量与普通整型变量的区别" class="headerlink" title="信号量与普通整型变量的区别"></a>信号量与普通整型变量的区别</h4><ol>
<li>信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；</li>
<li>操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</li>
</ol>
<h4 id="信号量与互斥量之间的区别："><a href="#信号量与互斥量之间的区别：" class="headerlink" title="信号量与互斥量之间的区别："></a>信号量与互斥量之间的区别：</h4><ol>
<li>互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</li>
</ol>
<p><strong>互斥</strong>：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br><strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br>2. 互斥量值只能为0/1，信号量值可以为非负整数。<br>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br>3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p>
<h3 id="共享内存-Shared-memory"><a href="#共享内存-Shared-memory" class="headerlink" title="共享内存(Shared memory)"></a>共享内存(Shared memory)</h3><ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729205724.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729205724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="套接字-Sockets"><a href="#套接字-Sockets" class="headerlink" title="套接字(Sockets)"></a>套接字(Sockets)</h3><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729211212.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729211212.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程通讯</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS(深度优先)与BFS(广度优先)算法</title>
    <url>/%E7%AE%97%E6%B3%95/DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88-%E4%B8%8EBFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88-%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>BFS（广度优先遍历，Breadth First Search）及DFS（深度优先遍历，Depth First Search）是遍历树或图的两种最常用的方法。</p>
<h2 id="深度优先算法"><a href="#深度优先算法" class="headerlink" title="深度优先算法"></a>深度优先算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>深度优先算法是从起始顶点开始，递归访问其所有邻近节点，比如A节点是其第一个邻近节点，而B节点又是A的一个邻近节点，则DFS访问A节点后再访问B节点，如果B节点有未访问的邻近节点的话将继续访问其邻近节点，否则继续访问A的未访问邻近节点，当所有从A节点出去的路径都访问完之后，继续递归访问除A以外未被访问的邻近节点。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729162431.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729162431.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><p>可以用递归和栈实现，时间复杂度为O(N)。</p>
<pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DFS</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;
        TreeNode left;
        TreeNode right;
        <span class="hljs-keyword">int</span> data;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
            <span class="hljs-keyword">this</span>.data = data;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(-<span class="hljs-number">1</span>);
        root.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">10</span>);
        root.right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">5</span>);
        root.right.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">2</span>);
        root.left.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>);
        root.left.left.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">4</span>);
        dfsByRecursion(root);
        dfsByStack(root);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 递归实现DFS</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 树节点</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfsByRecursion</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;
            System.out.println(node.data);
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;
                dfsByRecursion(node.left);
            &#125;
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;
                dfsByRecursion(node.right);
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 栈实现</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 节点</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfsByStack</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;
        Stack&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        nodes.push(node);
        <span class="hljs-keyword">while</span> (!nodes.isEmpty()) &#123;
            TreeNode treeNode = nodes.pop();
            System.out.println(treeNode.data);
            <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-keyword">null</span>) &#123;
                nodes.push(treeNode.right);
            &#125;
            <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-keyword">null</span>) &#123;
                nodes.push(treeNode.left);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-comment">//-1，10，3，4，5，2</span>
</code></pre>
<h2 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>其主要思想是从起始点开始，将其邻近的所有顶点都加到一个队列（FIFO）中去，然后标记下这些顶点离起始顶点的距离为1.最后将起始顶点标记为已访问，今后就不会再访问。然后再从队列中取出最先进队的顶点A，也取出其周边邻近节点，加入队列末尾，最后离开这个顶点A。依次下去，直到队列为空为止。从上面描述的过程我们知道每个顶点被访问的次数最多一次（已访问的节点不会再访问）。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729165242.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729165242.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h3><p>通过队列实现，其中树节点和测试数据和DFS一样。时间复杂度为O(N)。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 队列实现 BFS</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 节点</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfsByQueue</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    queue.add(node);
    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        TreeNode treeNode = queue.poll();
        System.out.println(treeNode.data);
        <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-keyword">null</span>) &#123;
            queue.add(treeNode.left);
        &#125;
        <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-keyword">null</span>) &#123;
            queue.add(treeNode.right);
        &#125;
    &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之图</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE.html</url>
    <content><![CDATA[<h2 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h2><p>在计算机科学中，一个图就是一些顶点的集合，这些顶点通过一系列边结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729142926.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729142926.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h2><p>在图中，最基本的单元是顶点（vertex），相当于树中的节点。顶点之间的关联关系，被称为边（edge）。</p>
<p>在有些图中，每一条边并不是完全等同的。比如刚才地铁线路的例子，从A站到B站的距离是3公里，从B站到C站的距离是5公里……这样就引入一个新概念：边的权重（Weight）。涉及到权重的图，被称为带权图（Weighted Graph）。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145508.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145508.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>拥有n个顶点的图，它所包含的连接数量最多是n（n-1）个。因此，要表达各个顶点之间的关联关系，最清晰易懂的方式是使用二维数组（矩阵）。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145615.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145615.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="邻接表和逆邻接表"><a href="#邻接表和逆邻接表" class="headerlink" title="邻接表和逆邻接表"></a>邻接表和逆邻接表</h3><p>为了解决邻接矩阵占用空间的问题，人们想到了另一种图的表示方法：邻接表。在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145641.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145641.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>十字链表的每一个顶点，都是两个链表的根节点，其中一个链表存储着该顶点能到达的相邻顶点，另一个链表存储着能到达该顶点的相邻节点。<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145737.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145737.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<p>我们没有必要把链表的节点都重复存储两次。在优化之后的十字链表中，链表的每一个节点不再是顶点，而是一条边，里面包含起止顶点的下标。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145857.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729145857.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>根据图的边是否有方向，可分为有向图和无向图。根据图的边是否有权重，可分为带权图和无权图。当然，也可以把两个维度结合起来描述，比如有向带权图，无向无权图等等。</p>
</li>
<li><p>图的表示方法有很多种。包括邻接矩阵、邻接表、逆邻接表、十字链表（还有一种邻接多重表，有兴趣的小伙伴可以自学下）。</p>
</li>
</ol>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://baijiahao.baidu.com/s?id=1629054934725051961">漫画：为什么你需要了解数据结构中的图？</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>邻接矩阵</tag>
        <tag>十字链表</tag>
        <tag>邻接表和逆邻接表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之堆Heap</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86Heap.html</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。<br>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树。</li>
</ul>
<p>图一为最大堆，图二为最小堆】</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727181837.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727181837.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="堆的存储结构"><a href="#堆的存储结构" class="headerlink" title="堆的存储结构"></a>堆的存储结构</h2><ol>
<li>根节点位置：根节点的数据总是在数组的位置[0]</li>
<li>节点的父节点位置：假设一个非根节点的数据在数组中的位置[i]，那么它的父节点总是在位置[(i-1)/2]</li>
<li>节点的孩子节点位置：假设一个节点的数据在数组中的位置为[i]，那么它的孩子（如果有）总是在下面的这两个位置：左孩子在[2 * i+1]，右孩子在[2 * i+2]</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727205126.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727205126.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="堆的一些操作"><a href="#堆的一些操作" class="headerlink" title="堆的一些操作"></a>堆的一些操作</h2><h3 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h3><ol>
<li>将新元素增加到堆的末尾</li>
<li>按照优先顺序，将新元素与其父节点比较，如果新元素小于父节点则将两者交换位置。</li>
<li>不断进行第2步操作，直到不需要交换新元素和父节点，或者达到堆顶则插入成功</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727205755.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727205755.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="删除根过程"><a href="#删除根过程" class="headerlink" title="删除根过程"></a>删除根过程</h3><p>堆的删除操作与插入操作相反，插入操作从下往上调整堆，而删除操作则从上往下调整堆。</p>
<ol>
<li>删除堆顶元素（通常是将堆顶元素放置在数组的末尾）</li>
<li>比较左右子节点，将小的元素上调。</li>
<li>不断进行步骤2，直到不需要调整或者调整到堆底。</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727210241.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727210241.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h3 id="Java实现堆"><a href="#Java实现堆" class="headerlink" title="Java实现堆"></a>Java实现堆</h3><ol>
<li>大根堆<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/27 22:15</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigHeap</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] data;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BigHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];
        Arrays.fill(<span class="hljs-keyword">this</span>.data, -<span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.data[size] = node;
        <span class="hljs-keyword">int</span> currentIndex = size++;
        <span class="hljs-keyword">while</span> (currentIndex &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">int</span> parentIndex = (currentIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
            <span class="hljs-comment">//如果这个节点比父节点小</span>
            <span class="hljs-keyword">if</span> (data[currentIndex] &gt; data[parentIndex]) &#123;
                swap(currentIndex, parentIndex);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            currentIndex = parentIndex;
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> Arrays.toString(data);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 删除根</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 根</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteRoot</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//堆尾元素放到根</span>
        <span class="hljs-keyword">int</span> root = data[<span class="hljs-number">0</span>];
        data[<span class="hljs-number">0</span>] = data[--size];
        data[size] = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> currentIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (; ; ) &#123;
            <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">2</span> * currentIndex + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">int</span> rightIndex = <span class="hljs-number">2</span> * currentIndex + <span class="hljs-number">2</span>;
            <span class="hljs-comment">//已经没有子节点了</span>
            <span class="hljs-keyword">if</span> (leftIndex &gt; size) &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-comment">//如果有右子节点，并且大于左子节点</span>
            <span class="hljs-keyword">if</span> (rightIndex &lt; size &amp;&amp; data[rightIndex] &gt; data[leftIndex]) &#123;
                leftIndex = rightIndex;
            &#125;
            <span class="hljs-keyword">if</span> (data[leftIndex] &gt; data[currentIndex]) &#123;
                swap(leftIndex, currentIndex);
            &#125;  <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            currentIndex = leftIndex;
        &#125;
        <span class="hljs-keyword">return</span> root;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to)</span> </span>&#123;
        <span class="hljs-keyword">int</span> tmp = data[from];
        data[from] = data[to];
        data[to] = tmp;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        BigHeap heap = <span class="hljs-keyword">new</span> BigHeap(<span class="hljs-number">10</span>);
        heap.add(<span class="hljs-number">88</span>);
        heap.add(<span class="hljs-number">11</span>);
        heap.add(<span class="hljs-number">22</span>);
        heap.add(<span class="hljs-number">3</span>);
        heap.add(<span class="hljs-number">5</span>);
        heap.add(<span class="hljs-number">1</span>);
        heap.add(<span class="hljs-number">19</span>);
        System.out.println(heap.deleteRoot());
        System.out.println(heap);
    &#125;
&#125;</code></pre></li>
<li>小根堆<br>修改增加删除方法<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.data[size] = node;
    <span class="hljs-keyword">int</span> currentIndex = size++;
    <span class="hljs-keyword">while</span> (currentIndex &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">int</span> parentIndex = (currentIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        <span class="hljs-comment">//如果这个节点比父节点小</span>
        <span class="hljs-keyword">if</span> (data[currentIndex] &lt; data[parentIndex]) &#123;
            swap(currentIndex, parentIndex);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        currentIndex = parentIndex;
    &#125;
&#125;

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> Arrays.toString(data);
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 删除根</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 根</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteRoot</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">//堆尾元素放到根</span>
    <span class="hljs-keyword">int</span> root = data[<span class="hljs-number">0</span>];
    data[<span class="hljs-number">0</span>] = data[--size];
    data[size] = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> currentIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (; ; ) &#123;
        <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">2</span> * currentIndex + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> rightIndex = <span class="hljs-number">2</span> * currentIndex + <span class="hljs-number">2</span>;
        <span class="hljs-comment">//已经没有子节点了</span>
        <span class="hljs-keyword">if</span> (leftIndex &gt; size) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-comment">//如果有右子节点，并且小于左子节点</span>
        <span class="hljs-keyword">if</span> (rightIndex &lt; size &amp;&amp; data[rightIndex] &lt; data[leftIndex]) &#123;
            leftIndex = rightIndex;
        &#125;
        <span class="hljs-keyword">if</span> (data[leftIndex] &lt; data[currentIndex]) &#123;
            swap(leftIndex, currentIndex);
            currentIndex = leftIndex;
        &#125;  <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;</code></pre>

</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/u013728021/article/details/84034420">数据结构-堆和堆的Java实现</a></li>
<li><a href="https://blog.csdn.net/qq_33186366/article/details/51876191">数据结构之堆的定义</a></li>
<li><a href="https://blog.csdn.net/tuke_tuke/article/details/50357939">数据结构-堆的实现</a>+</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>堆</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之树Tree</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91Tree.html</url>
    <content><![CDATA[<h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><p>树状图是一种数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个结点有零个或多个子结点；</li>
<li>没有父结点的结点称为根结点；</li>
<li>每一个非根结点有且只有一个父结点；</li>
<li>除了根结点外，每个子结点可以分为多个不相交的子树</li>
</ul>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>⼀个⼆叉树，如果每⼀个层的结点数都达到最⼤值，则这个⼆叉树就是满⼆叉树。也就是说，如果⼀个⼆叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满⼆叉树。</p>
<ol>
<li>一个层数为k 的满二叉树总结点数为：。因此满二叉树的结点数一定是奇数个。</li>
<li>第i层上的结点数为：</li>
<li>一个层数为k的满二叉树的叶子结点个数（也就是最后一层）：2^(k-1)<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727175930.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727175930.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ol>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p>
<ul>
<li>如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树；</li>
<li>如果遇到一个结点，左孩子不为空，右孩子为空；或者左右孩子都为空；则该节点之后的队列中的结点都为叶子节点；该树才是完全二叉树，否则就不是完全二叉树；<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727175717.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200727175717.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ul>
<h2 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h2><p>也叫二叉搜索树、二叉排序树。<br>⼆叉查找树的特点：</p>
<ol>
<li>若任意节点的左⼦树不空，则左⼦树上所有结点的 值均⼩于它的根结点的值；</li>
<li>若任意节点的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；</li>
<li>任意节点的左、右⼦树也分别为⼆叉查找树；</li>
<li>没有键值相等的节点（no duplicate nodes）。</li>
</ol>
<p>顺序表做储存的二叉查找树：<br>  按数组下标进行存储，根节点存储在下标0处，其左孩子存储于下标2 * 0 + 1，右孩子存储于下标2 * 0 + 2 …依次类推。<br> 下标为i的节点，左右孩子存储于下标<strong>2 * i + 1</strong>与<strong>2 * i + 2</strong></p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200728142206.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200728142206.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="平衡⼆叉树（Self-balancing-binary-search-tree）"><a href="#平衡⼆叉树（Self-balancing-binary-search-tree）" class="headerlink" title="平衡⼆叉树（Self-balancing binary search tree）"></a>平衡⼆叉树（Self-balancing binary search tree）</h2><p>平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200728164018.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200728164018.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>推荐阅读：<a href="https://baijiahao.baidu.com/s?id=1646617486319372351&wfr=spider&for=pc">一文读懂平衡二叉树</a></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ol>
<li>每个节点⾮红即⿊；</li>
<li>根节点总是⿊⾊的；</li>
<li>每个叶⼦节点都是⿊⾊的空节点（NIL节点）；</li>
<li>如果节点是红⾊的，则它的⼦节点必须是⿊⾊的（反之不⼀定）；</li>
<li>从根节点到叶节点或空⼦节点的每条路径，必须包含相同数⽬的⿊⾊节点（即相同的⿊⾊⾼度）。</li>
</ol>
<p><strong>为什么要⽤红⿊树？</strong><br>简单来说红⿊树就是为了解决⼆叉查找树的缺陷，因为⼆叉查找树在某些情况下会退化成⼀个线性结<br>构。</p>
<p>推荐阅读：</p>
<ol>
<li><a href="https://juejin.im/post/5a27c6946fb9a04509096248">漫画：什么是红黑树？</a></li>
<li><a href="https://blog.csdn.net/stven_king/article/details/79605370">红黑树的操作揭秘手册</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24367771">红黑树深入剖析及Java实现</a></li>
</ol>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p> 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
 <img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729095502.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729095502.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>推荐阅读：<a href="https://juejin.im/post/5e9ffe2851882573937a0656">漫画：什么是 “哈夫曼树” ？</a><br>推荐阅读：<a href="https://blog.csdn.net/qq_42623428/article/details/84074845">数据结构——树——哈夫曼树</a></p>
<h2 id="B树（B-树）"><a href="#B树（B-树）" class="headerlink" title="B树（B-树）"></a>B树（B-树）</h2><h3 id="B树性质"><a href="#B树性质" class="headerlink" title="B树性质"></a>B树性质</h3><ol>
<li>根结点至少有两个子女；</li>
<li>每个非根节点所包含的关键字个数 j 满足：(m/2) - 1 &lt;= j &lt;= m - 1；</li>
<li>除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：(m/2) &lt;= k &lt;= m ；</li>
<li>所有的叶子结点都位于同一层。</li>
</ol>
<h3 id="B树特点"><a href="#B树特点" class="headerlink" title="B树特点"></a>B树特点</h3><ol>
<li>B-tree是一种多路搜索树（并不是二叉的），对于一棵M阶树：</li>
<li>定义任意非叶子结点最多只有M个孩子；且M&gt;2；</li>
<li>根结点的孩子数为[2, M]，除非根结点为叶子节点；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>每个非叶子结点存放至少M/2-1（取上整）和至多M-1个关键字；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729085242.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729085242.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://juejin.im/post/5c31f64c6fb9a049ac794ffc">漫画：什么是B-树？</a></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>其定义基本与B-树同，除了：</p>
<ol>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
<li><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729105829.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729105829.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>B+ 树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p>B<em>-tree是B+-tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B</em>树中非根和非叶子结点再增加指向兄弟的指针；</p>
<p>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729111251.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200729111251.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h2 id="关于B树类的文章"><a href="#关于B树类的文章" class="headerlink" title="关于B树类的文章"></a>关于B树类的文章</h2><ol>
<li><a href="https://developer.aliyun.com/article/38345">二叉树学习笔记之B树、B+树、B*树</a></li>
<li><a href="https://blog.csdn.net/aqzwss/article/details/53074186">B-树，B+树，B*树详解</a></li>
<li><a href="https://blog.csdn.net/bigtree_3721/article/details/73632405">B-树，B+树与B*树的优缺点比较</a></li>
</ol>
<h2 id="LSM树（Log-Structured-Merge-Tree）"><a href="#LSM树（Log-Structured-Merge-Tree）" class="headerlink" title="LSM树（Log-Structured Merge Tree）"></a>LSM树（Log-Structured Merge Tree）</h2><p>存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</p>
<p>因为B+树可能存在大量得随机IO访问</p>
<p>推荐阅读：<a href="https://www.cnblogs.com/yanghuahui/p/3483754.html">LSM树由来、设计思想以及应用到HBase的索引</a></p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200731095711.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200731095711.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<ul>
<li>前序遍历:先访问根节点，再访问左子节点，最后访问右子节点。图中的二叉树的前序遍历的顺序是10、6、4、8、14、12、16。</li>
<li>中序遍历:先访问左子节点，再访问根节点，最后访问右子节点。图中的二叉树的中序遍历的顺序是4、6、8、10、12、14、16。</li>
<li>后序遍历:先访问左子节点，再访问右子节点，最后访问根节点。图中的二叉树的后序遍历的顺序是4、8、6、12、 16、14、10。</li>
</ul>
<p>推荐阅读: <a href="https://www.cnblogs.com/zhi-leaf/p/10813048.html">二叉树遍历（前序、中序、后序）- Java实现</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>tree</tag>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之Map</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BMap.html</url>
    <content><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在Java中，HashMap是Map的最常用的。HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。与HashTable主要区别为不支持同步和允许null作为key和value，所以如果你想要保证线程安全，可以使用ConcurrentHashMap代替而不是线程安全的HashTable，因为HashTable基本已经被淘汰</p>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>JDK1.8之前，HashMap使用了<strong>拉链法</strong>解决冲突。也就是在Hash冲突的时候，直接将冲突的加入链表即可<br>缺陷：如果散列分布不均匀，导致大量不同数据都有同一个Hash地址，这样拉链法的这个链表就会很长了，如果过于长，会降低HashMap的性能。<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726194737.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726194737.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>为了解决当链表过长出现的性能问题，HashMap采用<strong>拉链法+红黑树</strong>的方式解决冲突。也就是首先使用拉链法的方式，当链表长度达到一定长度之后(默认为8)，就将链表转换成红黑树。<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726194810.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726194810.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<h3 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h3><p>以下都来自JDK1.8</p>
<h4 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">// 序列号</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">362498820763181265L</span>;    
    <span class="hljs-comment">// 默认的初始容量是16</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;   
    <span class="hljs-comment">// 最大容量</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>; 
    <span class="hljs-comment">// 默认的填充因子</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;
    <span class="hljs-comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>; 
    <span class="hljs-comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;
    <span class="hljs-comment">// 桶中结构转化为红黑树对应的table的最小大小</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;
    <span class="hljs-comment">// 存储元素的数组，总是2的幂次倍</span>
    <span class="hljs-keyword">transient</span> Node&lt;k,v&gt;[] table; 
    <span class="hljs-comment">// 存放具体元素的集</span>
    <span class="hljs-keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;
    <span class="hljs-comment">// 存放元素的个数，注意这个不等于数组的长度。</span>
    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;
    <span class="hljs-comment">// 每次扩容和更改map结构的计数器</span>
    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;   
    <span class="hljs-comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>
    <span class="hljs-keyword">int</span> threshold;
    <span class="hljs-comment">// 装填因子</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;
&#125;</code></pre>
<ol>
<li>其中的MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 相当于是2的30次方。int一共32位，为什么不左移31位呢，也是2的幂次。原因就是因为31位为符号位，如果左移31位了就会是一个负数了，所以只能左移31位。</li>
<li>loadFactor就是装填因子，具体可以查看哈希表的那篇博文，HashMap默认设置为0.75f。</li>
<li>threshold，也就是容量阈值，就是装到了多少比例了再扩容，当作变量是不用每次都计算。只在容量变化时候计算。</li>
</ol>
<h4 id="树节点与链表节点"><a href="#树节点与链表节点" class="headerlink" title="树节点与链表节点"></a>树节点与链表节点</h4><ol>
<li>链表节点<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
     <span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>
     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;
     <span class="hljs-keyword">final</span> K key;
     V value;
     <span class="hljs-comment">// 指向下一个节点</span>
     Node&lt;K,V&gt; next;
&#125;</code></pre></li>
<li>红黑树节点<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
        TreeNode&lt;K,V&gt; parent;
        TreeNode&lt;K,V&gt; left; 
        TreeNode&lt;K,V&gt; right; 
        <span class="hljs-comment">// needed to unlink next upon deletion</span>
        TreeNode&lt;K,V&gt; prev;  
        <span class="hljs-comment">// 是否为红色节点  </span>
        <span class="hljs-keyword">boolean</span> red;         
&#125;</code></pre>

</li>
</ol>
<h4 id="增删查方法"><a href="#增删查方法" class="headerlink" title="增删查方法"></a>增删查方法</h4><p>1.put与putVal</p>
<pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
      <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;
    <span class="hljs-comment">//如果还没有初始化就进行初始化</span>
    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
        n = (tab = resize()).length;
    <span class="hljs-comment">//这里对hash值进行取余，保证hash的地址在数组长度以内，并且确定存放在哪个桶中，如果桶为空，则新的节点就放入桶中（在数组中的）</span>
    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)
        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
    <span class="hljs-comment">//证明此时桶不为空    </span>
    <span class="hljs-keyword">else</span> &#123;
        Node&lt;K,V&gt; e; K k;
        <span class="hljs-comment">//桶的第一个元素hash值和key值和新的节点一样</span>
        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
            e = p;
       <span class="hljs-comment">//hash值不相等，即key不相等；</span>
       <span class="hljs-comment">//为红黑树结点 时候    </span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);
       <span class="hljs-comment">//为链表结点 时候       </span>
        <span class="hljs-keyword">else</span> &#123;
          <span class="hljs-comment">//遍历到最后一个节点，将新的节点插入尾部</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;
               <span class="hljs-comment">//没有下一个节点了则到尾部了</span>
                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;
                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
                    <span class="hljs-comment">//如果链表长度到达了阈值，则转化成红黑树</span>
                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>
                        treeifyBin(tab, hash);
                    <span class="hljs-keyword">break</span>;
                &#125;
                <span class="hljs-comment">//遍历到的链表中的这个节点hash值和key值和新的节点一样，发现存在了，跳出循环。当前e为这个重复的节点。p为上一个节点</span>
                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//切换父节点为当前节点，做遍历</span>
                p = e;
            &#125;
        &#125;
        <span class="hljs-comment">//e的值存在</span>
        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>
            V oldValue = e.value;
            <span class="hljs-comment">//只有在值不存（onlyIfAbsent=false）在的或者为Null的时候才更新</span>
            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)
                e.value = value;
            <span class="hljs-comment">// 访问后回调    </span>
            afterNodeAccess(e);
            <span class="hljs-keyword">return</span> oldValue;
        &#125;
    &#125;
    ++modCount;
    <span class="hljs-comment">//判断是否需要扩容</span>
    <span class="hljs-keyword">if</span> (++size &gt; threshold)
        resize();
    <span class="hljs-comment">// 插入后回调    </span>
    afterNodeInsertion(evict);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre>
<p>可以看到put方法只是对key进行了hash，然后调用了putVal方法，核心的添加逻辑还是在putVal方法里面。<br>因为putTreeVal有添加树节点和红黑树的转换，不是这里的重点，具体可以查看红黑树那篇。</p>
<ol start="2">
<li>remove与removeNode</li>
</ol>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;
        Node&lt;K,V&gt; e;
        <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;
&#125;
<span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,<span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;
        <span class="hljs-comment">//hash表已经初始化，并且这个位置有节点，才进入逻辑</span>
        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;
            Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;
            <span class="hljs-comment">//桶中第一个元素key和hash值与新来的key相等</span>
            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
                node = p;
            <span class="hljs-comment">//不相等的时候，如果存下一个节点    </span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//桶中第一个节点节点为树节点时,拿到这个要删除的节点</span>
                <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
                <span class="hljs-comment">//为链表时    </span>
                <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">//遍历链表，直到找到</span>
                    <span class="hljs-keyword">do</span> &#123;
                        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;
                            node = e;
                            <span class="hljs-keyword">break</span>;
                        &#125;
                        p = e;
                    &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);
                &#125;
            &#125;
            <span class="hljs-comment">//这个key对应的节点存在，并且不匹配值，或者值与期望的值相等，则进行删除。</span>
            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||(value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;
                <span class="hljs-comment">//如果是树节点，就调用删除树节点的方法</span>
                <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)
                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);
                <span class="hljs-comment">//如果是第一个节点，那就把节点前移   ，桶中第一个节点变为下一个节点 </span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)
                    tab[index] = node.next;
                <span class="hljs-comment">//否则 直接把节点前移  </span>
                <span class="hljs-keyword">else</span>
                    p.next = node.next;
                ++modCount;
                --size;
                <span class="hljs-comment">//一处后的回调</span>
                afterNodeRemoval(node);
                <span class="hljs-keyword">return</span> node;
            &#125;
        &#125;
        <span class="hljs-comment">//没有找到这个key则直接返回null</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre>
<ol start="3">
<li>get与getNode</li>
</ol>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;
        Node&lt;K,V&gt; e;
        <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;
&#125;
<span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;
      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;
      <span class="hljs-comment">//hash表已经初始化，并且这个位置有节点，才进入逻辑</span>
      <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;
          <span class="hljs-comment">//如果桶中第一个就是了，直接返回</span>
          <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
              <span class="hljs-keyword">return</span> first;
          <span class="hljs-comment">//如果存在下一个节点    </span>
          <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;
              <span class="hljs-comment">//桶中第一个如果是树节点。直接查找树</span>
              <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)
                  <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
              <span class="hljs-comment">//不是的话就遍历链表，知道找到为止    </span>
              <span class="hljs-keyword">do</span> &#123;
                  <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
                      <span class="hljs-keyword">return</span> e;
              &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);
          &#125;
      &#125;
      <span class="hljs-comment">//没有找到返回null</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
  &#125;</code></pre>
<h4 id="hash表扩容"><a href="#hash表扩容" class="headerlink" title="hash表扩容"></a>hash表扩容</h4><p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 </p>
<p>扩容条件就是当threshold=loadFactory*capacity大于等于hash表当前的节点个数</p>
<pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    <span class="hljs-comment">//旧的容量</span>
    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;
    <span class="hljs-comment">//旧的阈值</span>
    <span class="hljs-keyword">int</span> oldThr = threshold;
    <span class="hljs-comment">//新的容量与阈值</span>
    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//如果初始化过了</span>
    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-comment">//如果旧的容量大于了最大的容量 2的30次方，装不下了，不再扩容了</span>
        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
          <span class="hljs-comment">//设置为最大，后续不再进入此方法了</span>
            threshold = Integer.MAX_VALUE;
            <span class="hljs-keyword">return</span> oldTab;
        &#125;
        <span class="hljs-comment">//两倍扩容</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>
    &#125;
    <span class="hljs-comment">//未初始化的时候</span>
    <span class="hljs-comment">//初始阈值大于0则将新的容量设置为旧的阈值</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>
        newCap = oldThr;
    <span class="hljs-comment">//否则使用默认的容量进行初始化新的容量    </span>
    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>
        newCap = DEFAULT_INITIAL_CAPACITY;
        <span class="hljs-comment">//计算新的阈值</span>
        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    <span class="hljs-comment">//计算新的阈值，如果新的阈值为0的话</span>
    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);
    &#125;
    <span class="hljs-comment">//更新新的阈值</span>
    threshold = newThr;
    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];
    table = newTab;
    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;
       <span class="hljs-comment">//遍历每个桶，拷贝到新的hash数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            <span class="hljs-comment">//如果桶不为空</span>
            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//释放以前节点的空间</span>
                oldTab[j] = <span class="hljs-keyword">null</span>;
                <span class="hljs-comment">//这个桶只有这一个节点</span>
                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)
                   <span class="hljs-comment">//直接把这个节点放到新的桶里</span>
                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;
                <span class="hljs-comment">//不只有一个节点</span>
                <span class="hljs-comment">//是树节点的时候    </span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);
                <span class="hljs-comment">//为链表的时候    </span>
                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>
                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;
                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;
                    Node&lt;K,V&gt; next;
                    <span class="hljs-comment">//遍历桶的所有节点</span>
                    <span class="hljs-keyword">do</span> &#123;
                        next = e.next;
                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;
                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)
                                loHead = e;
                            <span class="hljs-keyword">else</span>
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        <span class="hljs-keyword">else</span> &#123;
                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)
                                hiHead = e;
                            <span class="hljs-keyword">else</span>
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);

                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;
                        loTail.next = <span class="hljs-keyword">null</span>;
                        newTab[j] = loHead;
                    &#125;
                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;
                        hiTail.next = <span class="hljs-keyword">null</span>;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> newTab;
&#125;</code></pre>

<p>对于以上的为链表时候的扩容源码解读，因为一两句说不清楚，推荐阅读<a href="https://segmentfault.com/a/1190000015812438?utm_source=tag-newest">深入理解HashMap(四): 关键源码逐行分析之resize扩容</a></p>
<h3 id="线程不安全可能引发的链表成环问题-JDk1-7"><a href="#线程不安全可能引发的链表成环问题-JDk1-7" class="headerlink" title="线程不安全可能引发的链表成环问题(JDk1.7)"></a>线程不安全可能引发的链表成环问题(JDk1.7)</h3><p>推荐阅读<a href="https://www.cnblogs.com/wen-he/p/11496050.html">大多数人不知道的：HashMap链表成环的原因和解决方案</a></p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable和HashMap的实现原理几乎一样，<br>差别无非是</p>
<ol>
<li>HashTable不允许key和value为null；</li>
<li>HashTable是线程安全的。</li>
</ol>
<p>但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726225104.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726225104.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="CurrentHashMap"><a href="#CurrentHashMap" class="headerlink" title="CurrentHashMap"></a>CurrentHashMap</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li><p>JDK1.7<br> HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</p>
 <img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726225233.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726225233.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
<li><p>JDK1.8<br>取消segments字段，直接采用transient volatile HashEntry&lt;K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，并发控制使用Synchronized和CAS来操作</p>
</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树，总结如下：</p>
<ol>
<li>JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8实现降低锁的粒度就是HashEntry（首节点）</li>
<li>JDK1.8版本的数据结构变得更加简单，去掉了Segment这种数据结构，使用synchronized来进行同步锁粒度降低，所以不需要分段锁的概念，实现的复杂度也增加了</li>
<li>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</li>
<li>JDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock：<ul>
<li>低粒度加锁方式，synchronized并不比ReentrantLock差，粗粒度加锁中ReentrantLock可能通过Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了</li>
<li>JVM的开发团队从来都没有放弃synchronized，而且基于JVM的synchronized优化空间更大，使用内嵌的关键字比使用API更加自然</li>
<li>在大量的数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存</li>
</ul>
</li>
</ol>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap底层为红黑树，线程不安全的，如果需要使用请使用线程安全的，可以使用</p>
<pre><code class="hljs java">
Collections.synchronizedSortedMap();
Collections.synchronizedMap(<span class="hljs-keyword">new</span> TreeMap());
</code></pre>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://juejin.im/post/5ab0568b5188255580020e56#heading-6">集合框架源码学习之HashMap(JDK1.8)</a></li>
<li><a href="https://blog.csdn.net/weixin_43185598/article/details/87938882">ConcurrentHashMap实现原理及源码分析</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之哈希表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8.html</url>
    <content><![CDATA[<h2 id="关于哈希Hash"><a href="#关于哈希Hash" class="headerlink" title="关于哈希Hash"></a>关于哈希Hash</h2><p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。<br>白话：给你一(多)个字符串(数据)，你根据字符串生产一个唯一的hash数</p>
<h2 id="常用Hash函数"><a href="#常用Hash函数" class="headerlink" title="常用Hash函数"></a>常用Hash函数</h2><h3 id="直接寻址法"><a href="#直接寻址法" class="headerlink" title="直接寻址法"></a>直接寻址法</h3><p>取关键字或关键字的某个线性函数值为散列地址，即H(key)=key或H(key) = a·key + b，其中a和b为常数</p>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>取关键字平方后的中间几位作为散列地址。</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。</p>
<h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>选择一随机函数，取关键字作为随机函数的种子生成随机值作为散列地址，通常用于关键字长度不同的场合。</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p&lt;=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生碰撞。</p>
<h2 id="处理Hash冲突方案"><a href="#处理Hash冲突方案" class="headerlink" title="处理Hash冲突方案"></a>处理Hash冲突方案</h2><p>哈希冲突即是，不同的数据，经过同一个hash函数，生成了同一个hash值。</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>Hi=(H(key) + di) MOD m，i=1,2,…，k(k&lt;=m-1)，其中H(key)为散列函数，m为散列表长，di为增量序列，可有下列三种取法：</p>
<ol>
<li>di=1,2,3,…，m-1，称线性探测再散列；</li>
<li>di=1^2,-1^2,2^2,-2^2,3^2,…，±k^2,(k&lt;=m/2)称二次探测再散列；</li>
<li>di=伪随机数序列，称伪随机探测再散列。</li>
</ol>
<p>说的通俗一点，如果这个Hash冲突了，则根据上诉计算方式，尝试寻找下一个没有被占用地址的位置，就比如hash计算出来得1，则array[1]里面已经本占用了，这个时候可以根据方法1，计算得到下一个地址为2，如果2地址也被占用了，则3以此类推。直到找到没有被占用得即可。</p>
<h3 id="再散列法（再哈希）"><a href="#再散列法（再哈希）" class="headerlink" title="再散列法（再哈希）"></a>再散列法（再哈希）</h3><p>Hi=RHi(key),i=1,2,…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。</p>
<h3 id="链地址法-拉链法"><a href="#链地址法-拉链法" class="headerlink" title="链地址法(拉链法)"></a>链地址法(拉链法)</h3><p>拉链法就是用一个数组存hash过后的地址值，地址值后面存这个hash值得链表，当hash冲突之后，则只需要将冲突的数据连接到这个链表之后就行了，这样有个问题就是增加了空间成本，而且还有个问题就是查找可能出现问题。当某个hash值冲突严重的时候，这个链表可能会非常的长，如果查找一个数据就需要根据hash找到链表，然后遍历链表找到真正的数据。所以可能性能上有些影响，在Java(1.8)的HashMap里面，是在链表长度到达一定长度之后，链表转化成了红黑树。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726182226.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726182226.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h3><p>建立一个公共溢出区域，就是把冲突的都放在另一个地方，不在表里面。</p>
<h2 id="平均查找长度与装填因子"><a href="#平均查找长度与装填因子" class="headerlink" title="平均查找长度与装填因子"></a>平均查找长度与装填因子</h2><ol>
<li>平均查找长度<br>为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的平均查找长度()，ASL成功。<br>在查找表中查找不到待查元素，但是找到待查元素应该在表中存在的位置的平均查找次数称为查找不成功时的平均查找长度，不成功。</li>
<li>装填因子<br>散列表的装填因子定义为：α= 填入表中的元素个数/散列表的长度<br>装填因子越大，说明hash表装的越多，冲突出现越大。</li>
</ol>
<h2 id="影响Hash表性能的因素"><a href="#影响Hash表性能的因素" class="headerlink" title="影响Hash表性能的因素"></a>影响Hash表性能的因素</h2><ol>
<li>因素<ul>
<li>散列函数是否均匀；</li>
<li>处理冲突的方法；</li>
<li>散列表的装填因子。</li>
</ul>
</li>
<li>著名Hash算法<ul>
<li>MD4</li>
<li>MD5</li>
<li>SHA-1</li>
</ul>
</li>
</ol>
<h2 id="用Java实现Hash表"><a href="#用Java实现Hash表" class="headerlink" title="用Java实现Hash表"></a>用Java实现Hash表</h2><p>使用了开放地址法和拉链法。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Hash表的Java实现</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019.06.04 18:51</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashTable</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//索引使用数量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<span class="hljs-comment">//容量</span>
    <span class="hljs-keyword">private</span> Node&lt;K, V&gt;[] table;<span class="hljs-comment">//散列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mode = <span class="hljs-number">1</span>;<span class="hljs-comment">//处理冲突方式 1开放地址法，2链表储存法</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> eRate = <span class="hljs-number">0.8</span>;<span class="hljs-comment">//扩容因子（达到容量的多少比例后扩容）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hashMode;<span class="hljs-comment">//哈希值生成函数选择</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> conflictsNum;<span class="hljs-comment">//冲突次数</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> linkNodeNum;<span class="hljs-comment">//链式储存时当前节点个数</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> queryNum;<span class="hljs-comment">//查询一次比较次数</span>

    <span class="hljs-comment">//默认容量16</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashTable</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>(<span class="hljs-number">16</span>);
    &#125;

    <span class="hljs-comment">//构建散列表</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.capacity = capacity;
        table = <span class="hljs-keyword">new</span> Node[capacity];
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 高级构造</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity 容量</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mode     处理冲突方式</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> eRate    扩容因子</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">int</span> mode, <span class="hljs-keyword">double</span> eRate, <span class="hljs-keyword">int</span> hashMode)</span> </span>&#123;
        <span class="hljs-keyword">this</span>(capacity);
        <span class="hljs-keyword">this</span>.mode = mode;
        <span class="hljs-keyword">this</span>.eRate = eRate;
        <span class="hljs-keyword">this</span>.hashMode = hashMode;
    &#125;

    <span class="hljs-comment">//散列函数</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(K key)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (hashMode == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//余数法</span>
            <span class="hljs-keyword">return</span> (key.hashCode() &amp; <span class="hljs-number">0x7fffffff</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//折叠法+余数法</span>
            <span class="hljs-keyword">int</span> code = key.hashCode() &amp; <span class="hljs-number">0x7fffffff</span>;
            <span class="hljs-comment">//1865644118</span>
            <span class="hljs-keyword">int</span> h = code / <span class="hljs-number">1000000</span>;<span class="hljs-comment">//186</span>
            h += code / <span class="hljs-number">1000</span> % <span class="hljs-number">1000</span>;<span class="hljs-comment">//564</span>
            h += code % <span class="hljs-number">1000</span>;<span class="hljs-comment">//118</span>
            <span class="hljs-keyword">return</span> h;
        &#125;
    &#125;

    <span class="hljs-comment">//添加数据（三种情况，还没有初始化hash表，初始化了但是hash值冲突，key相同）</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K k, V v)</span> </span>&#123;
        <span class="hljs-comment">//自动扩容，2倍扩容</span>
        <span class="hljs-keyword">if</span> (num &gt; eRate * capacity &amp;&amp; mode == <span class="hljs-number">1</span>) &#123;
            resize(capacity * <span class="hljs-number">2</span>);
        &#125;
        <span class="hljs-keyword">int</span> hash = hash(k);<span class="hljs-comment">//计算哈希值</span>
        <span class="hljs-keyword">int</span> index = indexFor(hash);<span class="hljs-comment">//计算索引</span>
        <span class="hljs-comment">//如果没有冲突</span>
        <span class="hljs-keyword">if</span> (table[index] == <span class="hljs-keyword">null</span>) &#123;
            table[index] = <span class="hljs-keyword">new</span> Node&lt;&gt;(k, v, hash);
            linkNodeNum++;
            conflictsNum++;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//开放地址法解决冲突</span>
            <span class="hljs-keyword">if</span> (hash == table[index].hash &amp;&amp; (k.equals(table[index].getKey()))) &#123;<span class="hljs-comment">//如果键的值一样且与上次hash值相同则更新</span>
                table[index].setValue(v);
                conflictsNum++;
                <span class="hljs-keyword">return</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//确认为冲突</span>
                <span class="hljs-keyword">while</span> (table[index] != <span class="hljs-keyword">null</span>) &#123;
                    conflictsNum++;
                    <span class="hljs-comment">//找到可以插入的索引</span>
                    index = (index + <span class="hljs-number">1</span>) % capacity;
                &#125;
                table[index] = <span class="hljs-keyword">new</span> Node&lt;&gt;(k, v, hash);
            &#125;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//链式储存法解决冲突</span>
            <span class="hljs-comment">//判断是否为过更新</span>
            Node&lt;K, V&gt; node = table[index];
            <span class="hljs-keyword">while</span> (node.next != <span class="hljs-keyword">null</span> &amp;&amp; !node.getKey().equals(k)) &#123;<span class="hljs-comment">//遍历找到末尾节点或者找到键值相同的节点</span>
                node = node.next;
                conflictsNum++;
            &#125;
            <span class="hljs-keyword">if</span> (node.getKey().equals(k)) &#123;
                node.setValue(v);
                <span class="hljs-keyword">return</span>;
            &#125;
            <span class="hljs-comment">//非更新</span>
            linkNodeNum++;
            conflictsNum++;
            node.next = <span class="hljs-keyword">new</span> Node&lt;K, V&gt;(k, v, hash);
            <span class="hljs-keyword">return</span>;
        &#125;
        num++;<span class="hljs-comment">//当前表中索引使用数量增加</span>
    &#125;

    <span class="hljs-comment">//删除数据</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(K k)</span> </span>&#123;

    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 查询数据</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k key值</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 没找到返回null</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K k)</span> </span>&#123;
        queryNum = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> hash = hash(k);
        <span class="hljs-keyword">int</span> index = indexFor(hash);
        Node&lt;K, V&gt; node = table[index];
        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-comment">//开放地址法</span>
        <span class="hljs-keyword">if</span> (mode == <span class="hljs-number">1</span>) &#123;
            <span class="hljs-comment">//如果当前索引处node为空了并且还没有找到与键值匹配的关键字则跳出循环</span>
            <span class="hljs-keyword">while</span> (table[index] != <span class="hljs-keyword">null</span> &amp;&amp; !k.equals(table[index].getKey())) &#123;
                index = (index + <span class="hljs-number">1</span>) % capacity;
                queryNum++;
            &#125;
            <span class="hljs-keyword">return</span> table[index] == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : table[index].getValue();
        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//链式储存法</span>
            <span class="hljs-keyword">while</span> (node.next != <span class="hljs-keyword">null</span> &amp;&amp; !k.equals(node.getKey())) &#123;
                node = node.next;
                queryNum++;
            &#125;
            <span class="hljs-keyword">if</span> (k.equals(node.getKey())) &#123;
                <span class="hljs-keyword">return</span> node.getValue();
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
    &#125;

    <span class="hljs-comment">//获取index</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash)</span> </span>&#123;
        <span class="hljs-keyword">return</span> hash % capacity;
    &#125;

    <span class="hljs-comment">//获取当前表中数量,1线性探测法,2链式法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;
        <span class="hljs-keyword">return</span> type == <span class="hljs-number">1</span> ? num : linkNodeNum;
    &#125;

    <span class="hljs-comment">//获取容量</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> capacity;
    &#125;

    <span class="hljs-comment">//获取冲突次数</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getConflictsNum</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> conflictsNum;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 更改处理冲突模式</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mode 1开放地址法，2链表储存法</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mode)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.mode = mode;
    &#125;

    <span class="hljs-comment">//获取本次查询比较次数</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQueryNum</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> queryNum;
    &#125;

    <span class="hljs-comment">//重新设置大小</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
        <span class="hljs-comment">//如果传入容量小于当前容量则不处理</span>
        <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">this</span>.capacity;
        <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-keyword">this</span>.capacity) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        conflictsNum = <span class="hljs-number">0</span>;
        num = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.capacity = capacity;
        <span class="hljs-comment">//数据迁移</span>
        Node&lt;K, V&gt;[] oldTab = table;
        table = <span class="hljs-keyword">new</span> Node[capacity];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;
            <span class="hljs-keyword">if</span> (oldTab[i] != <span class="hljs-keyword">null</span>) &#123;
                put(oldTab[i].getKey(), oldTab[i].getValue());
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">//自定义节点类</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;
        <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<span class="hljs-comment">//哈希值</span>
        V value;<span class="hljs-comment">//值</span>
        Node&lt;K, V&gt; next;<span class="hljs-comment">//链表处理冲突时用</span>

        Node(K k, V v, <span class="hljs-keyword">int</span> hash) &#123;
            <span class="hljs-keyword">this</span>.key = k;
            <span class="hljs-keyword">this</span>.value = v;
            <span class="hljs-keyword">this</span>.hash = hash;
            <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> key;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> value;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;
            V oldValue = value;
            value = newValue;
            <span class="hljs-keyword">return</span> oldValue;
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> key.hashCode() ^ value.hashCode();
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;
            Node&lt;?, ?&gt; e = (Node&lt;?, ?&gt;) o;
            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/yeiweilan/article/details/73412438">解决Hash冲突四种方法</a></li>
<li><a href="https://baike.baidu.com/item/Hash/390310?fromtitle=%E5%93%88%E5%B8%8C&fromid=24086145&fr=aladdin">百度百科</a></li>
<li><a href="https://juejin.im/post/5ab0568b5188255580020e56#heading-6">集合框架源码学习之HashMap(JDK1.8)</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>hash</tag>
        <tag>开放地址法</tag>
        <tag>拉链法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之栈Stack</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88Stack.html</url>
    <content><![CDATA[<h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p>栈是一种用于存储数据的简单数据结构，有点类似链表或者顺序表（统称线性表），栈与线性表的最大区别是数据的存取的操作，我们可以这样认为栈(Stack)是一种特殊的线性表，其插入和删除操作只允许在线性表的一端进行，一般而言，把允许操作的一端称为栈顶(Top)，不可操作的一端称为栈底(Bottom)，同时把插入元素的操作称为入栈(Push),删除元素的操作称为出栈(Pop)。若栈中没有任何元素，则称为空栈<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726164205.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726164205.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<h2 id="Java中的栈Stack"><a href="#Java中的栈Stack" class="headerlink" title="Java中的栈Stack"></a>Java中的栈Stack</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Stack继承于Vector，所以也是线程安全的。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>Stack的源码比较简单，主要功能全部依赖与Vector方法实现。</p>
<pre><code class="hljs java">
<span class="hljs-keyword">public</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Vector</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">push</span><span class="hljs-params">(E item)</span> </span>&#123;
        addElement(item);

        <span class="hljs-keyword">return</span> item;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        E obj;
        <span class="hljs-keyword">int</span> len = size();
        obj = peek();
        removeElementAt(len - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> obj;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">int</span> len = size();
        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();
        <span class="hljs-keyword">return</span> elementAt(len - <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> size() == <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Object o)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = lastIndexOf(o);
        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> size() - i;
        &#125;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>


<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>参考 <a href="https://blog.csdn.net/javazejian/article/details/53362993">java数据结构与算法之栈（Stack）设计与实现</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之列表List</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%88%97%E8%A1%A8List.html</url>
    <content><![CDATA[<h2 id="什么是List"><a href="#什么是List" class="headerlink" title="什么是List"></a>什么是List</h2><p>在 List 中，⽤户可以精确控制列表中每个元素的插⼊位置，另外⽤户可以通过整数索引（列表中的位<br>置）访问元素，并搜索列表中的元素。 与 Set 不同，List 通常允许重复的元素。 另外 List 是有序<br>集合⽽ Set 是⽆序集合。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ArrayList是一个Java日常开发中经常使用到的类，底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p>
<p>它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p>
<p>在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为O(n）,求表长以及增加元素，取第 i 元素的时间复杂度为O(1）</p>
<ul>
<li>继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</li>
<li>实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li>实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。</li>
<li>实现java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。</li>
<li>线程不安全，所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>ArrayList在添加数据的时候会判断是否大于容量，如果大于了当前数组的容量，则进行扩容，每次扩容的容量为当前容量的1.5倍。如果每次增加一个，这个效率肯定不高的。</p>
<p>数组容量不能超过Integer.MAX_VALUE-8;如果超过则会OOM。因为对象头里面会存储_length字段，而这个字段长度为8，所以要减去8；</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;
    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span>
    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;
    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>
    <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>
    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>
    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)
        newCapacity = minCapacity;
    <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>
    <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>
    <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>
    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)
        newCapacity = hugeCapacity(minCapacity);
    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;</code></pre>

<h3 id="关于快速删除"><a href="#关于快速删除" class="headerlink" title="关于快速删除"></a>关于快速删除</h3><p>在ArrayList源码中可以看到有个fastRemove方法，这个方法为甚么叫快速删除呢，是因为直接调用了System.arraycopy方法，这样就不用考虑数组的边界问题而且还不用有返回值。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
      modCount++;
      <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;
      <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)
          System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,
                           numMoved);
      elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>
  &#125;</code></pre>

<h3 id="关于内部类中的迭代器"><a href="#关于内部类中的迭代器" class="headerlink" title="关于内部类中的迭代器"></a>关于内部类中的迭代器</h3><ul>
<li>Itr 其中的Itr是实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；</li>
<li>ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法。</li>
</ul>
<p>可以看出了 Iterator和ListIterator的区别: ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Vector相当于是线程安全的ArrayList，实现线程安全的方法也就是在每个修改数组的方法上面加上了一个Synchronized方法，所以效率很低，现在一般使用Collections.syschronizedList方法来创建线程安全的集合。</p>
<h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>与ArrayList有所不同，Vector设置了一个自己的扩容数量capacityIncrement，通过设置这个的大小，可以默认让Vector每次扩容这么多，如果不设置，则就以默认的2倍进行扩容。</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;
    <span class="hljs-comment">// overflow-conscious code</span>
    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;
    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ? capacityIncrement : oldCapacity);
    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)
        newCapacity = minCapacity;
    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;</code></pre>

<h2 id="动手实现ArrayList"><a href="#动手实现ArrayList" class="headerlink" title="动手实现ArrayList"></a>动手实现ArrayList</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019.06.03 14:40</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 元素</span>
<span class="hljs-comment">     */</span>
    Object[] elementData = &#123;&#125;;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENT_DATA = &#123;&#125;;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 容量</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">10</span>;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 当前元素个数</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 泛型转化</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity 容量</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (capacity &gt; <span class="hljs-number">0</span>) &#123;
            elementData = <span class="hljs-keyword">new</span> Object[capacity];
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123;
            elementData = EMPTY_ELEMENT_DATA;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;参数错误&quot;</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyList</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>(capacity);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 当前容量</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> size</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> size;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 检测是否满了，满了则扩容</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkAndExpansion</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (size + <span class="hljs-number">1</span> &gt; capacity) &#123;
            <span class="hljs-keyword">this</span>.elementData = Arrays.copyOf(elementData, size * <span class="hljs-number">2</span>);
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 泛型转化</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 泛型对象</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        <span class="hljs-keyword">return</span> (T) elementData[index];
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 指定下标设置值</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o     元素</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, T o)</span> </span>&#123;
        checkAndExpansion();
        elementData[index] = o;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 在尾部添加一个元素</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o 元素</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T o)</span> </span>&#123;
        checkAndExpansion();
        elementData[size++] = o;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 移除一个元素</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        System.arraycopy(elementData, index + <span class="hljs-number">1</span>, elementData, index, size - index - <span class="hljs-number">1</span>);
        size--;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 根据下标查询</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index /</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        checkAndExpansion();
        <span class="hljs-keyword">return</span> elementData(index);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 清空集合</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;
        elementData = <span class="hljs-keyword">new</span> Object[capacity];
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 添加一个集合</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> myList /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(MyList&lt;T&gt; myList)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (myList == <span class="hljs-keyword">null</span> || myList.size() == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; myList.size(); i++) &#123;
            <span class="hljs-keyword">this</span>.add(myList.get(i));
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 查看是否有这个元素元素</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 元素</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isExist</span><span class="hljs-params">(T e)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (Object elementDatum : elementData) &#123;
            <span class="hljs-keyword">if</span> (e.equals(elementDatum)) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 查找元素下标</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t 元素</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(T t)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementData.length; i++) &#123;
            <span class="hljs-keyword">if</span> (elementData[i] != <span class="hljs-keyword">null</span> &amp;&amp; t.equals(elementData[i])) &#123;
                <span class="hljs-keyword">return</span> i;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> Arrays.toString(elementData);
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>list</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之Set</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSet.html</url>
    <content><![CDATA[<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>Set 继承于 Collection 接⼝，是⼀个不允许出现重复元素，并且⽆序的集合，主要 HashSet 和<br>TreeSet 两⼤实现类。<br>在判断重复元素的时候，HashSet 集合会调⽤ hashCode()和 equal()⽅法来实现；TreeSet 集合会调<br>⽤compareTo⽅法来实现。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>HashSet 是哈希表结构，主要利⽤ HashMap 的 key 来存储元素,value为一个静态常量Object，计算插⼊元素的 hashCode 来获取元,素在集合中的位置； 此类允许null元素。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li>LinkedHashSet，基于LinkedHashMap，实现保证插入的顺序和输出的顺序是一样的。</li>
<li>ConcurrentHashSet，一个线程安全的</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出–倒序或者升序；</p>
<p>它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。</p>
<p>（1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；</p>
<p>（2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能；</p>
<p>（3）TreeSet实现Cloneable接口，意味着它也可以被克隆；</p>
<p>（4）TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输；</p>
<p>具有如下特点：</p>
<ul>
<li>对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）</li>
<li>底层使用红黑树结构，而不是哈希表结构</li>
<li>允许插入Null值</li>
<li>不允许插入重复元素</li>
<li>线程不安全</li>
</ul>
<h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li>SortedSet，一个有序Set的接口，是所有有序集合的父类。</li>
</ul>
<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h2><p>基于CopyOnWriteArrayList实现，每次添加都会去遍历LIst中是否存在元素，如果存在则不添加。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之队列</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97.html</url>
    <content><![CDATA[<h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>队列是数据结构中⽐᫾重要的⼀种类型，它⽀持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们⽣活中的排队类似。<br>因为队列是线性表，所以队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p>
<h2 id="队列的种类"><a href="#队列的种类" class="headerlink" title="队列的种类"></a>队列的种类</h2><h3 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h3><p>  单队列就是常⻅的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况</p>
<h4 id="假溢出"><a href="#假溢出" class="headerlink" title="假溢出"></a>假溢出</h4><ol>
<li><p>假设是长度为5的数组，初始状态，空队列如所示，front与 rear指针均指向下标为0的位置。然后入队a1、a2、a3、a4, front指针依然指向下标为0位置，而rear指针指向下标为4的位置。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200725210130.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200725210130.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
<li><p>出队a1、a2，则front指针指向下标为2的位置，rear不变，如下图所示，再入队a5，此时front指针不变，rear指针移动到数组之外。嗯？数组之外，那将是哪里？</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200725210303.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200725210303.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>  

<p>问题还不止于此。假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做“假溢出”。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3></li>
</ol>
<p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol>
<li><p>rear可以改为指向下标为0的位置，这样就不会造成指针指向不明的问题了。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726082321.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726082321.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
<li><p>但是这个时候，如果继续插入a6、a7的话，指针rear就会与front重合了。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726082509.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726082509.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
<li><p>这个时候新的问题来了，就是rear=front的时候，队列是空了还是满了？有两种解决方案 </p>
<ul>
<li>设置一个标志变量flag，当front == rear,且flag = 0时为队列空，当front == rear,且flag= 1时为队列满。</li>
<li>当队列空时，条件就是from = rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 如下图所示，我们就认为此队列已经满了，也就是说，我们不允许上图情况出现。<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726082853.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726082853.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
</ul>
</li>
<li><p>说说第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1) %QueueSize == front (取模“%的目的就是为了整合rear与front大小为一个问题)。<br>QueueSize = 5，当 front=0，而 rear=4, (4+1) %5 = 0，所以此时队列满。再比如，front = 2而rear =1。(1 + 1) %5 = 2，所以此时 队列也是满的。而对于下图, front = 2而rear= 0, (0+1) %5 = 1，1!=2,所以此时队列并没有满。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726101744.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726101744.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li><p>队列长度计算<br>当rear &gt; front时，此时队列的长度为rear-front。但当rear &lt; front时，队列长度分为两段，一段是QueueSize-front，另一段是0 + rear，加在一起，队列长度为rear-front + QueueSize，因此通用的计算队列长度公式为：<br><strong>(rear—front + QueueSize) % QueueSize</strong></p>
</li>
<li><p>Java实现</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 循环队列</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/26 9:37</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CycleQueue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rear = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] elementData;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CycleQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[len + <span class="hljs-number">1</span>];
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (isFull()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;队列满了&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            elementData[rear++] = e;
            <span class="hljs-keyword">if</span> (rear == elementData.length) &#123;
                rear = <span class="hljs-number">0</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 取出队头 并且删除</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 队头元素</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
        Object value = elementData[front];
        elementData[front++] = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (front == elementData.length) &#123;
            front = <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> (E) value;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 判断队列满了没有</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % elementData.length == front;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 当前队列长度</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> /</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (rear - front + elementData.length) % elementData.length;
    &#125;
&#125;</code></pre>
<blockquote>
<p>单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下不需要担心队列长度的链式存储结构。</p>
</blockquote>
</li>
</ol>
<h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726104815.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726104815.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 链队列</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/26 10:49</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkQueue</span> </span>&#123;
    <span class="hljs-keyword">private</span> Node head;
    <span class="hljs-keyword">private</span> Node tail;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
        Node front;
        Node rear;
        Object data;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Object data)</span> </span>&#123;
            <span class="hljs-keyword">this</span>.data = data;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object e)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
            head = <span class="hljs-keyword">new</span> Node(e);
            tail = head;
        &#125; <span class="hljs-keyword">else</span> &#123;
            Node last = <span class="hljs-keyword">new</span> Node(e);
            last.front = tail;
            tail.rear = last;
            tail = last;
        &#125;
        size++;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
        Node value = <span class="hljs-keyword">this</span>.head;
        head = head.rear;
        <span class="hljs-keyword">return</span> value;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> size;
    &#125;
&#125;
</code></pre>



<h2 id="Java中的队列"><a href="#Java中的队列" class="headerlink" title="Java中的队列"></a>Java中的队列</h2><p>以下都是基于JDK1.8版本。</p>
<h3 id="Queue单向队列"><a href="#Queue单向队列" class="headerlink" title="Queue单向队列"></a>Queue单向队列</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Queue是Java队列的最高层接口，定义了一些常用的方法<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726113439.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726113439.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<ul>
<li>add添加失败抛出异常，offer添加失败不会抛出异常</li>
<li>element取出队头元素不删除，队列为空则抛出NoSuchElementException异常，peek一样作用只是不会抛出异常</li>
<li>remove取出队头元素并且从队列中删除，队列为空则抛出NoSuchElementException异常，poll一样作用只是不会抛出异常</li>
</ul>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ul>
<li><strong>PriorityQueue</strong>优先队列，过传入一个Comparator比较器，来判断队列中元素的优先顺序，所以，队列也不一定全部都是FIFO（先进先出）的。</li>
<li><strong>BlockingQueue</strong> 阻塞队列，在操作不可行时的时候阻塞当前线程，比如想要添加一个元素，  但是队列已经满了，阻塞住当前线程直到队列可以添加元素为止，当然也可以传入等待时间。</li>
<li><strong>DelayQueue</strong> 一个无界阻塞队列，每个元素有一个延迟时间，如果延迟时间没有到，那么获取不到这个元素，因为队列每次从队列头获取元素，如果队头的元素一直没有到期，那么后面的元素将无法获取到。poll方法如果获取不到已经到期的元素则返回null，take方法会阻塞着一直等到可以获取到到期元素。</li>
<li><strong>SynchronousQueue</strong>，一个只能装一个元素的队列，插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。</li>
<li><strong>ArrayBlockingQueue</strong>，一个阻塞有界队列，创建后队列长度将不能改变。</li>
<li><strong>LinkedBlockingQueue</strong>，一个阻塞有界链队列，可以指定长度来控制队列长度。如果不指定则默认为Integer.MAX_VALUE</li>
</ul>
<h3 id="Deque双向队列"><a href="#Deque双向队列" class="headerlink" title="Deque双向队列"></a>Deque双向队列</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>一个双向队列的定义，实现了Queue接口，可以在两端进行插入删除操作，也可以当作栈来用。<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726144230.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726144230.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/><br>在Queue基础上添加了一些可以在队列头部进行插入，队列尾部进行删除的方法。</p>
<h4 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h4><ul>
<li><strong>BlockingDeque</strong>，一个阻塞的双向队列，也就是当队列满了之后，将会阻塞等到可以添加再添加。</li>
<li><strong>LinkedList</strong>双向链表，这个类比较常用，实现了Deque与List接口。所以也可以当作一个双向队列。</li>
<li><strong>ArrayDeque</strong>，双向无界队列，基础数组实现，可以实现自动扩容，与双向链表实现区别在于，对于长度固定的可以使用这个，比较节省内存（没有头尾节点这些，直接存数据）</li>
<li><strong>ConcurrentLinkedDeque</strong>，线程安全的双向队列，无界的。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>queue</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的滑动窗口与拥塞控制</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.html</url>
    <content><![CDATA[<h2 id="滑动窗口与流量控制"><a href="#滑动窗口与流量控制" class="headerlink" title="滑动窗口与流量控制"></a>滑动窗口与流量控制</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 利⽤滑动窗⼝实现流量控制。流量控制是为了控制发送⽅发送速率，保证接收⽅来得及接收。 接收⽅发送的确认报⽂中的窗⼝字段可以⽤来控制发送⽅窗⼝⼤⼩，从⽽影响发送⽅的发送速率。将窗⼝字段设置为 0，则发送⽅不能发送数据。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200811085349.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200811085349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做网络拥塞。</p>
<p>在计算机网络中数位链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。</p>
<p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</p>
<h3 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h3><p>当输入的负载到达一定程度 吞吐量不会增加，即一部分网络资源会丢失掉，网络的吞吐量维持在其所能控制的最大值，转发节点的缓存不够大这造成分组的丢失是拥塞的征兆。<br><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724204708.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724204708.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<h3 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h3><p>为了进⾏拥塞控制，TCP 发送⽅要维持⼀个 拥塞窗⼝(cwnd) 的状态变量。拥塞控制窗⼝的⼤⼩取决于⽹络的拥塞程度，并且动态变化。发送⽅让⾃⼰的发送窗⼝取为拥塞窗⼝和接收⽅的接受窗⼝中᫾⼩的⼀个。</p>
<p>TCP的拥塞控制采⽤了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在⽹络层也可以使路由器采⽤适当的分组丢弃策略（如主动队列管理 AQM），以减少⽹络拥塞的发⽣。</p>
<h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>慢开始算法的思路是当主机开始发送数据时，如果⽴即把⼤量数据字节注⼊到⽹络，那么可能会引起⽹络阻塞，因为现在还不知道⽹络的符合情况。经验表明，好的⽅法是先探测⼀下，即由⼩到⼤逐渐增⼤发送窗⼝，也就是由⼩到⼤逐渐增⼤拥塞窗⼝数值。cwnd初始值为1，每经过⼀个传播轮次，cwnd加倍。</p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增⼤，即每经过⼀个往返时间RTT就把发送放的cwnd加1.</p>
<h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使⽤定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地⼯作。当有多个数据信息包在某⼀段很短的时间内丢失时，它则不能很有效地⼯作。</p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724210223.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724210223.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724210353.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724210353.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724210547.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724210547.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724210807.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724210807.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>参考：<a href="https://blog.csdn.net/qq_41431406/article/details/97926927">https://blog.csdn.net/qq_41431406/article/details/97926927</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的三次握手与四次挥手</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content><![CDATA[<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>三次握⼿的⽬的是建⽴可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，⽽三次握⼿最主要的⽬的就是双⽅确认⾃⼰与对⽅的发送与接收是正常的。</p>
<p>第⼀次握⼿：Client 什么都不能确认；Server 确认了对⽅发送正常，⾃⼰接收正常<br>第⼆次握⼿：Client 确认了：⾃⼰发送、接收正常，对⽅发送、接收正常；Server 确认了：对⽅发送正常，⾃⼰接收正常<br>第三次握⼿：Client 确认了：⾃⼰发送、接收正常，对⽅发送、接收正常；Server 确认了：⾃⼰发送、接收正常，对⽅发送、接收正常</p>
<p>所以三次握⼿就能确认双发收发功能都正常，缺⼀不可。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 </li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724173440.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724173440.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724173102.gif" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724173102.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><h4 id="为什么不四次握手？"><a href="#为什么不四次握手？" class="headerlink" title="为什么不四次握手？"></a>为什么不四次握手？</h4><blockquote>
<p>四次握手的过程就是把第二次握手拆分成了两次，一次服务器响应ACK，再一次发回SYN来确定客户端的接收是否正常。因为握手没有数据传输，所以可以放在一次就可以完成的没有必要用两次。</p>
</blockquote>
<h4 id="为什么不两次握手？"><a href="#为什么不两次握手？" class="headerlink" title="为什么不两次握手？"></a>为什么不两次握手？</h4><blockquote>
<p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
</blockquote>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724180424.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200724180424.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h4><blockquote>
<p>任何⼀⽅都可以在数据传送结束后发出连接释放的通知，待对⽅确认后进⼊半关闭状态。当另⼀⽅也没有数据再发送的时候，则发出连接&gt;释放通知，对⽅确认后就完全关闭了TCP连接。</p>
<p>举个例⼦：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 &gt;B 跟着⾃⼰的节奏结束通话，于是 B 可能⼜巴拉巴拉说了⼀通，最后B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
</blockquote>
<h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><blockquote>
<p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
</blockquote>
<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><blockquote>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
</blockquote>
<h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><blockquote>
<p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
</blockquote>
<h4 id="TIME-WAIT和CLOSE-WAIT过多什么原因及解决？"><a href="#TIME-WAIT和CLOSE-WAIT过多什么原因及解决？" class="headerlink" title="TIME_WAIT和CLOSE_WAIT过多什么原因及解决？"></a>TIME_WAIT和CLOSE_WAIT过多什么原因及解决？</h4><p>原因：<br> 在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。</p>
<p> 解决：<br> 负载均衡，将请求分发到多个服务器上进行处理。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>本文参考与动图来自：<a href="https://blog.csdn.net/qzcsu/article/details/72861891">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>网络</tag>
        <tag>三次握手</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI的七层模型</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="体系结构图"><a href="#体系结构图" class="headerlink" title="体系结构图"></a>体系结构图</h2><img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724163850.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724163850.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="七层OSI"><a href="#七层OSI" class="headerlink" title="七层OSI"></a>七层OSI</h2><img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724172137.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724172137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="物理层-Physical-Laye"><a href="#物理层-Physical-Laye" class="headerlink" title="物理层(Physical Laye)"></a>物理层(Physical Laye)</h3><p><strong>主要功能</strong>：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br><strong>作用</strong>：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h3 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层(Data Link Layer)"></a>数据链路层(Data Link Layer)</h3><p><strong>主要功能</strong>：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br><strong>作用</strong>：接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p>
<h3 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层(Network Layer)"></a>网络层(Network Layer)</h3><p><strong>主要功能</strong>：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。<br><strong>作用</strong>：解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 </p>
<h3 id="运输层-Transport-Layer"><a href="#运输层-Transport-Layer" class="headerlink" title="运输层(Transport Layer)"></a>运输层(Transport Layer)</h3><p><strong>主要功能</strong>：负责向两台主机进程之间的通信提供通⽤的数据传输服务。<br><strong>作用</strong>：</p>
<ul>
<li>传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。</li>
<li>处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。</li>
</ul>
<h3 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层(Session Layer)"></a>会话层(Session Layer)</h3><p><strong>主要功能</strong>：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。<br><strong>作用</strong>：</p>
<ul>
<li>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。</li>
<li>会话流量控制：提供会话流量控制和交叉会话功能。</li>
<li>寻址：使用远程地址建立会话连接。l</li>
<li>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</li>
</ul>
<h3 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层(Presentation Layer)"></a>表示层(Presentation Layer)</h3><p><strong>主要功能</strong>：对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。<br><strong>作用</strong>：</p>
<ul>
<li>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。</li>
<li>数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。</li>
<li>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。</li>
<li>数据的加密和解密：可以提高网络的安全性。</li>
</ul>
<h3 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层(Application Layer)"></a>应用层(Application Layer)</h3><p>应用层提供的协议有Telnet，SMTP，FTP等等。<br><strong>主要功能</strong>：通过应⽤进程间的交互来完成特定⽹络应⽤<br><strong>作用</strong>：</p>
<ul>
<li>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。</li>
<li>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</li>
</ul>
<h2 id="四层TCP"><a href="#四层TCP" class="headerlink" title="四层TCP"></a>四层TCP</h2><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>　　包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</p>
<h3 id="网间层"><a href="#网间层" class="headerlink" title="网间层"></a>网间层</h3><p>　　对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>　　对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>　　对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等，这也是本书将要讨论的重点。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>osi</tag>
      </tags>
  </entry>
  <entry>
    <title>endorsed覆盖JDK中的类</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/endorsed%E8%A6%86%E7%9B%96JDK%E4%B8%AD%E7%9A%84%E7%B1%BB.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>endorsed技术是为了覆盖JDK提供的类。但是能够覆盖的类是有限制的，其中不包括java.lang包中的类(出于安全的考虑)。<br>两种方式：</p>
<ol>
<li>指定VM参数 -Djava.endorsed.dirs 指定的目录面放置的jar文件，</li>
<li>可以在$JAVA_HOME/jre/lib/endorsed目录存放jar文件而不使用VM参数的方式实现。</li>
</ol>
<h2 id="具体测试"><a href="#具体测试" class="headerlink" title="具体测试"></a>具体测试</h2><h3 id="VM参数"><a href="#VM参数" class="headerlink" title="VM参数"></a>VM参数</h3><p>使用Date对象做测试，把Date对象从JDK拷贝出来，再构造中加入</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">    * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it to</span>
<span class="hljs-comment">    * represent the specified number of milliseconds since the</span>
<span class="hljs-comment">    * standard base time known as &quot;the epoch&quot;, namely January 1,</span>
<span class="hljs-comment">    * 1970, 00:00:00 GMT.</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span>   date   the milliseconds since January 1, 1970, 00:00:00 GMT.</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@see</span>     java.lang.System#currentTimeMillis()</span>
<span class="hljs-comment">    */</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-keyword">long</span> date)</span> </span>&#123;
       fastTime = date;
       System.out.println(<span class="hljs-string">&quot;创建了时间实例&quot;</span>);
   &#125;</code></pre>

<p>然后就是jar包，图方便，我直接编译好Date.css，然后创建文件夹java/util/，把class文件放入进去<br><img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724095314.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724095314.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/><br>zip后改后缀名xxx.jar。</p>
<p>编写测试：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
       System.out.println(<span class="hljs-keyword">new</span> Date());
 &#125;</code></pre>
<p>指定VM参数 -Djava.endorsed.dirs=D:\java\endorsed<br>输出</p>
<pre><code class="hljs plain">创建了时间实例
Fri Jul 24 09:54:48 CST 2020</code></pre>
<p>可以看到成功覆盖了JDK的Date对象</p>
<h3 id="直接放到jre里面"><a href="#直接放到jre里面" class="headerlink" title="直接放到jre里面"></a>直接放到jre里面</h3><img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724095823.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200724095823.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>运行测试，不需要VM参数，一样的效果。</p>
<h2 id="存在原因"><a href="#存在原因" class="headerlink" title="存在原因"></a>存在原因</h2><p>因为JDK的类是由Bootstrap类加载器进行加载的，而这个类加载器由C++编写无法获取到，也是最开始进行类加载的，并且JVM是采用双亲委派机制进行加载class类的。如果你想要在应用程序中替换掉jdk中的某个类是无法做到的，所以提供了endorsed来达到你想要替换到系统中的类。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>endorsed</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的volatile关键字</title>
    <url>/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>volatile 关键字的主要作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直接在主存中进⾏读写。这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致</p>
<p>要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使⽤它都<br>到主存中进⾏读取。</p>
<ul>
<li>无volatile</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723192857.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723192857.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<ul>
<li>有volatile<img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723212630.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723212630.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="400"/></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="单例模式概念"><a href="#单例模式概念" class="headerlink" title="单例模式概念"></a>单例模式概念</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>Java中的Runtime即是单例。</p>
<h2 id="单例的实现方式"><a href="#单例的实现方式" class="headerlink" title="单例的实现方式"></a>单例的实现方式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>Runtime类也是使用的饿汉式。</p>
<pre><code class="hljs java"><span class="hljs-comment">//饿汉式</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();  
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  
         <span class="hljs-keyword">return</span> instance;  
    &#125;  
&#125;</code></pre>
<h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h3><pre><code class="hljs java"><span class="hljs-comment">//懒汉模式</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;  
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;  
  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;  
            instance = <span class="hljs-keyword">new</span> Singleton();  
        &#125;  
        <span class="hljs-keyword">return</span> instance;  
    &#125;  
&#125;</code></pre>
<h4 id="证明不安全"><a href="#证明不安全" class="headerlink" title="证明不安全"></a>证明不安全</h4><p>这种方法会存在一个问题就是，在并发情况下无法保证单例。比如两个线程同时运行到 if (Instance == null) 的时候，这个时候因为对象并未实例化，所以都是得到true.这个时候就会创建两个对象了，不能保证单例。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                System.out.println(SingleTon.getInstance());
            &#125;
        &#125;, <span class="hljs-string">&quot;线程1&quot;</span>).start();
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                System.out.println(SingleTon.getInstance());
            &#125;
        &#125;, <span class="hljs-string">&quot;线程2&quot;</span>).start();

    &#125;
&#125;
<span class="hljs-comment">//多运行几次得到</span>
SingleTon@<span class="hljs-number">6d</span>0ca4c7
SingleTon@<span class="hljs-number">455d</span>5a7e</code></pre>

<h3 id="饿汉式-方法锁-线程安全、效率低"><a href="#饿汉式-方法锁-线程安全、效率低" class="headerlink" title="饿汉式 方法锁(线程安全、效率低)"></a>饿汉式 方法锁(线程安全、效率低)</h3><p>因为每次执行都是同步的，所以效率比较低</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleTon</span><span class="hljs-params">()</span></span>&#123;&#125;;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon Instance;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (Instance == <span class="hljs-keyword">null</span>) &#123;
            Instance = <span class="hljs-keyword">new</span> SingleTon();
        &#125;
        <span class="hljs-keyword">return</span> Instance;
    &#125;
&#125;</code></pre>

<h3 id="饿汉式-Double-CheckLock-双重校验锁-线程安全、效率高"><a href="#饿汉式-Double-CheckLock-双重校验锁-线程安全、效率高" class="headerlink" title="饿汉式 Double CheckLock 双重校验锁(线程安全、效率高)"></a>饿汉式 Double CheckLock 双重校验锁(线程安全、效率高)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleTon</span><span class="hljs-params">()</span></span>&#123;&#125;;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> SingleTon Instance;

    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (Instance == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">synchronized</span> (SingleTon.class) &#123;
                <span class="hljs-keyword">if</span> (Instance == <span class="hljs-keyword">null</span>) &#123;
                    Instance = <span class="hljs-keyword">new</span> SingleTon();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> Instance;
    &#125;
&#125;</code></pre>

<p>需要注意 Instance 采⽤ volatile 关键字修饰也是很有必要。<br>Instance 采⽤ volatile 关键字修饰也是很有必要的， Instance = new Singleton();<br>这段代码其实是分为三步执⾏：<br>    1. 分配内存空间<br>    2. 初始化<br>    3. 将Instance指向分配的内存地址（这个时候已经不为null了）</p>
<p>但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1→3→2。<br>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。<br>例如，线程 T1 执⾏了 1 和 3，此时 T2 调⽤ getInstance() 后发现 Instance 不为空，因此返回Instance，<br>但此时 Instance 还未被初始化。使⽤ volatile 可以禁⽌ JVM 的指令重排，保证在多线程环境下也能正常运⾏。<br><strong>总结</strong>：如果不使用volatile关键词修饰，可能会导致拿到的对象是未被初始化的。</p>
<h3 id="饿汉式-静态内部类"><a href="#饿汉式-静态内部类" class="headerlink" title="饿汉式 静态内部类"></a>饿汉式 静态内部类</h3><p>通过JVM来保证线程安全，高效</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleTon</span><span class="hljs-params">()</span> </span>&#123;
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTonHolder</span> </span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingleTon INSTANCE = <span class="hljs-keyword">new</span> SingleTon();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title">getInstances</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> SingleTonHolder.INSTANCE;
    &#125;
&#125;</code></pre>

<h3 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SingleTonEnum</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 实例</span>
<span class="hljs-comment">     */</span>
    INSTANCE;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//todo</span>
    &#125;
&#125;</code></pre>


<h2 id="如何选用"><a href="#如何选用" class="headerlink" title="如何选用"></a>如何选用</h2><ul>
<li><p>单例对象 占用资源少，不需要延时加载，枚举 好于 饿汉</p>
</li>
<li><p>单例对象 占用资源多，需要延时加载，静态内部类 好于 懒汉式</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>最佳评论系统Valine+Valine-Admin简洁且带邮件通知</title>
    <url>/%E9%97%AE%E9%A2%98%E6%95%99%E7%A8%8B/%E6%9C%80%E4%BD%B3%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine-Valine-Admin%E7%AE%80%E6%B4%81%E4%B8%94%E5%B8%A6%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5.html</url>
    <content><![CDATA[<h2 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a>Valine</h2><p>因为博客最近换了一个主题，想着想着把评论也重新弄一弄，在茫茫网络中探索了一下，发现Valine挺方便，只需要填个用户名和邮箱就可以评论了，不需要登陆。而且用户输入了用户名和邮箱后，会自动把信息存在LocalStorage里面，这样在这个站点只要回复过一次就可以免除反复输入用户名来评论了。</p>
<p>这样的无后端的评论系统虽然是不错，但也存在一个明显存在一个问题，就是用户评论之后，自己怎么知道。自己回复了用户，用户怎么知道。这是一个很重要的问题，需要解决。因为Valine自带的邮件提醒功能将在v1.4.0发布时下线，需要更改为第三方邮件提醒。</p>
<p>所以要解决一个问题：无后端+邮件通知。</p>
<p>这个时候我找到了新的解决方案，Valine-Admin。</p>
<h2 id="Valine-Admin"><a href="#Valine-Admin" class="headerlink" title="Valine-Admin"></a>Valine-Admin</h2><p>Valine Admin 是 Valine 评论系统的扩展和增强，主要实现评论邮件通知、评论管理、垃圾评论过滤等功能。支持完全自定义的邮件通知模板。基于Akismet API实现准确的垃圾评论过滤。此外，使用云函数等技术解决了免费版云引擎休眠问题，支持云引擎自动唤醒，漏发邮件自动补发。兼容云淡风轻及Deserts维护的多版本Valine。</p>
<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><ol>
<li><p>首先在<a href="https://console.leancloud.app/login.html#/signup">LeanCloud</a>注册你的账号，然后创建你的账号.创建自己的应用，拿到AppId和AppKey</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20200719113137.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20200719113137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="700"></li>
<li><p>设置环境变量</p>
 <div class="table-wrap">

<table>
<thead>
<tr>
<th>变量</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SITE_NAME</td>
<td>Deserts</td>
<td>[必填]博客名称</td>
</tr>
<tr>
<td>SITE_URL</td>
<td><a href="https://deserts.io">https://deserts.io</a></td>
<td>[必填]首页地址</td>
</tr>
<tr>
<td><strong>SMTP_SERVICE</strong></td>
<td>QQ</td>
<td>[新版支持]邮件服务提供商，支持 QQ、163、126、Gmail 以及 <a href="https://nodemailer.com/smtp/well-known/#supported-services">更多</a></td>
</tr>
<tr>
<td>SMTP_USER</td>
<td><a href="mailto:xxxxxx@qq.com">xxxxxx@qq.com</a></td>
<td>[必填]SMTP登录用户</td>
</tr>
<tr>
<td>SMTP_PASS</td>
<td>ccxxxxxxxxch</td>
<td>[必填]SMTP登录密码（QQ邮箱需要获取独立密码）</td>
</tr>
<tr>
<td>SENDER_NAME</td>
<td>Deserts</td>
<td>[必填]发件人</td>
</tr>
<tr>
<td>SENDER_EMAIL</td>
<td><a href="mailto:xxxxxx@qq.com">xxxxxx@qq.com</a></td>
<td>[必填]发件邮箱</td>
</tr>
<tr>
<td>ADMIN_URL</td>
<td><a href="https://xxx.leanapp.cn/">https://xxx.leanapp.cn/</a></td>
<td>[建议]Web主机二级域名，用于自动唤醒</td>
</tr>
<tr>
<td>BLOGGER_EMAIL</td>
<td><a href="mailto:xxxxx@gmail.com">xxxxx@gmail.com</a></td>
<td>[可选]博主通知收件地址，默认使用SENDER_EMAIL</td>
</tr>
<tr>
<td>AKISMET_KEY</td>
<td>xxxxxxxxxxxx</td>
<td>[可选]Akismet Key 用于垃圾评论检测，设为MANUAL_REVIEW开启人工审核，留空不使用反垃圾</td>
</tr>
</tbody></table>
 </div>
 以上必填参数请务必正确设置。

<p> 二级域名用于评论后台管理，如<a href="https://deserts.leanapp.cn">https://deserts.leanapp.cn</a> 。</p>
 <img src="https://gitee.com/unclezs/image-blog/raw/master///20200719113845.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20200719113845.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="700"/></li>
<li><p>部署源码<br>点击部署即可，然后服务将会自动部署。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master///20200719114110.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master///20200719114110.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></li>
<li><p>测试</p>
<ul>
<li>访问<a href="https://xxx.avosapps.us/sign-up注册自己的管理员用户名和密码，">https://xxx.avosapps.us/sign-up注册自己的管理员用户名和密码，</a></li>
<li>然后访问<a href="https://xxx.avosapps.us/comments即可查看自己收到的评论了。">https://xxx.avosapps.us/comments即可查看自己收到的评论了。</a></li>
</ul>
</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://valine.js.org/">Valine</a></li>
<li><a href="https://github.com/DesertsP/Valine-Admin">Valine-Admin</a></li>
<li>安装教程请以<a href="https://deserts.io/valine-admin-document/">博客最新版</a>为准。</li>
</ul>
]]></content>
      <categories>
        <category>问题教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>valine</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized与ReentrantLock</title>
    <url>/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Synchronized%E4%B8%8EReentrantLock.html</url>
    <content><![CDATA[<p>Java 里面，最基本的互斥同步手段就是 synchronized 关键字，这是一种块结构( Block Structured ）的同步语法。还有就是 Java 类库中新提供了 java. util.concurrent 包，其中的 java.util.concurrent.locks.Lock 接口便成了 Java 另一 全新的互斥 同步手段。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><ul>
<li>被 synchronized 修饰的同步块对同一条线程来说是可重人的 这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况</li>
<li>被synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会元条件地阻塞后面其他线程的进入 意味着无法像处理某些数据库中 的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出</li>
</ul>
<h3 id="三种使⽤⽅式"><a href="#三种使⽤⽅式" class="headerlink" title="三种使⽤⽅式"></a>三种使⽤⽅式</h3><ol>
<li><strong>修饰实例⽅法</strong>: 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态⽅法</strong>: 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管new了多少个对象，只有⼀份）。所以如果⼀个线程A调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程B需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态<strong>synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。</strong></li>
<li><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。</li>
</ol>
<p><strong>总结</strong>： synchronized 关键字加到 static 静态⽅法和 synchronized(class)代码块上都是是给 Class类上锁。synchronized 关键字加到实例⽅法上是给对象实例上锁。尽量不要使⽤synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="作用于对象的时候"><a href="#作用于对象的时候" class="headerlink" title="作用于对象的时候"></a>作用于对象的时候</h4><p>当synchronized作用于对象时候（即代码块方式），JVM会使用字节码monitorenter，monitorexit来进行同步代码块区分:</p>
<pre><code class="hljs java"> <span class="hljs-number">4</span>: monitorenter
 5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
 <span class="hljs-number">8</span>: sipush        <span class="hljs-number">666</span>
11: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
<span class="hljs-number">14</span>: aload_1
<span class="hljs-number">15</span>: monitorexit</code></pre>

<p>在执行 monitorenter 指令时，首先要去尝试获取对象的锁 如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行 monitorexit 指令时会将锁计数器的值减一 一旦计数器的值为零，锁随即就被释放了 如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p>
<h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）。Mark Word 平时存储这个对象的 哈希码 、 分代年龄 ，当加锁时，这些信息就根据情况被替换为 标记位 、 线程锁记录指 针 、 重量级锁指针 、 线程ID 等内容</p>
<p>高效并发是从 JDK 升级到 JDK 后一项重要的改进项， Hotspot 虚拟机开发团队在这个版本上花费了大 的资源去实现各种锁优化技术，如适应性自旋（ Adaptive Spinning锁消除（ Lock Elimination ）、锁膨胀（ Lock Coarsening 、轻量级锁（ Lightweight Locking）、偏向锁（ Biased Locking ）等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率</p>
<ul>
<li><p>对象头 Mark Word</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20200723174025.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20200723174025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
<li><p>锁之间的转换</p>
</li>
</ul>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20200723174658.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20200723174658.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量，而偏向锁在无竞争的情况下会把整个同步都会消除掉。</p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏” 它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“ 0”），撤销后标志位恢复到未锁定（标志位为“01 ”）或轻量级锁定（标志位为“00 ”）的状态</p>
<p>注意：</p>
<ul>
<li>撤销偏向锁这个过程中所有线程需要暂停（STW）</li>
<li>访问对象的 hashCode 时候，如果对象处于偏向锁，也会撤销偏向锁，并且转换为重量级锁</li>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li>
<li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li>
</ul>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</p>
<ol>
<li><p>加锁：<br>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01 ”状态），那么虚拟机就会在当前线程栈帧中创建一个名字为Lock Record的空间，用于存储当前对象的MarK Word的拷贝（方便后期比较），虚拟机将会使用CAS把对象的Mark Word更新为指向Lock Recod的指针。</p>
<ul>
<li>转化之前的对象头 <img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723182243.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723182243.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="  width="500"/> </li>
<li>转换之后的对象头 <img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723182354.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723182354.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ul>
<p>如果这个更新操作成功了，则代表这个对象获得了这个对象的锁，锁状态变成轻量级锁的“00”。如果失败了，则代表有多个线程正在竞争这个对象的锁，这个时候虚拟机再检查对象的Mark Word的指针是不是指向了当前线程存的Lock Record，如果是则直接进入同步代码块（锁重入）。如果不是则代表锁已经被其他线程占用了。当线程数量两个及以上时候，则可能进行锁膨胀。</p>
</li>
</ol>
<ol start="2">
<li>解锁<br>将Lock Recod存的Mark Word替换回去，同样是使用CAS操作，假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</li>
</ol>
<p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则 如果没有竞争，轻量级锁便通过 CAS 操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销 ，还额外发生了CAS作的开销 因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），如果出现两条及以上的线程争用同一个锁的情况，后来的那条会自旋（循环等待）一定次数来等待锁，如果还是获取不到锁，这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723184722.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723184722.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="700"/>

<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<h4 id="synchronized的其他优化"><a href="#synchronized的其他优化" class="headerlink" title="synchronized的其他优化"></a>synchronized的其他优化</h4><ol>
<li><strong>减少上锁时间</strong>：同步代码块中尽量短</li>
<li><strong>减少锁的粒度</strong>：将一个锁拆分为多个锁提高并发度</li>
<li><strong>锁粗化</strong>：多次循环进入同步块不如同步块内多次循环 另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</li>
<li><strong>锁消除</strong>：JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</li>
<li><strong>读写分离</strong>：CopyOnWriteArrayList、ConyOnWriteSet等</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>重人锁（ ReentrantLock ）是 Lock 接口最常见的一种实现，顾名思义，它与 synchronized样是可重人的 在基本用法上， ReentrantLock 也与 synchronized 很相似，只是代码写法上稍有区别而已 不过， ReentrantLock synchronized 相比增加了一些高级功能，主要有以下 等待可中断、可实现公平锁及锁可以绑定多个条件</p>
<ul>
<li><strong>等待可中断：</strong> 是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情 可中断特性对处理执行时间非常长的同步块很有帮助</li>
<li><strong>公平锁：</strong> 是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何－个等待锁的线程都有机会获得锁 synchronized 中的锁是非公平的， ReentrantLock 默认情况下也是非公平<br>的，但可以通过带布尔值的构造函数要求使用公平锁 不过一旦使用了公平锁，将会导致 ReentrantLock 的性能急剧下降，会明显 吞吐量</li>
<li><strong>锁绑定多个条件：</strong> 是指一个 ReentrantLock 象可以同时绑定多个 Condition 对象synchronized 中，锁对象的 wait() 跟的 notify()或者 notifyAll ()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一<br>个锁；而 ReentrantLock 则无须这样做，多次调用 newCondition（）方法即可</li>
</ul>
<h2 id="Synchronized-和-ReentrantLock-的对比"><a href="#Synchronized-和-ReentrantLock-的对比" class="headerlink" title="Synchronized 和 ReentrantLock 的对比"></a>Synchronized 和 ReentrantLock 的对比</h2><p><strong>① 两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>③ ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p>
<ul>
<li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ul>
<p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p>
<p><strong>④ 性能已不是选择标准</strong></p>
<p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723180607.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master//blog/20200723180607.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>认识CAS与ABA问题</title>
    <url>/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%AE%A4%E8%AF%86CAS%E4%B8%8EABA%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。 CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行 +1 操作</p>
<p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p>
<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
<p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p>
<p>伪代码：</p>
<pre><code class="hljs java"><span class="hljs-comment">// 需要不断尝试</span>
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123; 
  <span class="hljs-keyword">int</span> 旧值 = 共享变量;<span class="hljs-comment">//比如拿到了当前值 0 </span>
  <span class="hljs-keyword">int</span> 结果 = 旧值 + <span class="hljs-number">1</span>;<span class="hljs-comment">//在旧值 0 的基础上增加 1 ，正确结果是 1 </span>

  <span class="hljs-comment">//这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作</span>
  <span class="hljs-comment">//废了，这时候 compareAndSwap 返回 false，重新尝试，直到： compareAndSwap 返回 </span>
  <span class="hljs-comment">//true，表示我本线程做修改的同时，别的线程没有干扰 */</span>
  <span class="hljs-keyword">if</span>( compareAndSwap ( 旧值, 结果 )) &#123; 
    <span class="hljs-comment">// 成功，退出循环 </span>
  &#125;
&#125;</code></pre>

<h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p>
<ol>
<li>循环时间长开销很大。</li>
<li>只能保证一个变量的原子操作。</li>
<li>ABA问题。</li>
</ol>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><h3 id="什么是ABA问题"><a href="#什么是ABA问题" class="headerlink" title="什么是ABA问题"></a>什么是ABA问题</h3><p>ABA问题通俗一点的说，就是一个从内存里面读取到了值A，正在改的时候也检查到了还是A，但是真实的值是被改成了B再改回了A的。</p>
<h3 id="怎么解决ABA"><a href="#怎么解决ABA" class="headerlink" title="怎么解决ABA"></a>怎么解决ABA</h3><p>解决ABA问题就是给操作数加上一个“版本号”，就像Mysql的乐观锁一样。而Java中提供了AtomicStampedReference类来实现这个功能。</p>
<p>AtomicStampedReference类可以给一个引用标记上一个标记位，来保证原子性。AtomicStampedReference可以给一个引用标记上一个整型的版本戳，来保证原子性。</p>
<h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> blog.unclezs.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/26 21:22</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASTest</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String A = <span class="hljs-string">&quot;A&quot;</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String B = <span class="hljs-string">&quot;B&quot;</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String C = <span class="hljs-string">&quot;C&quot;</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; atomic = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(A, <span class="hljs-number">0</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//线程1来了，先检查是否和当前值一样,我准备把A改成C了,并且拿到线程1比较时候的stamp</span>
        <span class="hljs-keyword">boolean</span> same = atomic.attemptStamp(A, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> stamp = atomic.getStamp();
        <span class="hljs-comment">//线程2来了，我准备把A换成B了</span>
        atomic.compareAndSet(A, B, atomic.getStamp(), atomic.getStamp() + <span class="hljs-number">1</span>);
        <span class="hljs-comment">//线程3来了，我准备把B换回A了</span>
        atomic.compareAndSet(A, B, atomic.getStamp(), atomic.getStamp() + <span class="hljs-number">1</span>);
        <span class="hljs-comment">//到线程1来修改了A成C了</span>
        <span class="hljs-keyword">if</span> (same) &#123;
            <span class="hljs-keyword">boolean</span> b = atomic.compareAndSet(A, C, stamp, stamp + <span class="hljs-number">1</span>);
            System.out.println(b?<span class="hljs-string">&quot;修改成功&quot;</span>:<span class="hljs-string">&quot;修改失败ABA了&quot;</span>);
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/v123411739/article/details/79561458">面试必问的CAS，你懂了吗？</a></li>
<li><a href="https://blog.csdn.net/justry_deng/article/details/83449038">CAS算法与ABA问题</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet 3.0 通过SPI 进行注册组件，SpringMVC 无web.xml配置采用此种方式</title>
    <url>/Java/javaee/Servlet-3-0-%E9%80%9A%E8%BF%87SPI-%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%EF%BC%8CSpringMVC-%E6%97%A0web-xml%E9%85%8D%E7%BD%AE%E9%87%87%E7%94%A8%E6%AD%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h1><p>SPI ，全称为 Service Provider Interface，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。</p>
<p>这一机制为很多框架扩展提供了可能，比如在JDBC的加载驱动方式也是采用了这种方式，只需要导入对应驱动jar包则可以自动注册驱动。<br>本文提到的Servlet3.0也提供了这一机制，只需要在META-INF/services下面创建javax.servlet.ServletContainerInitializer这一文件，并在里面填入需要在Tomcat启动的时候加载的类的全限定类名即可，如果有多个，一行一个。</p>
<h1 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h1><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><ol>
<li>首先引入Servlet-Api</li>
<li>创建一个类实现ServletContainerInitializer接口，并重写onStartup方法</li>
<li>在src/META-INF下面创建上述文件，并在其中填入创建的类的全限定类名</li>
<li>配置tomcat并启动项目即可</li>
</ol>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><ol>
<li><p>maven创建工程引入Servet-Api并改打包方式为war</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182200.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182200.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
<li><p>创建MyServletContainerInitializer实现ServletContainerInitializer</p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.initializer;

<span class="hljs-keyword">import</span> javax.servlet.ServletContainerInitializer;
<span class="hljs-keyword">import</span> javax.servlet.ServletContext;
<span class="hljs-keyword">import</span> javax.servlet.ServletException;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> uncle</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/3/20 20:51</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;
      System.out.println(<span class="hljs-string">&quot;容器初始化了&quot;</span>)
    &#125;
&#125;
</code></pre>

<ol>
<li><p>在src下面创建META-INF/service/javax.servlet.ServletContainerInitializer</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182311.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182311.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
<li><p>配置Tomcat启动查看效果</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182345.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182345.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ol>
<h2 id="细节说明"><a href="#细节说明" class="headerlink" title="细节说明"></a>细节说明</h2><p>可以看到，当我们实现了ServletContainerInitializer接口的话，在onStartUp方法中传入了</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span></span>&#123;&#125;</code></pre>

<p>其中的ServletContext我们已经熟悉，为Servlet的上下文，可以做web.xml里面可以做的事情</p>
<p>这个Set集合传入的class则需要配合一个@HandlesTypes注解了</p>
<pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> HandlesTypes &#123;
    Class&lt;?&gt;[] value();
&#125;</code></pre>

<p>容器启动的时候会将@HandlesTypes指定的这个类型下面的子类（实现类，子接口等）传递过来。<br>所以如果我们需要做一些额外的定制的话可以写一个这样的接口，SpringMVC的WebApplicationInitializer就是这么一个接口。</p>
<h2 id="SpringMVC中使用这个机制"><a href="#SpringMVC中使用这个机制" class="headerlink" title="SpringMVC中使用这个机制"></a>SpringMVC中使用这个机制</h2><p>打开Spring-Web这个jar包一看<br><img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182415.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182415.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></p>
<p>可以看到就是利用在Servlet3.0更新的SPI机制，其中WebApplicationInitializer这个接口，就是我们用来配置无web.xml搭建springmvc项目的时候用到的类。</p>
<p>贴一下无web.xml配置一个最小SpringMVC项目</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.config;

<span class="hljs-keyword">import</span> org.springframework.web.WebApplicationInitializer;
<span class="hljs-keyword">import</span> org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.DispatcherServlet;

<span class="hljs-keyword">import</span> javax.servlet.ServletException;
<span class="hljs-keyword">import</span> javax.servlet.ServletRegistration;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> uncle</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019.12.31</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebApplicationInitializer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(javax.servlet.ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;
        AnnotationConfigWebApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigWebApplicationContext();
        ctx.scan(<span class="hljs-string">&quot;com.unclezs&quot;</span>);
        ServletRegistration.Dynamic mvc = servletContext.addServlet(<span class="hljs-string">&quot;springmvc&quot;</span>, <span class="hljs-keyword">new</span> DispatcherServlet(ctx));
        mvc.addMapping(<span class="hljs-string">&quot;/&quot;</span>);
        mvc.setLoadOnStartup(<span class="hljs-number">1</span>);
    &#125;
&#125;
</code></pre>

<p>配置好Tomcat直接启动就可可以了，是不是贼清爽~</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>javaee</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Aop 注解方式食用</title>
    <url>/Java/Spring/Spring-Aop-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%A3%9F%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="Aop简介"><a href="#Aop简介" class="headerlink" title="Aop简介"></a>Aop简介</h1><p>Aop(Aspect-OrientedProgramming 面向切面编程)。在面向对象编程中，常用封装、多态和继承这些来建立一个层次结果，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候。面向对象的对象就显得有些无力。因为这个时候我们通常用继承和委派来实现对重复代码的利用，但是当我们需要记录日志、和事务操作这些的时候，如果我们还采用继承的话会导致每个类都继承一个Log类，显得有些臃肿，用委派的话会显得类比较笨重，重要的是这些与我们业务无关的代码大量嵌入了进来。</p>
<p>所以这个时候就需要了Aop的重左到右的来实现，直接将重复的代码封装到一个切面，当然后定义一些切点来声明这些重复代码需要在哪些地方执行。定义一些连接点来标明什么时候需要执行，比如方法执行前执行后之类的。</p>
<h1 id="Spring-Aop"><a href="#Spring-Aop" class="headerlink" title="Spring Aop"></a>Spring Aop</h1><h2 id="一些通知的注解"><a href="#一些通知的注解" class="headerlink" title="一些通知的注解"></a>一些通知的注解</h2><p>在环绕通知的时候，会传入一个ProceedingJoinPoint参数给环绕方法，执行其Process()方法即为调用了原来的方法，必须调用，不然会阻塞</p>
<h2 id="切点的过滤及匹配的一些方式"><a href="#切点的过滤及匹配的一些方式" class="headerlink" title="切点的过滤及匹配的一些方式"></a>切点的过滤及匹配的一些方式</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182533.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182533.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h3 id="execution的写法"><a href="#execution的写法" class="headerlink" title="execution的写法"></a>execution的写法</h3><img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182542.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182542.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>当有多个条件的时候可以用 &amp;&amp; 符号或者 and 来连接 还有 not 、! 、or、||这些</p>
<h2 id="通过注解方式创建的实例"><a href="#通过注解方式创建的实例" class="headerlink" title="通过注解方式创建的实例"></a>通过注解方式创建的实例</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unclezs.spring.aop;

<span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;
<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-keyword">import</span> java.util.Objects;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> uncle</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/3/20 10:18</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopTest</span> </span>&#123;
    <span class="hljs-meta">@Pointcut(&quot;@within(com.unclezs.spring.aop.annotation.AopPoint)&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;before&quot;</span>);
    &#125;

    <span class="hljs-meta">@After(&quot;pointcut()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;after&quot;</span>);
    &#125;

    <span class="hljs-meta">@AfterReturning(&quot;pointcut()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;afterReturning&quot;</span>);
    &#125;

    <span class="hljs-meta">@AfterThrowing(&quot;pointcut()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;afterThrowing&quot;</span>);
    &#125;

    <span class="hljs-meta">@Around(&quot;pointcut()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(<span class="hljs-string">&quot;环绕Before&quot;</span>);
            Object proceed = joinPoint.proceed();
            System.out.println(<span class="hljs-string">&quot;环绕After&quot;</span>);
            <span class="hljs-keyword">return</span> proceed;
        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;
            System.out.println(<span class="hljs-string">&quot;环绕afterThrowing&quot;</span>);
            throwable.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;
</code></pre>
<p>需要注意的是，在使用SpringAop的时候需要在配置类上面添加@EnableAspectJAutoProxy注解才能生效</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中Profiles的作用及原理浅析</title>
    <url>/Java/Spring/Spring%E4%B8%ADProfiles%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90.html</url>
    <content><![CDATA[<h2 id="什么是Profile"><a href="#什么是Profile" class="headerlink" title="什么是Profile"></a>什么是Profile</h2><p>profile是用户区别环境来执行那些代码的，在我们日常开发中经常需要由开发环境到生产环境切换，这个时候需要更改数据库、redis等等这些的连接地址和密码，改完再打包，然后再改回来，这样实在是繁琐且多余。而Profile的作用正是解决这个问题的。</p>
<h2 id="Spring中使用Profile的例子"><a href="#Spring中使用Profile的例子" class="headerlink" title="Spring中使用Profile的例子"></a>Spring中使用Profile的例子</h2><ol>
<li><p>创建根据Profile配置的配置类</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;
    <span class="hljs-keyword">private</span> String message;
&#125;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile(&quot;dev&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DevConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Message <span class="hljs-title">message</span><span class="hljs-params">()</span> </span>&#123;
        Message message = <span class="hljs-keyword">new</span> Message();
        message.setMessage(<span class="hljs-string">&quot;dev env&quot;</span>);
        <span class="hljs-keyword">return</span> message;
    &#125;
&#125;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile(&quot;pro&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Message <span class="hljs-title">message</span><span class="hljs-params">()</span> </span>&#123;
        Message message = <span class="hljs-keyword">new</span> Message();
        message.setMessage(<span class="hljs-string">&quot;pro env&quot;</span>);
        <span class="hljs-keyword">return</span> message;
    &#125;
&#125;</code></pre></li>
<li><p>测试根据激活的Profile来配置</p>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span>
<span class="hljs-meta">@ContextConfiguration(classes = ContextConfig.class)</span>
<span class="hljs-meta">@ActiveProfiles(&quot;pro&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringTest</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> Message message;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProfile</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(message.getMessage());
    &#125;
&#125;</code></pre>
<p>其中ContextConfiguration是指定包扫描的，里面就配置了ComponetScan<br>@ActiveProfile是指定激活的Profile，值可以是数组<br>比如同时激活两个环境@ActiveProfile({“dev”,”pro”})</p>
</li>
<li><p>运行代码测试</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182613.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182613.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ol>
<h2 id="浅析源码"><a href="#浅析源码" class="headerlink" title="浅析源码"></a>浅析源码</h2><p>用户标记在什么环境下启用，使用实示例@Profile(“dev”)。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Conditional(ProfileCondition.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Profile &#123;
	String[] value();
&#125;
</code></pre>
<p>条件匹配，当满足条件的时候才使这个配置生效。value也得以证明是一个数组，可以传入多个profile,可以看到里面有一个@Conditional注解，可以跟进Conditional的源码看看</p>
<pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Conditional&#123;
	Class&lt;? extends Condition&gt;[] value();
&#125;</code></pre>
<p>里面的需要传入实现了Condition接口，而再@Profile中的@Conditional里面传入了ProfileCondition.class，可以再看看ProfileCondition的源码</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;
		MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
		<span class="hljs-keyword">if</span> (attrs != <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">for</span> (Object value : attrs.get(<span class="hljs-string">&quot;value&quot;</span>)) &#123;
				<span class="hljs-keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
				&#125;
			&#125;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
	&#125;

&#125;</code></pre>
<p>他实现了Condition接口，ConditionContext里面可以拿到当前环境的激活的Profile然后从AnnotatedTypeMetadata中拿到@Profile注解的value值，然后对比是否包含当前环境的Profile，如果有则返回true，条件生效。</p>
<h2 id="激活Profile"><a href="#激活Profile" class="headerlink" title="激活Profile"></a>激活Profile</h2><p>激活方式是设置spring.profiles.active的值，可以是一个数组。也可以设置spring.profiles.default来指定默认激活的profile。<br>通常我们可以通过一下几种方式来改变profile</p>
<ul>
<li>在spring-web中通过DispatcherServlet传入spring.profiles.default,比如：</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>spring.profiles.default<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre>
<p>在DispatcherServlet中可以通过super.getServletConfig().getInitParameter(“spring.profiles.default”)获取</p>
<ul>
<li>在web应用中使用context上下问参数来指定</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>spring.profiles.default<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre>
<p>在Servlet中可以通过getServletConfig().getServletContext().getInitParameter(“spring.profiles.default”)获取。</p>
<ul>
<li>作为JNDI条目，JDNI是Java 命名与目录接口(Java Naming and Directory Interface)</li>
<li>作为环境变量，设置一个名字为spring.active.profile的环境变量</li>
<li>作为JVM的参数，比如java -jar xxx.jar –spring.profile.active=dev</li>
<li>在测试类中可以使用@ActiveProfiles注解指定</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>profile</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之Bean的生命周期</title>
    <url>/Java/Spring/Spring%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content><![CDATA[<h2 id="spring-bean与普通bean"><a href="#spring-bean与普通bean" class="headerlink" title="spring-bean与普通bean"></a>spring-bean与普通bean</h2><p>Spring创建一个Bean不像是传统的javaBean一样，简单的new一个出来，用了等着被回收就完了，Spring对Bean的创建和销毁过程都加入了一些关于Spring本身的操作，比如当Spring容器销毁的时候自动调用Bean的destory方法，如果这个Bean实现了DisposableBean接口的话。</p>
<h2 id="图解Spring-Bean的生命周期"><a href="#图解Spring-Bean的生命周期" class="headerlink" title="图解Spring-Bean的生命周期"></a>图解Spring-Bean的生命周期</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182559.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182559.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="文解Spring-Bean生命周期"><a href="#文解Spring-Bean生命周期" class="headerlink" title="文解Spring-Bean生命周期"></a>文解Spring-Bean生命周期</h2><p>1.Spring对Bean进行实例化<br>2.将依赖的Bean进行注入，和传入值进行赋值到属性中。<br>3.如果Bean实现了BeanNameAware接口，Spring将调用setBeanName将Bean的Id传入进来</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanNameAware</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name=name;
        <span class="hljs-comment">//do something</span>
    &#125;
&#125;</code></pre>

<p>4.如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory将BeanFactory传入进来</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryAware</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
        <span class="hljs-comment">//do something</span>
    &#125;
&#125;</code></pre>

<p>5.如果Bean实现了ApplicationContextAware接口，那么Spring将会把applicationContext传入调用setApplicationContext方法，这个可以用户获取上下文对象来手动获取Bean</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span><span class="hljs-keyword">throws</span> BeansException </span>&#123;
        <span class="hljs-comment">//拿到ApplicationContext对象</span>
    &#125;
&#125;</code></pre>

<p>6.如果实现了BeanPostProcessor，则调用post-ProcessBeforeInitialization方法。<br>7.如果Bean实现了InitializingBean，那么则调用after-PropertiesSet<br>8.如果Bean实现了BeanPostProcessor接口，Spring将调用post-ProcessAfterInitialization方法，这个时候Bean已经加载好了，直到被销毁。<br>9.如果Bean实现了DisposableBean接口，那么在Bean销毁的时候将会自动调用该Bean的destory方法。</p>
<h2 id="一个实用的使用方式"><a href="#一个实用的使用方式" class="headerlink" title="一个实用的使用方式"></a>一个实用的使用方式</h2><p>根据以上周期，可以根据其特性来创建一个Spring上下文工具类。使用范围一般在一些静态方法里面使用Spring容器里面的Bean和一些非SpringBean中调用SpringBean对象的时候。SpringContextHolder.getBean(xxx.class) 即可</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringContextHolder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 从静态变量applicationContext中取得Bean, 自动转型为所赋值对象的类型.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> </span>&#123;
        assertContextInjected();
        <span class="hljs-keyword">return</span> (T) applicationContext.getBean(name);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 从静态变量applicationContext中取得Bean, 自动转型为所赋值对象的类型.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> </span>&#123;
        assertContextInjected();
        <span class="hljs-keyword">return</span> applicationContext.getBean(requiredType);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 检查ApplicationContext不为空.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assertContextInjected</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (applicationContext == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;applicaitonContext属性未注入, 请在applicationContext&quot;</span> +
                    <span class="hljs-string">&quot;.xml中定义SpringContextHolder或在SpringBoot启动类中注册SpringContextHolder.&quot;</span>);
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 清除SpringContextHolder中的ApplicationContext为Null.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearHolder</span><span class="hljs-params">()</span> </span>&#123;
        log.debug(<span class="hljs-string">&quot;清除SpringContextHolder中的ApplicationContext:&quot;</span>
                + applicationContext);
        applicationContext = <span class="hljs-keyword">null</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;
        SpringContextHolder.clearHolder();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
        <span class="hljs-keyword">if</span> (SpringContextHolder.applicationContext != <span class="hljs-keyword">null</span>) &#123;
            log.warn(<span class="hljs-string">&quot;SpringContextHolder中的ApplicationContext被覆盖, 原有ApplicationContext为:&quot;</span> + SpringContextHolder.applicationContext);
        &#125;
        SpringContextHolder.applicationContext = applicationContext;
    &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖注入与松耦合</title>
    <url>/Java/Spring/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%9D%BE%E8%80%A6%E5%90%88.html</url>
    <content><![CDATA[<h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p>耦合就是一个类依赖于其他的类才能完成其功能。<br>耦合具有两面性，一个方面是难以测试，难以复用和难以理解，另外一个方面是我们却不得不耦合，完全没有耦合的代码几乎啥都干不了。<br>所以耦合是必须的，但是必须得好好管理可以。</p>
<h2 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h2><p>先来看看耦合的<br><strong>例子1-1</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChiFan</span></span>&#123;
    <span class="hljs-keyword">private</span> Kuaizi kuaizi;
    ChiFan()&#123;
        <span class="hljs-keyword">this</span>.kuaizi=<span class="hljs-keyword">new</span> kuaizi();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">this</span>.kuaizi.eat();
    &#125;
&#125;</code></pre>
<p>吃饭需要用到筷子，所以吃饭之前必须得有个筷子，但是吃饭不一定得用筷子，也可以用叉子等等。<br>这个时候如果要改成叉子就需要改变代码了，这个时候就体现了耦合性得缺点。</p>
<p>再看看松耦合的<br><strong>例子1-2</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChiFan</span></span>&#123;
    <span class="hljs-keyword">private</span> Tool tool;
    ChiFan(Tool tool)&#123;
        <span class="hljs-keyword">this</span>.tool=tool;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">this</span>.tool.eat();
    &#125;
&#125;</code></pre>
<p>这里可以看到我们使用接口Tool来当作参数，要吃饭必须给一个吃饭的工具才行，而这个工具是可以有多种实现，可以用筷子实现也可以用叉子实现，这里也体现了多态性。</p>
<h2 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入(DI)"></a>依赖注入(DI)</h2><p>依赖注入的思想与传统的做法不同在于</p>
<ul>
<li>传统做法是每个对象自己管理自己需要的相互协作的对象,如同<strong>例子1-1</strong>那样，在自己里面直接new一个出来。</li>
<li>依赖注入就是这个对象去请求要一个这样的对象才能完成工作，这个依赖对象可以set方法进来的也可以是构造方法进来的,一般推荐使用构造方法进来，因为你这个对象没了那些依赖对象无法进行工作，所以如果没有这些依赖对象直接不能创建类的实例才是。一句话概括就是依赖注入会将依赖关系的关系自动交给目标对象，而不是是自己去获取依赖。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>耦合</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet回顾 之 源码入手</title>
    <url>/Java/javaee/Servlet%E5%9B%9E%E9%A1%BE-%E4%B9%8B-%E6%BA%90%E7%A0%81%E5%85%A5%E6%89%8B.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>感觉用了太久的框架这Servlet写着都有点陌生了，所以打算重温下。还有一个原因就是因为Servlet当时第一次学的时候并没有学习Spring也没有刨源码学,所以在学习了SpringMVC的时候就不知道这个MVC是如何接管了。</p>
<h2 id="Servlet与tomcat"><a href="#Servlet与tomcat" class="headerlink" title="Servlet与tomcat"></a>Servlet与tomcat</h2><ol>
<li><p>与tomcat之间的交互</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182454.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182454.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>
</li>
<li><p>Servlet继承树</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/20210103182513.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/20210103182513.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

</li>
</ol>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="tomcat配置"><a href="#tomcat配置" class="headerlink" title="tomcat配置"></a>tomcat配置</h3><h4 id="1-context-xml的配置"><a href="#1-context-xml的配置" class="headerlink" title="1. context.xml的配置"></a>1. context.xml的配置</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">WatchedResource</span>&gt;</span>WEB-INF/web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">WatchedResource</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">WatchedResource</span>&gt;</span>WEB-INF/tomcat-web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">WatchedResource</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">WatchedResource</span>&gt;</span>$&#123;catalina.base&#125;/conf/web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">WatchedResource</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span></code></pre>

<p>可以看到tomcat服务器启动项目的时候会加载 WEB-INF 下面的xml配置，${catalina.base}代表的就是tomcat的home目录。<br>也就是说tomcat跑起来的时候会自动加载tomcat的home目录下面的conf/web.xml<br>里面配置了默认的Servlet，也就是我们安装tomcat后默认打开的看到的那个tomcat网页的原因。<br>也定义了一些默认的mine-mapping用户文件访问。</p>
<h4 id="2-ServletContextListener"><a href="#2-ServletContextListener" class="headerlink" title="2. ServletContextListener"></a>2. ServletContextListener</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServletContextListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventListener</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;&#125;
&#125;</code></pre>

<p>如果监听器实现了这个接口，在Servlet容器初始化的时候会调用contextInitialized，在SpringMVC框架中就是实现了这个接口对XmlWebApplicationContext进行实例化创建了Spring容器<br>在销毁的时候调用contextDestroyed方法。</p>
<ol>
<li>ServletContext<br>Servlet的上线文对象，每个应用只有一个上下文对象，这个对像是根据web.xml来创建的，里面有addListenr、addFilter等方法，具体可以自行查看。</li>
</ol>
<h4 id="3-ServletConfig"><a href="#3-ServletConfig" class="headerlink" title="3. ServletConfig"></a>3. ServletConfig</h4><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServletConfig</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletName</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletContext <span class="hljs-title">getServletContext</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInitParameter</span><span class="hljs-params">(String name)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;String&gt; <span class="hljs-title">getInitParameterNames</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>

<p>这个是在Servlet被创建的时候会传入一个ServletConfig对象进Servlet，可以获取到容器的Servlet的上下文，比如在web.xml里面配置的<context-param>,就可以通过此获取到</p>
<ol>
<li>Servlet</li>
</ol>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Servlet</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span><span class="hljs-keyword">throws</span> ServletException, IOException</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>;
&#125;
</code></pre>

<p>当tomcat将servlet实例化之后将会调用Servlet的service方法，并将封装好的ServletRequest和ServletResponse方法传入</p>
<ol>
<li>GenericServlet</li>
</ol>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span>, <span class="hljs-title">ServletConfig</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123;
    <span class="hljs-comment">//func...</span>
&#125;</code></pre>

<p>这个是一个对Servlet的增强方法，可以方便的获取到Servlet上下文信息,和上下文参数</p>
<ol>
<li>HttpServlet</li>
</ol>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericServlet</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req,HttpServletResponse resp)</span></span>&#123;
        String protocol = req.getProtocol();
        String msg = lStrings.getString(<span class="hljs-string">&quot;http.method_get_not_supported&quot;</span>);
        <span class="hljs-keyword">if</span> (protocol.endsWith(<span class="hljs-string">&quot;1.1&quot;</span>)) &#123;
            resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);
        &#125; <span class="hljs-keyword">else</span> &#123;
            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req,HttpServletResponse resp)</span></span>&#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPut</span><span class="hljs-params">(HttpServletRequest req,HttpServletResponse resp)</span></span>&#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doHead</span><span class="hljs-params">(HttpServletRequest req,HttpServletResponse resp)</span></span>&#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDelete</span><span class="hljs-params">(HttpServletRequest req,HttpServletResponse resp)</span></span>&#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOptions</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTrace</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123;
        String method = req.getMethod();
        <span class="hljs-keyword">if</span> (method.equals(METHOD_GET)) &#123;
            <span class="hljs-keyword">long</span> lastModified = getLastModified(req);
            <span class="hljs-keyword">if</span> (lastModified == -<span class="hljs-number">1</span>) &#123;
                doGet(req, resp);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
                <span class="hljs-keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;
                    maybeSetLastModified(resp, lastModified);
                    doGet(req, resp);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_HEAD)) &#123;
            <span class="hljs-keyword">long</span> lastModified = getLastModified(req);
            maybeSetLastModified(resp, lastModified);
            doHead(req, resp);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_POST)) &#123;
            doPost(req, resp);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_PUT)) &#123;
            doPut(req, resp);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_DELETE)) &#123;
            doDelete(req, resp);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;
            doOptions(req,resp);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_TRACE)) &#123;
            doTrace(req,resp);
        &#125; <span class="hljs-keyword">else</span> &#123;
            String errMsg = lStrings.getString(<span class="hljs-string">&quot;http.method_not_implemented&quot;</span>);
            Object[] errArgs = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1</span>];
            errArgs[<span class="hljs-number">0</span>] = method;
            errMsg = MessageFormat.format(errMsg, errArgs);
            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
        &#125;
    &#125;
&#125;</code></pre>

<p>这是Servlet的Http封装，一般我们编写Servlet的时候都是继承自这个类，这里面的doXXX方法统计都是响应方法不被支持，这个是为了如果我们没有重写这个方法，那么这个接口将不支持这个请求方法。在service里面就是对这些doXXX的调用，因为Servelt被tomcat调用的只有这个Service方法。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>javaee</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之Bean的作用域</title>
    <url>/Java/Spring/Spring%E4%B9%8BBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content><![CDATA[<p>在Spring中，bean作用域用于确定哪种类型的bean实例应该从Spring容器中返回给调用者。</p>
<p>目前Spring Bean的作用域或者说范围主要有五种。</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</td>
</tr>
<tr>
<td>prototype</td>
<td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</td>
</tr>
<tr>
<td>request</td>
<td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。</td>
</tr>
<tr>
<td>session</td>
<td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。</td>
</tr>
<tr>
<td>application</td>
<td>限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</td>
</tr>
<tr>
<td>websocket</td>
<td>将单个bean定义的作用域限定为的生命周期WebSocket。仅在可感知网络的Spring上下文中有效ApplicationContext。</td>
</tr>
</tbody></table>
<p>官方文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes">Bean Scopes</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>出生第一篇，介绍下怎么出生的</title>
    <url>/%E5%87%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%B8%8B%E6%80%8E%E4%B9%88%E5%87%BA%E7%94%9F%E7%9A%84.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>大一的时候在用 WordPress 搭建了一个博客，但是坚持写了几个月的博客，后来发现没有什么人看，于是就迁移到了CSDN。</p>
<p>CSDN也用了快两年了，但是有段时间突然没有写博客的动力，感觉自己的博客没有什么含金量，于是停下了博客，加紧提升自己去了。</p>
<p>现在大三快结束了，正准备参加秋招实习面试了，于是开始恶补自己的盲区与基础，但是在这个过程中觉得有些东西确实应该记录下，于是有了这个博客的诞生，于是开始选型，主要需求就是便于迁移，和使用方便，不像wordpress那样笨重，但是也需要有点颜值的，于是相中了Hexo+butterfly这套。  </p>
<p>本来是打算使用github pages来部署的，但是发现访问实在是汗颜，于是想着去码云，发现码云居然自定义域名需要99/年的服务费，然后想着用gitlab发现还是很慢，于是自己搭建了一个gitlab，打算用CI部署到Nginx，结果给我用掉了1个多G内存。实在是伤不起，于是决定还是老实用自己的服务器上搭个Nginx来跑了。</p>
<p>2020-8-9 更新</p>
<p>对主题Maupassant进行DIY改成了现在自己还算满意的样子，主要更改是添加阅读时候的目录显示，与正文显示主题样式。</p>
<p><strong>最终方案：</strong></p>
<table>
<thead>
<tr>
<th align="center">服务器</th>
<th align="center">博客框架</th>
<th align="center">博客主题</th>
<th align="center">部署方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Nginx</td>
<td align="center">Hexo</td>
<td align="center">Maupassant</td>
<td align="center">sftp</td>
</tr>
</tbody></table>
<h2 id="博客搭建过程"><a href="#博客搭建过程" class="headerlink" title="博客搭建过程"></a>博客搭建过程</h2><h3 id="环境及工具问题"><a href="#环境及工具问题" class="headerlink" title="环境及工具问题"></a>环境及工具问题</h3><h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><ul>
<li>Node.js</li>
<li>VsCode</li>
</ul>
<h4 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h4><ul>
<li>装好Nginx的服务器一台</li>
</ul>
<h3 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>因为都是中文文档并且很详细，所以没有必要说啥安装配置教程，自己看看就能够装好了。</p>
<ul>
<li>首先按照Hexo官网中文文档装好<a href="https://hexo.io/zh-cn">Hexo</a></li>
<li>然后按照<a href="https://jerryc.me/posts/21cfbf15">maupassant</a>官网文档装好并且配置好。</li>
</ul>
<h4 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h4><h5 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h5><p>Hexo的部署方式有很多，git和ftp还有其他一些代码托管中心，当然也可以自己复制public下面的文件随便丢到一个服务器就行了。</p>
<p>如果你想要快并且不需要自定义域名，那么你可以选择码云的Pages服务，因为在国内访问速度还是很可观的。</p>
<p>我选择sftp方式，因为搭建ftp服务也会占用，而stfp是建立在ssh服务上的，如果你有装了ssh那么sftp也有了，不需要另外再去搭建了。sftp比ftp更加安全，但是效率上会低一点，因为我们的博客部署没多大的多西，所以感觉不到什么慢的。</p>
<h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p>修改hexo根目录里面的_config.yml文件，拉到最下面有个deploy，具体配置方式可以参见<a href="https://hexo.io/zh-cn/docs/one-command-deployment">Hexo配置部署文档</a>,这里面还是很详细的。这里贴下sftp部署的代码。</p>
<pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">sftp</span> <span class="hljs-comment"># 部署方式</span>
  <span class="hljs-attr">host:</span> <span class="hljs-string">blog.unclezs.com</span> <span class="hljs-comment">#主机地址</span>
  <span class="hljs-attr">user:</span> <span class="hljs-string">unclezs</span> <span class="hljs-comment"># 用户名</span>
  <span class="hljs-attr">pass:</span> <span class="hljs-string">unclezs</span> <span class="hljs-comment"># 密码</span>
  <span class="hljs-attr">remotePath:</span> <span class="hljs-string">/nignx/html/xxx</span> <span class="hljs-comment">#部署到的目录</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">22</span> <span class="hljs-comment"># SSH端口号</span></code></pre>

<p>然后只需要执行一下 hexo deploy就可以部署到服务器访问自己的域名即可了。</p>
<h2 id="当前"><a href="#当前" class="headerlink" title="当前"></a>当前</h2><p>已经改主题，网站下面</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离与不分离的登录方式解析</title>
    <url>/Web%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%8E%E4%B8%8D%E5%88%86%E7%A6%BB%E7%9A%84%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><h4 id="1-1-起因"><a href="#1-1-起因" class="headerlink" title="1.1 起因"></a>1.1 起因</h4><p>现在越来越流行前后端分离的方式进行开发了，做Web开发的，逃不掉的就是登录了，因为前后端分离登录与传统的方式不再相同，所以就想总结下它们各自的实现方式</p>
<h4 id="1-2-什么是前后端不分离"><a href="#1-2-什么是前后端不分离" class="headerlink" title="1.2 什么是前后端不分离"></a>1.2 什么是前后端不分离</h4><p>前后端不分离也就是前端的页面是由后端进行渲染的，也就是前端的只负责写样式和JS，后端负责填充数据，前端代码里面混杂着后端代码，两者的耦合度非常高，就像JSP那样，这种实现就不容易维护，一旦除了问题前后端都得返工，开发效率低下；</p>
<h4 id="1-3-什么是前后端分离"><a href="#1-3-什么是前后端分离" class="headerlink" title="1.3 什么是前后端分离"></a>1.3 什么是前后端分离</h4><p>为了解决不分离情况下带来的弊端，把页面渲染数据这部分从后端手中抽离出来，交由前端去做，当然这里不是直接让他去干后端的代码，而是前端所有用到的数据都是后端通过异步接口的方式提供的，前端将数据通过ajax异步请求把数据拿到，然后负责展示即可。这样的好处就是，你前端不管想怎么改样式后端都不用管，因为里面没有了后端代码，你怎么改也不关后端的事情了</p>
<h4 id="1-4-完全分离–Mock"><a href="#1-4-完全分离–Mock" class="headerlink" title="1.4 完全分离–Mock"></a>1.4 完全分离–Mock</h4><p>上面分离确实是将前后端分离开了，但是还有一个问题，就是这样并没有提高太多效率，因为你前端开发的时候需要后端的数据接口才能完整开发，应对这样的情况，应运而生的Mock就起到了关键作用，Mock就是模拟后端的数据接口，需要什么数据都可以模拟出来，等到后面对接后端的时候只需要把Mock的接口地址换成真正的接口就地址就可以了，这样前端也就完全脱离了后端进行开发了</p>
<h2 id="二、关于登录的必要概念"><a href="#二、关于登录的必要概念" class="headerlink" title="二、关于登录的必要概念"></a>二、关于登录的必要概念</h2><h4 id="2-1-什么是session"><a href="#2-1-什么是session" class="headerlink" title="2.1 什么是session"></a>2.1 什么是session</h4><p>session是一次浏览器和服务器交互的会话，在jsp中，作为一个内置对象存在。我的理解，就是当用户打开网页时，程序会在浏览器中开辟一段空间来存储作为session的存储，可以对一些用户信息进行保存。session就是一个会话级别的cokkie，外加服务器内存中的一组散列表。当关闭浏览器时，cookie会消失，session也就消失了，这个cookie不写在磁盘上，而是写在浏览器的缓存中。</p>
<h4 id="2-2-session和cookie的区别"><a href="#2-2-session和cookie的区别" class="headerlink" title="2.2 session和cookie的区别"></a>2.2 session和cookie的区别</h4><ol>
<li>cookie数据存放在客户的浏览器中，session数据放在服务器上</li>
<li>cookie不是很安全，别人可以轻易的获取本地的cookie并获取相关信息进行欺诈</li>
<li>session有时间限制，会在设置的一定时间内保存到服务器上。</li>
<li>cookie有限制，单个为3k，一个站点在客户端存放的cookie不能超过3k</li>
</ol>
<p>所以一般将登陆的用户信息保存到session上，以防被盗，如果是其他信息，可以放在cookie里面，如果考虑到服务器的性能，减轻压力，应该使用cookie</p>
<h2 id="三、前后端不分离的登录实现方式"><a href="#三、前后端不分离的登录实现方式" class="headerlink" title="三、前后端不分离的登录实现方式"></a>三、前后端不分离的登录实现方式</h2><p>因为前后端不分离的情况下，我们可以基于Cookie和Session来实现登录；大致流程就是：</p>
<ol>
<li>前端发起登录请求</li>
<li>后端验证是否登录成功，成功则记录一个Session，响应的时候把SessionID写入Cookie</li>
<li>每次请求都会带着Cookie</li>
<li>后端可以根据Cookie中的Session来确认你是否登录过，而保持登录状态</li>
</ol>
<h2 id="四、前后端分离情况下"><a href="#四、前后端分离情况下" class="headerlink" title="四、前后端分离情况下"></a>四、前后端分离情况下</h2><h4 id="4-1-有状态登录"><a href="#4-1-有状态登录" class="headerlink" title="4.1 有状态登录"></a>4.1 有状态登录</h4><p>分离的情况下，服务器也能为你写上Session到Cookie，但是对于Ajax默认对于跨域请求是不带Cookie的，这时候有两种解决方式，<br>1.设置ajax请求默认全部带上Cookie,并且后端开启跨域支持，<br>2.通过代理实现不跨域，开发阶段可以用Webpack的proxy，部署阶段可以用nginx的反向代理</p>
<h4 id="4-2-无状态登录Token"><a href="#4-2-无状态登录Token" class="headerlink" title="4.2 无状态登录Token"></a>4.2 无状态登录Token</h4><p>什么叫无状态，也就是服务器不保存你的登录状态，不保存登录状态那服务器怎么知道你登陆了呢，原因很简单，就是Token里面保存了你的信息，就像这样</p>
<pre><code class="hljs java">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHBpcmVUaW1lIjoxNTQ5NTU0NDUyLCJ1c2VyTmFtZSI6IuacveacqCIsInVzZXJJZCI6IjY2NiJ9.fiQKWuMTWbkfQ3dOozoJr13pJSmKnc5El4EBnKyU42o</code></pre>
<p>用户每次请求时候带上这个，这个放在请求头里面，后端根据Token就能解析出来用户信息<br>当然生成这样的Token肯定得有时效性，一段时间自动过期保证安全</p>
<p>应用场景：<br>1.在分布式系统中，每个服务部署在的服务器都不一样，所以这个时候的服务器端Session就无效了，这个时候带着Token无论去哪个服务器去请求资源都能够解析用户信息<br>2.对于单点登录，就像京东一样，一次登录每个服务都相当于登录了</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>前后端分离</tag>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的Duration的时间格式解析，ISO-8601持续时间格式</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/java%E7%9A%84Duration%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90%EF%BC%8CISO-8601%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>  在配置springboot的配置的时候突然看到时间是Duration来配置的，上源码看到这样一个方法</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">    * Obtains a &#123;<span class="hljs-doctag">@code</span> Duration&#125; from a text string such as &#123;<span class="hljs-doctag">@code</span> PnDTnHnMn.nS&#125;.</span>
<span class="hljs-comment">    * &lt;p&gt;</span>
<span class="hljs-comment">    * This will parse a textual representation of a duration, including the</span>
<span class="hljs-comment">    * string produced by &#123;<span class="hljs-doctag">@code</span> toString()&#125;. The formats accepted are based</span>
<span class="hljs-comment">    * on the ISO-8601 duration format &#123;<span class="hljs-doctag">@code</span> PnDTnHnMn.nS&#125; with days</span>
<span class="hljs-comment">    * considered to be exactly 24 hours.</span>
<span class="hljs-comment">    * &lt;p&gt;</span>
<span class="hljs-comment">    * The string starts with an optional sign, denoted by the ASCII negative</span>
<span class="hljs-comment">    * or positive symbol. If negative, the whole period is negated.</span>
<span class="hljs-comment">    * The ASCII letter &quot;P&quot; is next in upper or lower case.</span>
<span class="hljs-comment">    * There are then four sections, each consisting of a number and a suffix.</span>
<span class="hljs-comment">    * The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for</span>
<span class="hljs-comment">    * days, hours, minutes and seconds, accepted in upper or lower case.</span>
<span class="hljs-comment">    * The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before</span>
<span class="hljs-comment">    * the first occurrence, if any, of an hour, minute or second section.</span>
<span class="hljs-comment">    * At least one of the four sections must be present, and if &quot;T&quot; is present</span>
<span class="hljs-comment">    * there must be at least one section after the &quot;T&quot;.</span>
<span class="hljs-comment">    * The number part of each section must consist of one or more ASCII digits.</span>
<span class="hljs-comment">    * The number may be prefixed by the ASCII negative or positive symbol.</span>
<span class="hljs-comment">    * The number of days, hours and minutes must parse to an &#123;<span class="hljs-doctag">@code</span> long&#125;.</span>
<span class="hljs-comment">    * The number of seconds must parse to an &#123;<span class="hljs-doctag">@code</span> long&#125; with optional fraction.</span>
<span class="hljs-comment">    * The decimal point may be either a dot or a comma.</span>
<span class="hljs-comment">    * The fractional part may have from zero to 9 digits.</span>
<span class="hljs-comment">    * &lt;p&gt;</span>
<span class="hljs-comment">    * The leading plus/minus sign, and negative values for other units are</span>
<span class="hljs-comment">    * not part of the ISO-8601 standard.</span>
<span class="hljs-comment">    * &lt;p&gt;</span>
<span class="hljs-comment">    * Examples:</span>
<span class="hljs-comment">    * &lt;pre&gt;</span>
<span class="hljs-comment">    *    &quot;PT20.345S&quot; -- parses as &quot;20.345 seconds&quot;</span>
<span class="hljs-comment">    *    &quot;PT15M&quot;     -- parses as &quot;15 minutes&quot; (where a minute is 60 seconds)</span>
<span class="hljs-comment">    *    &quot;PT10H&quot;     -- parses as &quot;10 hours&quot; (where an hour is 3600 seconds)</span>
<span class="hljs-comment">    *    &quot;P2D&quot;       -- parses as &quot;2 days&quot; (where a day is 24 hours or 86400 seconds)</span>
<span class="hljs-comment">    *    &quot;P2DT3H4M&quot;  -- parses as &quot;2 days, 3 hours and 4 minutes&quot;</span>
<span class="hljs-comment">    *    &quot;P-6H3M&quot;    -- parses as &quot;-6 hours and +3 minutes&quot;</span>
<span class="hljs-comment">    *    &quot;-P6H3M&quot;    -- parses as &quot;-6 hours and -3 minutes&quot;</span>
<span class="hljs-comment">    *    &quot;-P-6H+3M&quot;  -- parses as &quot;+6 hours and -3 minutes&quot;</span>
<span class="hljs-comment">    * &lt;/pre&gt;</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> text  the text to parse, not null</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the parsed duration, not null</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> DateTimeParseException if the text cannot be parsed to a duration</span>
<span class="hljs-comment">    */</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Duration <span class="hljs-title">parse</span><span class="hljs-params">(CharSequence text)</span> </span>&#123;
	...
   &#125;</code></pre>

<p>大致意思就是按照ISO-8601持续时间格式格式都能进行解析；那就说说这个格式怎么写</p>
<h1 id="二、ISO-8601持续时间格式"><a href="#二、ISO-8601持续时间格式" class="headerlink" title="二、ISO-8601持续时间格式"></a>二、ISO-8601持续时间格式</h1><p>运行间隔以”P”开始，和上面一样也是用”T”分割日期和时间，如P1Y2M10DT2H30M15S</p>
<p>P 开始标记<br>1Y - 一年<br>2M - 两个月<br>10D - 十天<br>T - 时间和日期分的割标记<br>2H - 两个小时<br>30M - 三十分钟<br>15S 十五秒钟</p>
<p>例子，注意如果没有年月日，”T”也不能省略</p>
<p>P1DT1M - 一天一分钟执行一次<br>P1W - 一周执行一次<br>PT1H - 一小时执行一次<br>PT10S - 十秒执行一次</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码解析</tag>
        <tag>Duration</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-admin-template改造实现后台传入路由表动态生成权限菜单</title>
    <url>/Web%E5%89%8D%E7%AB%AF/vue-admin-template%E6%94%B9%E9%80%A0%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E4%BC%A0%E5%85%A5%E8%B7%AF%E7%94%B1%E8%A1%A8%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%9D%83%E9%99%90%E8%8F%9C%E5%8D%95.html</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>因为打算做前后端分离的权限控制，并且生成动态的权限菜单，但是发现vue-admin-template是前端根据角色控制页面，并且代码写死在前端，我觉得这样不好，后面用户管理的时候添加了个角色前端就得改代码，就查阅了下资料，根据后台来传入路由表，然后再通过router.addRouters()；方法将路由表添加进去；</p>
<h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><h6 id="1-后台传入路由表数据数据格式"><a href="#1-后台传入路由表数据数据格式" class="headerlink" title="1.后台传入路由表数据数据格式"></a>1.后台传入路由表数据数据格式</h6><pre><code class="hljs json">&#123;
	<span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,
	<span class="hljs-attr">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,
	<span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">20000</span>,
	<span class="hljs-attr">&quot;data&quot;</span>: &#123;
		<span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Uncle&quot;</span>,
		<span class="hljs-attr">&quot;avatar&quot;</span>: <span class="hljs-string">&quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;</span>,
		<span class="hljs-attr">&quot;roles&quot;</span>: [<span class="hljs-string">&quot;admin&quot;</span>],
		<span class="hljs-attr">&quot;routers&quot;</span>: [&#123;
			<span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Test_It&quot;</span>,
			<span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;/test&quot;</span>,
			<span class="hljs-attr">&quot;component&quot;</span>: <span class="hljs-string">&quot;Layout&quot;</span>,
			<span class="hljs-attr">&quot;children&quot;</span>: [&#123;
				<span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Test_It_c&quot;</span>,
				<span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;index&quot;</span>,
				<span class="hljs-attr">&quot;component&quot;</span>: <span class="hljs-string">&quot;Test&quot;</span>,
				<span class="hljs-attr">&quot;meta&quot;</span>: &#123;
					<span class="hljs-attr">&quot;icon&quot;</span>: <span class="hljs-string">&quot;example&quot;</span>,
					<span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;后台&quot;</span>
				&#125;,
			&#125;]
		&#125;]
	&#125;
&#125;</code></pre>
<h6 id="2-前端页面将json格式化成js对象，重点是将compoent转化真实的组件对象"><a href="#2-前端页面将json格式化成js对象，重点是将compoent转化真实的组件对象" class="headerlink" title="2.前端页面将json格式化成js对象，重点是将compoent转化真实的组件对象"></a>2.前端页面将json格式化成js对象，重点是将compoent转化真实的组件对象</h6><p>2.1 格式化工具</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/form/index&#x27;</span>
<span class="hljs-keyword">import</span> Layout <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/layout&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">routers</span>) </span>&#123;
  <span class="hljs-keyword">return</span> filterAsyncRouter(routers)
&#125;
<span class="hljs-comment">//将后台返回的json权限数据格式化（递归遍历子节点）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span>  filterAsyncRouter=<span class="hljs-function">(<span class="hljs-params">asyncRouterMap</span>) =&gt;</span>&#123; <span class="hljs-comment">//遍历后台传来的路由字符串，转换为组件对象</span>
  <span class="hljs-keyword">const</span> accessedRouters = asyncRouterMap.filter(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (route.component) &#123;
        <span class="hljs-keyword">if</span> (route.component === <span class="hljs-string">&#x27;Layout&#x27;</span>) &#123; <span class="hljs-comment">//Layout组件特殊处理</span>
          route.component = Layout
        &#125; <span class="hljs-keyword">else</span> &#123;
          route.component = Test
        &#125;
    &#125;
    <span class="hljs-keyword">if</span> (route.children &amp;&amp; route.children.length) &#123;

      route.children = filterAsyncRouter(route.children)
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  &#125;)
  <span class="hljs-keyword">return</span> accessedRouters
&#125;</code></pre>
<p>2.2 获取路由表并且格式化</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;constantRouterMap&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span>;
<span class="hljs-keyword">const</span> user = &#123;
  state: &#123;
    routers: constantRouterMap,
    addRouters: []
  &#125;,
  mutations: &#123;
    SET_ROUTERS: <span class="hljs-function">(<span class="hljs-params">state, routers</span>) =&gt;</span> &#123;
      state.addRouters = routers; <span class="hljs-comment">//路由访问</span>
      state.routers = constantRouterMap.concat(routers); <span class="hljs-comment">//菜单显示</span>
    &#125;
  &#125;,

  actions: &#123;
    <span class="hljs-comment">// 获取用户信息</span>
    GetInfo(&#123;commit,state &#125;) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
        getInfo(state.token).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;
          <span class="hljs-keyword">const</span> data = response.data
          commit(<span class="hljs-string">&#x27;SET_NAME&#x27;</span>, data.name)
          commit(<span class="hljs-string">&#x27;SET_ROLES&#x27;</span>, data.roles)
          commit(<span class="hljs-string">&#x27;SET_AVATAR&#x27;</span>, data.avatar)
          commit(<span class="hljs-string">&#x27;SET_ROUTERS&#x27;</span>, routerFormat(data.routers))
          resolve(response)
        &#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;
          reject(error)
        &#125;)
      &#125;)
    &#125;,
    &#125;</code></pre>
<h6 id="3-添加路由表"><a href="#3-添加路由表" class="headerlink" title="3.添加路由表"></a>3.添加路由表</h6><p>全局路由拦截器</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>
<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>
<span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nprogress&#x27;</span> <span class="hljs-comment">// Progress 进度条</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;nprogress/nprogress.css&#x27;</span><span class="hljs-comment">// Progress 进度条样式</span>
<span class="hljs-keyword">import</span> &#123; Message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>
<span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/auth&#x27;</span> <span class="hljs-comment">// 验权</span>

<span class="hljs-keyword">const</span> whiteList = [<span class="hljs-string">&#x27;/login&#x27;</span>] <span class="hljs-comment">// 不重定向白名单</span>
router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;
  NProgress.start()
  <span class="hljs-keyword">if</span> (getToken()) &#123;
    <span class="hljs-keyword">if</span> (to.path === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;
      next(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span> &#125;)
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">if</span> (store.getters.name.length === <span class="hljs-number">0</span>) &#123;
        store.dispatch(<span class="hljs-string">&#x27;GetInfo&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-comment">// 拉取用户信息</span>
          router.addRoutes(store.getters.routers)<span class="hljs-comment">//添加后台路由表</span>
          next(&#123; ...to, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;)
        &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;
          store.dispatch(<span class="hljs-string">&#x27;FedLogOut&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;
            Message.error(<span class="hljs-string">&#x27;验证失败,请重新登录&#x27;</span>+e.message)
            next(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span> &#125;)
          &#125;)
        &#125;)
      &#125; <span class="hljs-keyword">else</span> &#123;
        next()
      &#125;
    &#125;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">if</span> (whiteList.indexOf(to.path) !== <span class="hljs-number">-1</span>) &#123;
      next()
    &#125; <span class="hljs-keyword">else</span> &#123;
      next(<span class="hljs-string">&#x27;/login&#x27;</span>)
      NProgress.done()
    &#125;
  &#125;
&#125;)

router.afterEach(<span class="hljs-function">() =&gt;</span> &#123;
  NProgress.done() <span class="hljs-comment">// 结束Progress</span>
&#125;)
</code></pre>

<h6 id="4-绑定路由表"><a href="#4-绑定路由表" class="headerlink" title="4.绑定路由表"></a>4.绑定路由表</h6><p>路径 @/layout/componets/SideBar/index.vue<br>刚开始发现addRouters()之后能访问但是并没有在菜单中显示，打印出来看了下router.option.router没有添加的路由，但是自己在store里面的却有，所以这里路由绑定我就换成了store里的routers，成功显示。</p>
<pre><code class="hljs js">routes() &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.routers<span class="hljs-comment">//大坑。。</span>
&#125;,</code></pre>

<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/unclezs/vue-admin-template-custom">GitHub源码地址</a></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>后台管理</tag>
        <tag>前后端分离</tag>
        <tag>动态路由</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ之工作模式</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E4%B9%8B%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="六大工作模式"><a href="#六大工作模式" class="headerlink" title="六大工作模式"></a>六大工作模式</h1><p>RabbitMQ有以下几种工作模式 ：<br>1、Work queues<br>2、Publish/Subscribe<br>3、Routing<br>4、Topics<br>5、Header<br>6、RPC</p>
<h2 id="一、-Work-queues"><a href="#一、-Work-queues" class="headerlink" title="一、 Work queues"></a>一、 Work queues</h2><p><img src="https://img-blog.csdnimg.cn/20190912151107801.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190912151107801.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>工作队列模式，采用默认的交换机，路由名称为队列名称，有多个终端消费同一个队列的时候，交换机采用轮询发送消息，通俗点说就是给第一个发一条，另外一个发下一条</p>
<p><strong>应用场景：</strong><br>对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。</p>
<p><strong>测试：</strong><br>1、多个消费者。<br>2、生产者发送多个消息。<br><strong>结果：</strong><br>1、一条消息只会被一个消费者接收；<br>2、rabbit采用轮询的方式将消息是平均发送给消费者的；<br>3、消费者在处理完某条消息后，才会收到下一条消息。</p>
<h2 id="二、-Publish-subscribe"><a href="#二、-Publish-subscribe" class="headerlink" title="二、 Publish/subscribe"></a>二、 Publish/subscribe</h2><p><img src="https://img-blog.csdnimg.cn/20190912151058185.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190912151058185.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br><strong>发布订阅模式：</strong><br>1、每个消费者监听自己的队列。<br>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</p>
<p><strong>应用场景：</strong><br>用户通知，当用户充值成功或转账完成系统通知用户，通知方式有短信、邮件多种方法 。</p>
<p><strong>流程：</strong><br>1.生产者<br>声明fanout类型交换机。<br>声明两个队列并且绑定到此交换机，绑定时不需要指定routingkey<br>发送消息时不需要指定routingkey</p>
<p>2.消费者<br>交换机会将信息发布给每个监听本交换机的队列，但是如果多个消费者监听了同一个队列，这个队列还是会按照轮询方式把信息发给每个消费者，一人一条（非同一个信息）</p>
<h2 id="三、Routing"><a href="#三、Routing" class="headerlink" title="三、Routing"></a>三、Routing</h2><p><img src="https://img-blog.csdnimg.cn/20190912151038875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190912151038875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br><strong>路由模式：</strong><br>1、每个消费者监听自己的队列，并且设置routingkey。<br>2、生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列。</p>
<p><strong>流程：</strong><br>1.生产者<br>声明DIRECT类型交换机。<br>声明两个队列并且绑定到此交换机，绑定时需要指定routingkey<br>发送消息时需要指定routingkey<br>2.消费者<br>消费者绑定队列的时候可以指定routingkey来只获取指定routingkey的消息<br><strong>说明：</strong><br>Routing模式要求队列在绑定交换机时要指定routingkey，消息会转发到符合routingkey的队列。</p>
<h2 id="四、Topics"><a href="#四、Topics" class="headerlink" title="四、Topics"></a>四、Topics</h2><p><img src="https://img-blog.csdnimg.cn/20190912154304754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190912154304754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br><strong>通配符模式：</strong><br>同路由模式相似，但是routingkey的匹配是通过通配符决定的，路由模式是相等才匹配<br>设置交换机类型为Topics即可</p>
<p><strong>应用场景：</strong><br>根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种<br>通知类型都接收的则两种通知都有效。</p>
<p><strong>通配符使用：</strong></p>
<ol>
<li>[#],匹配一个或者多个词，比如 uncle.# ,可以匹配uncle.sms、uncle.email、uncle.sms.email</li>
<li>[* ],匹配一个词，比如 uncle.*,可以匹配uncle.sms、uncle.email</li>
</ol>
<p>例子：<br> uncle.#.sms.# 能匹配 uncle.sms、uncle.email.sms,不能匹配 uncle.email</p>
<h2 id="五、Header"><a href="#五、Header" class="headerlink" title="五、Header"></a>五、Header</h2><p>header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。</p>
<h2 id="六、RPC"><a href="#六、RPC" class="headerlink" title="六、RPC"></a>六、RPC</h2><p><img src="https://img-blog.csdnimg.cn/20190912163612701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190912163612701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下：<br>1、客户端即是生产者就是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。<br>2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果<br>3、服务端将RPC方法 的结果发送到RPC响应队列<br>4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>RabitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ入门程序之HelloWorld</title>
    <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E4%B9%8BHelloWorld.html</url>
    <content><![CDATA[<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><h4 id="1-下载RabbitMQ"><a href="#1-下载RabbitMQ" class="headerlink" title="1.下载RabbitMQ"></a>1.下载RabbitMQ</h4><p>RabbitMQ由Erlang语言开发，Erlang语言用于并发及分布式系统的开发，在电信领域应用广泛，OTP（Open<br>Telecom Platform）作为Erlang语言的一部分，包含了很多基于Erlang开发的中间件及工具库，安装RabbitMQ需<br>要安装Erlang/OTP，并保持版本匹配，如下图：<br>RabbitMQ的下载地址：<a href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a></p>
<h4 id="2-下载erlang"><a href="#2-下载erlang" class="headerlink" title="2.下载erlang"></a>2.下载erlang</h4><p>地址如下：<br><a href="http://erlang.org/download/otp_win64_20.3.exe">http://erlang.org/download/otp_win64_20.3.exe</a></p>
<h4 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h4><p>先安装erlang再安装RabbitMQ</p>
<h4 id="4-启动管理插件"><a href="#4-启动管理插件" class="headerlink" title="4.启动管理插件"></a>4.启动管理插件</h4><p><code>rabbitmq-plugins.bat enable rabbitmq_management</code><br>访问 <a href="http://localhost:15672/#/">http://localhost:15672/#/</a><br>登录用户名密码都是guest</p>
<h1 id="二、创建工程"><a href="#二、创建工程" class="headerlink" title="二、创建工程"></a>二、创建工程</h1><p>两个工程一个Consumer一个Producer，生产者负责发送消息，消费者负责监听队列取消息</p>
<h6 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h6><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre>

<h6 id="2-Producer"><a href="#2-Producer" class="headerlink" title="2.Producer"></a>2.Producer</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer01</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE = <span class="hljs-string">&quot;HelloWorld&quot;</span>;<span class="hljs-comment">//队列名称</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        <span class="hljs-comment">//创建连接工厂</span>
        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();
        <span class="hljs-comment">//设置工厂</span>
        connectionFactory.setHost(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);
        connectionFactory.setPort(<span class="hljs-number">5672</span>);
        connectionFactory.setUsername(<span class="hljs-string">&quot;root&quot;</span>);
        connectionFactory.setPassword(<span class="hljs-string">&quot;root&quot;</span>);
        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);
        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//创建连接</span>
            connection = connectionFactory.newConnection();
            <span class="hljs-comment">//建立管道</span>
            channel = connection.createChannel();
            <span class="hljs-comment">//声明队列</span>
            <span class="hljs-comment">//1.队列名称</span>
            <span class="hljs-comment">//2.是否持久化</span>
            <span class="hljs-comment">//3.是否独占队列</span>
            <span class="hljs-comment">//4.是否自动删除</span>
            <span class="hljs-comment">//5.参数</span>
            channel.queueDeclare(QUEUE, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            <span class="hljs-comment">//发送消息</span>
            String message = <span class="hljs-string">&quot;我是Uncle哎哎，你好RabbitMQ   &quot;</span> + System.currentTimeMillis();
            <span class="hljs-comment">//1.交换机名称</span>
            <span class="hljs-comment">//2.队列名称</span>
            <span class="hljs-comment">//3.参数</span>
            <span class="hljs-comment">//4.消息</span>
            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE, <span class="hljs-keyword">null</span>, message.getBytes());
            System.out.println(<span class="hljs-string">&quot;发送信息：&quot;</span> + message);
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">//释放连接</span>
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;
                channel.close();
            &#125;
            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
                connection.close();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h6 id="3-Consumer"><a href="#3-Consumer" class="headerlink" title="3.Consumer"></a>3.Consumer</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer01</span></span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE = <span class="hljs-string">&quot;HelloWorld&quot;</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        <span class="hljs-comment">//连接工厂</span>
        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();
        connectionFactory.setHost(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);
        connectionFactory.setPort(<span class="hljs-number">5672</span>);
        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();
        <span class="hljs-comment">//声明队列</span>
        channel.queueDeclare(QUEUE, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        <span class="hljs-comment">//创建消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span></span>
<span class="hljs-function"><span class="hljs-params">             AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);
                System.out.println(<span class="hljs-string">&quot;收到消息：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;UTF-8&quot;</span>));
            &#125;
        &#125;;
        <span class="hljs-comment">//绑定队列，消费者</span>
        channel.basicConsume(QUEUE, <span class="hljs-keyword">true</span>, consumer);
    &#125;
&#125;</code></pre>

<h6 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h6><p><img src="https://img-blog.csdnimg.cn/20190912121812821.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190912121812821.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190912121819729.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190912121819729.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h4 id="1、发送端操作流程"><a href="#1、发送端操作流程" class="headerlink" title="1、发送端操作流程"></a>1、发送端操作流程</h4><p>1）创建连接<br>2）创建通道<br>3）声明队列<br>4）发送消息</p>
<h4 id="2、接收端"><a href="#2、接收端" class="headerlink" title="2、接收端"></a>2、接收端</h4><p>1）创建连接<br>2）创建通道<br>3）声明队列<br>4）监听队列<br>5）接收消息<br>6）ack回复</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>RabitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaFX程序通过exe4j和FXLauncher实现打包exe加自动更新</title>
    <url>/Java/javaFX/JavaFX%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87exe4j%E5%92%8CFXLauncher%E5%AE%9E%E7%8E%B0%E6%89%93%E5%8C%85exe%E5%8A%A0%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0.html</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>因为用JavaFX做了个PC的小说下载阅读软件，所以想实现下自动更新,每次手动下载更新实在太麻烦了，后来就百度了一下看看有没有现成的结果找到的<a href="https://github.com/edvin/fxlauncher">FXLauncher</a>，这个东西的官方文档实在是太过简洁了。不过好在弄出来了</p>
<h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><h3 id="1-首先下载官方的domo，然后分析他的配置"><a href="#1-首先下载官方的domo，然后分析他的配置" class="headerlink" title="1.首先下载官方的domo，然后分析他的配置"></a>1.首先下载官方的domo，然后分析他的配置</h3><p><strong>引入依赖</strong></p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>no.tornado<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fxlauncher<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<p><strong>首先是properties</strong></p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.filename</span>&gt;</span>Uncle小说<span class="hljs-tag">&lt;/<span class="hljs-name">app.filename</span>&gt;</span>
    <span class="hljs-comment">&lt;!--运行的主类--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.mainClass</span>&gt;</span>com.unclezs.UI.App.Main<span class="hljs-tag">&lt;/<span class="hljs-name">app.mainClass</span>&gt;</span>
    <span class="hljs-comment">&lt;!--FXLauncher运行后文件下载的位置--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.cacheDir</span>&gt;</span>./lib<span class="hljs-tag">&lt;/<span class="hljs-name">app.cacheDir</span>&gt;</span>
    <span class="hljs-comment">&lt;!--FXLauncher运行时候的参数，比如什么更新失败后继续打开程序之类的，有哪些看官方的Readme里面--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.parameters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app.parameters</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.vendor</span>&gt;</span>Acme Inc<span class="hljs-tag">&lt;/<span class="hljs-name">app.vendor</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.version</span>&gt;</span>3.3<span class="hljs-tag">&lt;/<span class="hljs-name">app.version</span>&gt;</span>
    <span class="hljs-comment">&lt;!--更新文件的服务器地址，在这里可以打开下载你的更新jar包就行，tomcat和apache都行--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.url</span>&gt;</span>http://114.115.208.62/<span class="hljs-tag">&lt;/<span class="hljs-name">app.url</span>&gt;</span>
    <span class="hljs-comment">&lt;!--编译后的位置，这个位置在Idea里面是target下面的app目录--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.dir</span>&gt;</span>$&#123;project.build.directory&#125;/app<span class="hljs-tag">&lt;/<span class="hljs-name">app.dir</span>&gt;</span>
    <span class="hljs-comment">&lt;!--打包exe程序后的目录位置target/install--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.installerdir</span>&gt;</span>$&#123;project.build.directory&#125;/installer<span class="hljs-tag">&lt;/<span class="hljs-name">app.installerdir</span>&gt;</span>
    <span class="hljs-comment">&lt;!--是否接受版本降级--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app.acceptDowngrade</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">app.acceptDowngrade</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre>

<p><strong>然后是build</strong></p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
           <span class="hljs-comment">&lt;!-- 编译执行文件 --&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;app.dir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
           <span class="hljs-comment">&lt;!-- 拷贝依赖jar包到编译目录 --&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">excludeScope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">excludeScope</span>&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;app.dir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">stripVersion</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">stripVersion</span>&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                           <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                       <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
                   <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
               <span class="hljs-comment">&lt;!-- 生成 app.xml manifest --&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>create-manifest<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                           <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                       <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                           <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>fxlauncher.CreateManifest<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>
                           <span class="hljs-tag">&lt;<span class="hljs-name">arguments</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>$&#123;app.url&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>$&#123;app.mainClass&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>$&#123;app.dir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>--cache-dir=$&#123;app.cacheDir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>--accept-downgrade=$&#123;app.acceptDowngrade&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                               <span class="hljs-comment">&lt;!--这里可以放你想要更新文件打包进去的文件 比如dll，db之类的，可以事先放在app目录下--&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>--include-extensions=jpg<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>$&#123;app.parameters&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                           <span class="hljs-tag">&lt;/<span class="hljs-name">arguments</span>&gt;</span>
                       <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
                   <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
                   <span class="hljs-comment">&lt;!-- 把app.xml打包进fxlauncher.xml,这样就启动器就不需要依赖app.xml来启动了 --&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>embed-manifest-in-launcher<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                           <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                       <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
                       <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                           <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span>
                           <span class="hljs-tag">&lt;<span class="hljs-name">workingDirectory</span>&gt;</span>$&#123;app.dir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">workingDirectory</span>&gt;</span>
                           <span class="hljs-tag">&lt;<span class="hljs-name">arguments</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>uf<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>fxlauncher.jar<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                               <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>app.xml<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span>
                           <span class="hljs-tag">&lt;/<span class="hljs-name">arguments</span>&gt;</span>
                       <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
                   <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>
                   <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>


<h3 id="2-配置分析完了可以看看怎么用了"><a href="#2-配置分析完了可以看看怎么用了" class="headerlink" title="2.配置分析完了可以看看怎么用了"></a>2.配置分析完了可以看看怎么用了</h3><pre><code>打开控制台输入：mvn package</code></pre><p><img src="https://img-blog.csdnimg.cn/20190718213802330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190718213802330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>编译完成后会在target/app下面出现我们的jar包和依赖文件<br>全部复制到tomcat的root目录下，这个时候要能通过tomcat下载你的jar文件</p>
<pre><code class="hljs plain">&lt;app.url&gt;http:&#x2F;&#x2F; 202.202.144.134:8080&#x2F;&lt;&#x2F;app.url&gt;</code></pre>
<p>如果这个url+你的jar包名字拼接出来的URL，能够在浏览器下载这个jar包，那这个时候就可以了<br>这个时候复制出fxlauncher.jar，随便到一个文件夹，这个时候就能够自动下载依赖并且自动更新了<br>更新的时候你只需要把新的依赖在服务器更新就行了，app启动的时候会自动更新</p>
<h1 id="exe4j打包exe"><a href="#exe4j打包exe" class="headerlink" title="exe4j打包exe"></a>exe4j打包exe</h1><h5 id="1-打开exe4j，选择打包方式"><a href="#1-打开exe4j，选择打包方式" class="headerlink" title="1.打开exe4j，选择打包方式"></a>1.打开exe4j，选择打包方式</h5><p><img src="https://img-blog.csdnimg.cn/20190718214830628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190718214830628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h5 id="2-输入软件名字和打包后的exe文件放在哪里"><a href="#2-输入软件名字和打包后的exe文件放在哪里" class="headerlink" title="2.输入软件名字和打包后的exe文件放在哪里"></a>2.输入软件名字和打包后的exe文件放在哪里</h5><p><img src="https://img-blog.csdnimg.cn/20190718214930245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190718214930245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h5 id="3-选择图标，选择打包程序类型，应用名字"><a href="#3-选择图标，选择打包程序类型，应用名字" class="headerlink" title="3.选择图标，选择打包程序类型，应用名字"></a>3.选择图标，选择打包程序类型，应用名字</h5><p><img src="https://img-blog.csdnimg.cn/20190718215025948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190718215025948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h5 id="4-选择哪种运行方式，勾了就是64，不勾就是32"><a href="#4-选择哪种运行方式，勾了就是64，不勾就是32" class="headerlink" title="4.选择哪种运行方式，勾了就是64，不勾就是32"></a>4.选择哪种运行方式，勾了就是64，不勾就是32</h5><p><img src="https://img-blog.csdnimg.cn/20190718215148187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190718215148187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h5 id="5-选择fxlauncher-jar和运行主类，fxlauncher-Laucnher"><a href="#5-选择fxlauncher-jar和运行主类，fxlauncher-Laucnher" class="headerlink" title="5.选择fxlauncher.jar和运行主类，fxlauncher.Laucnher"></a>5.选择fxlauncher.jar和运行主类，fxlauncher.Laucnher</h5><p><img src="https://img-blog.csdnimg.cn/201907182154598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/201907182154598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h5 id="6-这里配置jre，是搜索自带的环境变量或者添加本地的jre都可以"><a href="#6-这里配置jre，是搜索自带的环境变量或者添加本地的jre都可以" class="headerlink" title="6.这里配置jre，是搜索自带的环境变量或者添加本地的jre都可以"></a>6.这里配置jre，是搜索自带的环境变量或者添加本地的jre都可以</h5><p><img src="https://img-blog.csdnimg.cn/20190718215550528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190718215550528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h5 id="7-然后点完成就可以了"><a href="#7-然后点完成就可以了" class="headerlink" title="7.然后点完成就可以了"></a>7.然后点完成就可以了</h5><p>双击exe可以自动更新的exe程序出炉，上张图<br><img src="https://img-blog.csdnimg.cn/20190718215832234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190718215832234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>此软件源码地址：<br><a href="https://github.com/unclezs/NovelHarvester">https://github.com/unclezs/NovelHarvester</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaFX</category>
      </categories>
      <tags>
        <tag>JavaFX</tag>
        <tag>exe4j</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaFX实现像安卓一样的Toast</title>
    <url>/Java/javaFX/JavaFX%E5%AE%9E%E7%8E%B0%E5%83%8F%E5%AE%89%E5%8D%93%E4%B8%80%E6%A0%B7%E7%9A%84Toast.html</url>
    <content><![CDATA[<h2 id="JAVAFX消息弹窗"><a href="#JAVAFX消息弹窗" class="headerlink" title="JAVAFX消息弹窗"></a>JAVAFX消息弹窗</h2><p>一个像安卓的Toast弹窗小说，定时消失</p>
<pre><code class="hljs java">
<span class="hljs-keyword">import</span> javafx.application.Application;
<span class="hljs-keyword">import</span> javafx.application.Platform;
<span class="hljs-keyword">import</span> javafx.geometry.Pos;
<span class="hljs-keyword">import</span> javafx.scene.Scene;
<span class="hljs-keyword">import</span> javafx.scene.control.Label;
<span class="hljs-keyword">import</span> javafx.scene.paint.Color;
<span class="hljs-keyword">import</span> javafx.scene.text.Font;
<span class="hljs-keyword">import</span> javafx.stage.Stage;
<span class="hljs-keyword">import</span> javafx.stage.StageStyle;

<span class="hljs-keyword">import</span> java.util.Timer;
<span class="hljs-keyword">import</span> java.util.TimerTask;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> *@author unclezs.com</span>
<span class="hljs-comment"> *@date 2019.07.06 12:46</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToastUtil</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Stage stage=<span class="hljs-keyword">new</span> Stage();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Label label=<span class="hljs-keyword">new</span> Label();
    <span class="hljs-keyword">static</span> &#123;
        stage.initStyle(StageStyle.TRANSPARENT);<span class="hljs-comment">//舞台透明</span>
    &#125;
    <span class="hljs-comment">//默认3秒</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toast</span><span class="hljs-params">(String msg)</span> </span>&#123;
        toast(msg,<span class="hljs-number">3000</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 指定时间消失</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toast</span><span class="hljs-params">(String msg, <span class="hljs-keyword">int</span> time)</span> </span>&#123;
        label.setText(msg);
        TimerTask task= <span class="hljs-keyword">new</span> TimerTask() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                Platform.runLater(()-&gt;stage.close());
            &#125;
        &#125;;
        init(msg);
        Timer timer=<span class="hljs-keyword">new</span> Timer();
        timer.schedule(task,time);
        stage.show();
    &#125;

    <span class="hljs-comment">//设置消息</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(String msg)</span> </span>&#123;
  	    Label label=<span class="hljs-keyword">new</span> Label(msg);<span class="hljs-comment">//默认信息</span>
        label.setStyle(<span class="hljs-string">&quot;-fx-background: rgba(56,56,56,0.7);-fx-border-radius: 25;-fx-background-radius: 25&quot;</span>);<span class="hljs-comment">//label透明,圆角</span>
        label.setTextFill(Color.rgb(<span class="hljs-number">225</span>,<span class="hljs-number">255</span>,<span class="hljs-number">226</span>));<span class="hljs-comment">//消息字体颜色</span>
        label.setPrefHeight(<span class="hljs-number">50</span>);
        label.setPadding(<span class="hljs-keyword">new</span> Insets(<span class="hljs-number">15</span>));
        label.setAlignment(Pos.CENTER);<span class="hljs-comment">//居中</span>
        label.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-number">20</span>));<span class="hljs-comment">//字体大小</span>
        Scene scene=<span class="hljs-keyword">new</span> Scene(label);
        scene.setFill(<span class="hljs-keyword">null</span>);<span class="hljs-comment">//场景透明</span>
        stage.setScene(scene);
    &#125;
&#125;

</code></pre>

<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://img-blog.csdnimg.cn/20190706133710865.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190706133710865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaFX</category>
      </categories>
      <tags>
        <tag>JavaFX</tag>
        <tag>弹窗</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk源码分析-TreeMap红黑树插入删除过程</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/jdk%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-TreeMap%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<h2 id="一、红-黑树的性质"><a href="#一、红-黑树的性质" class="headerlink" title="一、红-黑树的性质"></a>一、红-黑树的性质</h2><h6 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h6><p>jdk中的TreeMap是由红黑树实现的，所以本文记录下我分析的红黑树<br>红黑树实际是实现二叉排序树的实现自平衡的算法之一，所以可以叫红黑树为高级二叉查找树。<br>如果不了解排序树请先学习排序树</p>
<h6 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h6><p>1.每个节点不是红色就是黑色的；<br>2.根节点总是黑色的；<br>3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；<br>4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</p>
<h2 id="二、平衡化的旋转"><a href="#二、平衡化的旋转" class="headerlink" title="二、平衡化的旋转"></a>二、平衡化的旋转</h2><p>为了达到树的平衡我们需要对其进行旋转，下面说的是左右旋的基本概念</p>
<h6 id="1-左旋"><a href="#1-左旋" class="headerlink" title="1.左旋"></a>1.左旋</h6><p>以5为节点进行左旋转<br><img src="https://img-blog.csdnimg.cn/20190617091938685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190617091938685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>以E为节点进行左旋转示意图<br><img src="https://img-blog.csdnimg.cn/20190617090248373.gif" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190617090248373.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h6 id="2-右旋"><a href="#2-右旋" class="headerlink" title="2.右旋"></a>2.右旋</h6><p>以20为节点进行右旋转</p>
<p><img src="https://img-blog.csdnimg.cn/20190617091647412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190617091647412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>以s为节点，右旋转示意图<br><img src="https://img-blog.csdnimg.cn/20190617092155466.gif" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190617092155466.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h2 id="三、插入过程"><a href="#三、插入过程" class="headerlink" title="三、插入过程"></a>三、插入过程</h2><p>插入的时候为保证红黑树性质不被改变，插入后应该对其旋转操作，需要修复红黑树结构的情况为父节点为红色的时候</p>
<h4 id="1-情况分析"><a href="#1-情况分析" class="headerlink" title="1.情况分析"></a>1.情况分析</h4><p>我按照两种情况来分析需要旋转的情况<br>新插入的节点默认都为红色</p>
<h6 id="1-1-父亲在左边"><a href="#1-1-父亲在左边" class="headerlink" title="1.1.父亲在左边"></a>1.1.父亲在左边</h6><p><strong>1.1.1 .叔叔为红色</strong><br><img src="https://img-blog.csdnimg.cn/20190617093838739.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190617093838739.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>这里不需要旋转，只需要换色即可，（父亲,叔叔）&lt;—&gt;（祖父），再将祖父当作根节点判断是否满足红黑树结构再进行操作</p>
<p><strong>1.1.2  叔叔为黑色、我在左</strong><br><img src="https://img-blog.csdnimg.cn/2019061709433826.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/2019061709433826.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>这里只需要进行以<strong>父</strong>为节点<strong>右</strong>旋转，然后父亲-&gt;黑色，祖父-&gt;红色</p>
<p><strong>1.1.3 叔叔为黑色、我在右边</strong><br><img src="https://img-blog.csdnimg.cn/20190617094831404.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190617094831404.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>这里要先对<strong>父</strong>节点做一次<strong>左</strong>旋，再以<strong>祖</strong>为节点<strong>右</strong>旋转</p>
<h6 id="1-2-父亲在右边"><a href="#1-2-父亲在右边" class="headerlink" title="1.2.父亲在右边"></a>1.2.父亲在右边</h6><p><strong>1.2.1 叔叔为红色</strong><br>和1.1.1一样<br><strong>1.2.2 叔叔为黑色，我在左</strong><br><img src="https://img-blog.csdnimg.cn/20190617095954714.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190617095954714.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>这里需要以<strong>父</strong>为节点进行一次<strong>左</strong>旋，再以<strong>祖父</strong>为节点进行<strong>左</strong>旋转即可<br><strong>1.2.1 叔叔为黑色，我在右</strong><br><img src="https://img-blog.csdnimg.cn/20190617100719981.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190617100719981.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>这里只需要以<strong>祖</strong>为节点左旋一次即可达到平衡</p>
<h4 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h4><p>回到java源码中对TreeMap中插入时修复红黑树的方法为<strong>fixAfterInsertion</strong><br>源码：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixAfterInsertion</span><span class="hljs-params">(Entry&lt;K,V&gt; x)</span> </span>&#123;
 	    me.color=RED;
        <span class="hljs-comment">//x为根节点时候不需要操作，x父亲为黑色时为正确红黑树，不需要修复</span>
        <span class="hljs-keyword">while</span> (me!=<span class="hljs-keyword">null</span>&amp;&amp;me!=root&amp;&amp;me.parent.color==RED)&#123;
            <span class="hljs-comment">//分两大种情况处理，父亲在左边或者右边时</span>
            <span class="hljs-keyword">if</span>(parentOf(me)==leftOf(parentOf(parentOf(me))))&#123;<span class="hljs-comment">//父亲在左边的时候</span>
                Node&lt;E&gt; uncle = rightOf(parentOf(parentOf(me)));<span class="hljs-comment">//获取叔叔(在右)</span>
                <span class="hljs-keyword">if</span>(colorOf(uncle)==BLACK)&#123;<span class="hljs-comment">//叔叔为黑色</span>
                    <span class="hljs-comment">//此时父左，叔右，若我为左则以祖父为根R旋转，若我在右边则以我为根进行LR转</span>
                    <span class="hljs-keyword">if</span>(rightOf(parentOf(me))==me)&#123;<span class="hljs-comment">//我在右边</span>
                        me=parentOf(me);
                        leftRotate(me);
                    &#125;
                    setColor(parentOf(me),BLACK);
                    setColor(parentOf(parentOf(me)),RED);
                    rightRotate(parentOf(parentOf(me)));
                &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//叔叔为红色,交换颜色（父亲,叔叔）&lt;-&gt;（祖父），再将祖父接着前操作</span>
                    setColor(parentOf(uncle),RED);<span class="hljs-comment">//祖父红色</span>
                    setColor(parentOf(me),BLACK);<span class="hljs-comment">//父亲黑色</span>
                    setColor(uncle,BLACK);<span class="hljs-comment">//叔叔黑色</span>
                    me=parentOf(uncle);<span class="hljs-comment">//祖父为节点接着修复</span>
                &#125;
            &#125;
            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//父亲在右边的时候</span>
                Node&lt;E&gt; uncle = leftOf(parentOf(parentOf(me)));<span class="hljs-comment">//获取叔叔(在左)</span>
                <span class="hljs-keyword">if</span>(colorOf(uncle)==BLACK)&#123;<span class="hljs-comment">//叔叔为黑色</span>
                    <span class="hljs-comment">//此时父右，叔左，若我为左则以我为根RL旋转，若我在右边则以祖父为根进行L转</span>
                    <span class="hljs-keyword">if</span>(leftOf(parentOf(me))==me)&#123;<span class="hljs-comment">//我在左边</span>
                        me=parentOf(me);
                        rightRotate(me);
                    &#125;
                    setColor(parentOf(me),BLACK);
                    setColor(parentOf(parentOf(me)),RED);
                    leftRotate(parentOf(parentOf(me)));
                &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//叔叔为红色,交换颜色（父亲,叔叔）&lt;-&gt;（祖父），再将祖父接着前操作</span>
                    setColor(parentOf(uncle),RED);<span class="hljs-comment">//祖父红色</span>
                    setColor(parentOf(me),BLACK);<span class="hljs-comment">//父亲黑色</span>
                    setColor(uncle,BLACK);<span class="hljs-comment">//叔叔黑色</span>
                    me=parentOf(uncle);<span class="hljs-comment">//祖父为节点接着修复</span>
                &#125;
            &#125;
        &#125;
        root.color=BLACK;
    &#125;</code></pre>

<h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><p>Todo</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>源码分析</tag>
        <tag>红黑树</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring给util类注入bean</title>
    <url>/Java/Spring/spring%E7%BB%99util%E7%B1%BB%E6%B3%A8%E5%85%A5bean.html</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在用SSM写东西的时候遇到的，spring因为不能够给静态对象自动注入，所以加上@Autowired注解也无用</p>
<pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtil</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool pool;</code></pre>
<p>这样是注入不进来pool的</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>1.先检查注解扫描是否正确spring-context.xml 和spring-mvc.xml</p>
<pre><code class="hljs java">&lt;context:component-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.unclezs&quot;</span>/&gt;</code></pre>
<p>2.检查web.xml加载顺序，先加载spring-context.xml才行<br>3.修改工具类</p>
<pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtil</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> JedisPool pool;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisUtil jedisUtil;
    <span class="hljs-meta">@PostConstruct</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;
        jedisUtil=<span class="hljs-keyword">this</span>;
        jedisUtil.pool= <span class="hljs-keyword">this</span>.pool;
    &#125;
&#125;</code></pre>

<p>问题这样就完美解决了</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门初体验</title>
    <url>/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker%E5%85%A5%E9%97%A8%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>如需安装 Docker CE，您需要 64 位版本的 CentOS 7</p>
<p>卸载旧版本<br>Docker 的早期版本称为 docker 或 docker-engine。如果安装了这些版本，请卸载它们及关联的依赖资源。</p>
<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum remove docker \</span>
                  docker-common \
                  docker-selinux \
                  docker-engine</code></pre>

<p>更新yum到最新</p>
<pre><code class="hljs shell">sudo yum update</code></pre>
<p>安装依赖</p>
<pre><code class="hljs shell">yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre>
<p>设置镜像</p>
<pre><code class="hljs shell">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre>

<p>更新 yum 软件包索引。</p>
<pre><code class="hljs shell">sudo yum makecache fast</code></pre>
<p>安装最新版本的 Docker CE，或者转至下一步以安装特定版本。</p>
<pre><code class="hljs shell">sudo yum install docker-ce</code></pre>
<p>查看版本、信息</p>
<pre><code class="hljs shell">docker -v
docker info</code></pre>
<p>启动、停止、重启，开启自启docker</p>
<pre><code class="hljs shell">systemctl start/stop/restart/enable docker</code></pre>

<h1 id="三、常用指令"><a href="#三、常用指令" class="headerlink" title="三、常用指令"></a>三、常用指令</h1><h4 id="1-镜像相关"><a href="#1-镜像相关" class="headerlink" title="1.镜像相关"></a>1.镜像相关</h4><h6 id="1-1查看镜像"><a href="#1-1查看镜像" class="headerlink" title="1.1查看镜像"></a>1.1查看镜像</h6><pre><code class="hljs shell">docker images</code></pre>

<h6 id="1-2-删除镜像"><a href="#1-2-删除镜像" class="headerlink" title="1.2.删除镜像"></a>1.2.删除镜像</h6><pre><code class="hljs shell">docker rmi 镜像名字或者id
docker rmi `docker images -q`  //删除所有</code></pre>
<h6 id="1-3-搜搜镜像"><a href="#1-3-搜搜镜像" class="headerlink" title="1.3.搜搜镜像"></a>1.3.搜搜镜像</h6><pre><code class="hljs shell">docker search 镜像名字</code></pre>
<h6 id="1-4-拉取镜像"><a href="#1-4-拉取镜像" class="headerlink" title="1.4.拉取镜像"></a>1.4.拉取镜像</h6><pre><code class="hljs shell">docker pull 镜像名字</code></pre>
<h4 id="2-容器相关"><a href="#2-容器相关" class="headerlink" title="2.容器相关"></a>2.容器相关</h4><h6 id="2-1-查看容器"><a href="#2-1-查看容器" class="headerlink" title="2.1.查看容器"></a>2.1.查看容器</h6><p> 查看所有，运行+没运行的    </p>
<pre><code class="hljs shell">docker ps //正在运行的容器
docker ps -a //全部容器
docker ps -l //最后一次运行的容器
docker ps -f status=exited //查看停止的容器</code></pre>
<h6 id="2-2-创建容器"><a href="#2-2-创建容器" class="headerlink" title="2.2.创建容器"></a>2.2.创建容器</h6><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>表示运行容器</td>
</tr>
<tr>
<td>-t</td>
<td>表示启动后进入其命令行。加入这个参数后，肉哦容器创建就能进入一个伪终端</td>
</tr>
<tr>
<td>–name</td>
<td>容器名字</td>
</tr>
<tr>
<td>-v</td>
<td>目录映射，‘:’分割前面是宿主目录，后者是容器目录，可以多个-v创建多个映射目录</td>
</tr>
<tr>
<td>-d</td>
<td>守护式创建容器，即创建后不会进去命令行</td>
</tr>
<tr>
<td>-p</td>
<td>端口映射，‘:’分割，前者是主机端口，后者是容器端口</td>
</tr>
</tbody></table>
<p>1.交互式方式创建容器</p>
<pre><code class="hljs shell">docker run -it --name=容器名称 镜像名称:标签 /bin/bash
exit //退出容器</code></pre>
<p>2.守护式方式创建容器</p>
<pre><code class="hljs shell">docker run -di --name=容器名称 镜像名称:标签
docker exec -it 容器名称(或者id) /bin/bash</code></pre>
<p>3.停止启动容器</p>
<pre><code class="hljs shell">docker stop 容器名称(或者id)
docker start 容器名称(或者id)</code></pre>
<p>4.主机与容器文件互相拷贝</p>
<pre><code class="hljs shell">docker cp 主机目录 容器名称:容器目录  //主机到容器
docker cp 容器名称:容器目录 主机目录  //容器到主机</code></pre>
<p>5.目录挂载</p>
<pre><code class="hljs shell">docker run -di -v 主机目录:容器目录 --name=容器名称 镜像名称</code></pre>

<p>6.查看容器信息、ip</p>
<pre><code class="hljs shell">docker inspect 容器名称（id） 
docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; 容器名称（id）</code></pre>

<p>7.删除容器</p>
<pre><code class="hljs shell">docker rm 容器名称（id）</code></pre>

<h1 id="四、搭建环境"><a href="#四、搭建环境" class="headerlink" title="四、搭建环境"></a>四、搭建环境</h1><h4 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1.mysql"></a>1.mysql</h4><pre><code class="hljs shell">docker run -di --name=con_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123 centos/mysql-57-centos7</code></pre>
<h4 id="2-tomcat"><a href="#2-tomcat" class="headerlink" title="2.tomcat"></a>2.tomcat</h4><pre><code class="hljs shell">run -di --name=tomcat7 -p 8888:8080 -v /usr/local/webapps:/usr/local/webapps tomcat:7-jre7</code></pre>
<h4 id="3-tomcat"><a href="#3-tomcat" class="headerlink" title="3.tomcat"></a>3.tomcat</h4><pre><code class="hljs shell">docker run -di --name=mynginx -p 8889:80 nginx</code></pre>
<h4 id="4-redis"><a href="#4-redis" class="headerlink" title="4.redis"></a>4.redis</h4><pre><code class="hljs shell">docker run -di --name=myredis -p 16379:6379 redis</code></pre>
<h1 id="四、保存备份"><a href="#四、保存备份" class="headerlink" title="四、保存备份"></a>四、保存备份</h1><h4 id="4-1-容器保存为镜像"><a href="#4-1-容器保存为镜像" class="headerlink" title="4.1 容器保存为镜像"></a>4.1 容器保存为镜像</h4><pre><code class="hljs shell">docker commit 容器名字 镜像名字</code></pre>
<h4 id="4-2-镜像备份"><a href="#4-2-镜像备份" class="headerlink" title="4.2 镜像备份"></a>4.2 镜像备份</h4><pre><code class="hljs shell">docker save -o 名字.tar 镜像名字</code></pre>
<h4 id="4-3镜像恢复"><a href="#4-3镜像恢复" class="headerlink" title="4.3镜像恢复"></a>4.3镜像恢复</h4><pre><code class="hljs shell">docker load  -i 镜像名字.tar</code></pre>

<h1 id="五、Dockerfile"><a href="#五、Dockerfile" class="headerlink" title="五、Dockerfile"></a>五、Dockerfile</h1><h4 id="5-1常用指令"><a href="#5-1常用指令" class="headerlink" title="5.1常用指令"></a>5.1常用指令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td>FROM image_name:tag</td>
<td>定义了从哪个镜像启动构建流程</td>
</tr>
<tr>
<td>MAINTAINER username</td>
<td>声明创作者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>定义环境变量,可以多条</td>
</tr>
<tr>
<td>RUN cmd</td>
<td>核心部分，可以写多条</td>
</tr>
<tr>
<td>ADD 宿主目录文件 容器目录文件</td>
<td>重宿主机添加文件到容器，会自动解压</td>
</tr>
<tr>
<td>COPY 宿主目录文件 容器目录文件</td>
<td>重宿主机添加文件到容器,不解压</td>
</tr>
<tr>
<td>WORKDIR 容器目录</td>
<td>工作目录</td>
</tr>
<tr>
<td>#### 5.2 例子</td>
<td></td>
</tr>
</tbody></table>
<pre><code class="hljs shell">FROM centos:7
MAINTAINER Uncle
WORKDIR /usr
RUN mkdir /usr/local
ADD jdk1.8.tar.gz /usr/local
ENV PATH /usr/local/jdk1.8/bin:$PATH</code></pre>
<h4 id="5-3-构建"><a href="#5-3-构建" class="headerlink" title="5.3 构建"></a>5.3 构建</h4><pre><code class="hljs shell">docker build -t=&#x27;镜像名称&#x27; Dockerfile所在目录</code></pre>
]]></content>
      <categories>
        <category>容器化</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch-Head安装配置</title>
    <url>/%E9%97%AE%E9%A2%98%E6%95%99%E7%A8%8B/ElasticSearch-Head%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h4 id="1-elasticSearch安装"><a href="#1-elasticSearch安装" class="headerlink" title="1.elasticSearch安装"></a>1.elasticSearch安装</h4><p>在官网下载<a href="https://www.elastic.co/cn/">https://www.elastic.co/cn/</a><br>节压后点击elasticSearch.bat即可运行，注意对应java版本<br>访问127.0.0.1:9200看到json数据则成功</p>
<h4 id="2-图形化工具安装："><a href="#2-图形化工具安装：" class="headerlink" title="2.图形化工具安装："></a>2.图形化工具安装：</h4><p>图形化工具<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p>
<ol>
<li>node.js环境，下载node.js安装<br> 1.行npm install -g grunt-cli<br> 2.然后npm install</li>
<li>开启在bin目录执行grunt server；<br> <a href="http://localhost:9100/即可访问">http://localhost:9100/即可访问</a></li>
<li>解决跨域问题<br> 在elasticSearch下的config/elasticsearch.yml添加<br> http.cors.enabled: true<br>http.cors.allow-origin: “*”<br>重启即可</li>
</ol>
]]></content>
      <categories>
        <category>问题教程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>搜索</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucen入门使用</title>
    <url>/Java/%E5%85%B6%E4%BB%96/Lucen%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。</p>
<h1 id="二、lucene实现全文检索流程"><a href="#二、lucene实现全文检索流程" class="headerlink" title="二、lucene实现全文检索流程"></a>二、lucene实现全文检索流程</h1><p><img src="https://img-blog.csdnimg.cn/20190411193346339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190411193346339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>1、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：<br>确定原始内容即要搜索的内容 =&gt; 采集文档 =&gt; 创建文档=&gt;分析文档=&gt;索引文档</p>
<p>2、红色表示搜索过程，从索引库中搜索内容，搜索过程包括：<br>用户通过搜索界面=&gt;创建查询=&gt;执行搜索，从索引库搜索=&gt;渲染搜索结果</p>
<h1 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h1><h3 id="3-1-jar包"><a href="#3-1-jar包" class="headerlink" title="3.1 jar包"></a>3.1 jar包</h3><p>lucene-analyzers-common.jar<br>lucene-core.jar<br>ikAnalyzer.jar<br>lucene-queryparser.jar</p>
<h4 id="3-2-创建索引"><a href="#3-2-创建索引" class="headerlink" title="3.2 创建索引"></a>3.2 创建索引</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">//指定索引库存放的路径</span>
    FSDirectory fsDirectory = FSDirectory.open(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\java\\IDEA_WORKSPACE\\LuceneDomo\\index&quot;</span>).toPath());
    <span class="hljs-comment">//使用IKAnalyzer分析器</span>
    IndexWriterConfig config=<span class="hljs-keyword">new</span> IndexWriterConfig(<span class="hljs-keyword">new</span> IKAnalyzer());
    <span class="hljs-comment">//创建indexwriter对象</span>
    IndexWriter writer=<span class="hljs-keyword">new</span> IndexWriter(fsDirectory,config);
    <span class="hljs-comment">//原始文档</span>
    File[] files=<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;H:\\searchsource&quot;</span>).listFiles();
    <span class="hljs-keyword">for</span> (File f:files)&#123;
        String name = f.getName();
        String path = f.getPath();
        String content= FileUtils.readFileToString(f, <span class="hljs-string">&quot;utf-8&quot;</span>);
        <span class="hljs-keyword">long</span> size = FileUtils.sizeOf(f);
        <span class="hljs-comment">//创建域</span>
        Field fName=<span class="hljs-keyword">new</span> TextField(<span class="hljs-string">&quot;name&quot;</span>,name,Field.Store.YES);
        Field fPath=<span class="hljs-keyword">new</span> StoredField(<span class="hljs-string">&quot;path&quot;</span>,path);
        Field fContent=<span class="hljs-keyword">new</span> TextField(<span class="hljs-string">&quot;content&quot;</span>,content,Field.Store.YES);
        Field lSize=<span class="hljs-keyword">new</span> LongPoint(<span class="hljs-string">&quot;size&quot;</span>,size);
        Field fSize=<span class="hljs-keyword">new</span> StoredField(<span class="hljs-string">&quot;size&quot;</span>,size);
        <span class="hljs-comment">//存入域</span>
        Document doc=<span class="hljs-keyword">new</span> Document();
        doc.add(fName);
        doc.add(fContent);
        doc.add(fPath);
        doc.add(fSize);
        doc.add(lSize);
        writer.addDocument(doc);
    &#125;
    writer.close();
&#125;</code></pre>
<h3 id="3-3-检索"><a href="#3-3-检索" class="headerlink" title="3.3 检索"></a>3.3 检索</h3><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
       <span class="hljs-comment">//指定索引库存放的路径</span>
       FSDirectory fsDirectory = FSDirectory.open(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\java\\IDEA_WORKSPACE\\LuceneDomo\\index&quot;</span>).toPath());
       IndexReader reader= DirectoryReader.open(fsDirectory);
       IndexSearcher searcher=<span class="hljs-keyword">new</span> IndexSearcher(reader);
       Query query=<span class="hljs-keyword">new</span> TermQuery(<span class="hljs-keyword">new</span> Term(<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;spring&quot;</span>));
       TopDocs docs = searcher.search(query, <span class="hljs-number">10</span>);
       System.out.println(<span class="hljs-string">&quot;共记录：&quot;</span>+docs.totalHits);
       <span class="hljs-keyword">for</span> (ScoreDoc doc:docs.scoreDocs)&#123;
           <span class="hljs-keyword">int</span> id=doc.doc;
           Document document = searcher.doc(id);
           System.out.println(document.get(<span class="hljs-string">&quot;name&quot;</span>));
           System.out.println(document.get(<span class="hljs-string">&quot;path&quot;</span>));
       &#125;
       reader.close();
   &#125;</code></pre>
<h1 id="四、分析器"><a href="#四、分析器" class="headerlink" title="四、分析器"></a>四、分析器</h1><h3 id="4-1-IkAnalyzer中文分析器（第三方）"><a href="#4-1-IkAnalyzer中文分析器（第三方）" class="headerlink" title="4.1. IkAnalyzer中文分析器（第三方）"></a>4.1. IkAnalyzer中文分析器（第三方）</h3><p>对中文支持比好，扩展性也好</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">analyzer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
       Analyzer analyzer=<span class="hljs-keyword">new</span> IKAnalyzer();
       TokenStream tokenStream = analyzer.tokenStream(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;们都是一些公开给别人尝试破解的小程序，制作 Crackme 的人可能是程序员，想测试一下自己的软件保护技术 &quot;</span>);
       CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class);
       tokenStream.reset();
       <span class="hljs-keyword">while</span> (tokenStream.incrementToken())&#123;
           System.out.println(charTermAttribute.toString());
       &#125;
       tokenStream.close();
   &#125;</code></pre>
<h3 id="4-2-StandardAnalyzer（自带）"><a href="#4-2-StandardAnalyzer（自带）" class="headerlink" title="4.2 StandardAnalyzer（自带）"></a>4.2 StandardAnalyzer（自带）</h3><p>对英文支持比较好，对中文分析不行，就是按照中文一个字一个字地进行分词。<br>如：“我爱中国”，<br>效果：“我”、“爱”、“中”、“国”。</p>
<h3 id="4-3-SmartChineseAnalyzer（自带）"><a href="#4-3-SmartChineseAnalyzer（自带）" class="headerlink" title="4.3 SmartChineseAnalyzer（自带）"></a>4.3 SmartChineseAnalyzer（自带）</h3><p>对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理</p>
<h1 id="五、索引库的维护"><a href="#五、索引库的维护" class="headerlink" title="五、索引库的维护"></a>五、索引库的维护</h1><table>
<thead>
<tr>
<th>Field类</th>
<th>数据类型</th>
<th>Analyzed是否分析</th>
<th>Indexed是否索引</th>
<th>Stored是否存储</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StringField(FieldName, FieldValue,Store.YES))</td>
<td>字符串</td>
<td>N</td>
<td>Y</td>
<td>Y或N</td>
<td>这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)是否存储在文档中用Store.YES或Store.NO决定</td>
</tr>
<tr>
<td>LongPoint(String name, long… point)</td>
<td>Long型</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>可以使用LongPoint、IntPoint等类型存储数值类型的数据。让数值类型可以进行索引。但是不能存储数据，如果想存储数据还需要使用StoredField。</td>
</tr>
<tr>
<td>StoredField(FieldName, FieldValue)</td>
<td>重载方法，支持多种类型</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>这个Field用来构建不同类型Field不分析，不索引，但要Field存储在文档中</td>
</tr>
<tr>
<td>TextField(FieldName, FieldValue, Store.NO)或TextField(FieldName, reader)</td>
<td>字符串或流</td>
<td>Y</td>
<td>Y</td>
<td>Y或N</td>
<td>如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略.</td>
</tr>
</tbody></table>
<h3 id="5-1-添加文档"><a href="#5-1-添加文档" class="headerlink" title="5.1 添加文档"></a>5.1 添加文档</h3><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">//索引库存放路径</span>
    Directory directory = FSDirectory.open(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C://index&quot;</span>).toPath());
    IndexWriterConfig config = <span class="hljs-keyword">new</span> IndexWriterConfig(<span class="hljs-keyword">new</span> IKAnalyzer());
    <span class="hljs-comment">//创建一个indexwriter对象</span>
    IndexWriter indexWriter = <span class="hljs-keyword">new</span> IndexWriter(directory, config);
    <span class="hljs-comment">//创建一个Document对象</span>
    Document document = <span class="hljs-keyword">new</span> Document();
    <span class="hljs-comment">//向document对象中添加域。</span>
    <span class="hljs-comment">//不同的document可以有不同的域，同一个document可以有相同的域。</span>
    document.add(<span class="hljs-keyword">new</span> TextField(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-string">&quot;新添加的文档&quot;</span>, Field.Store.YES));
    document.add(<span class="hljs-keyword">new</span> TextField(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;新添加的文档的内容&quot;</span>, Field.Store.NO));
    <span class="hljs-comment">//LongPoint创建索引</span>
    document.add(<span class="hljs-keyword">new</span> LongPoint(<span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-number">1000l</span>));
    <span class="hljs-comment">//StoreField存储数据</span>
    document.add(<span class="hljs-keyword">new</span> StoredField(<span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-number">1000l</span>));
    <span class="hljs-comment">//不需要创建索引的就使用StoreField存储</span>
    document.add(<span class="hljs-keyword">new</span> StoredField(<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;d:/temp/1.txt&quot;</span>));
    <span class="hljs-comment">//添加文档到索引库</span>
    indexWriter.addDocument(document);
    <span class="hljs-comment">//关闭indexwriter</span>
    indexWriter.close();

&#125;
</code></pre>

<h3 id="5-2-索引库删除"><a href="#5-2-索引库删除" class="headerlink" title="5.2 索引库删除"></a>5.2 索引库删除</h3><p>说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAllIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
		<span class="hljs-comment">//getIndexWriter重复代码省略为方法</span>
		IndexWriter indexWriter = getIndexWriter();
		<span class="hljs-comment">//删除全部索引</span>
		indexWriter.deleteAll();
		<span class="hljs-comment">//关闭indexwriter</span>
		indexWriter.close();
</code></pre>
<h3 id="5-3-指定查询条件删除"><a href="#5-3-指定查询条件删除" class="headerlink" title="5.3 指定查询条件删除"></a>5.3 指定查询条件删除</h3><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteIndexByQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
		IndexWriter indexWriter = getIndexWriter();
		<span class="hljs-comment">//创建一个查询条件</span>
		Query query = <span class="hljs-keyword">new</span> TermQuery(<span class="hljs-keyword">new</span> Term(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-string">&quot;apache&quot;</span>));
		<span class="hljs-comment">//根据查询条件删除</span>
		indexWriter.deleteDocuments(query);
		<span class="hljs-comment">//关闭indexwriter</span>
		indexWriter.close();
	&#125;
</code></pre>
<h3 id="5-4-7-3-索引库的修改"><a href="#5-4-7-3-索引库的修改" class="headerlink" title="5.4 7.3    索引库的修改"></a>5.4 7.3    索引库的修改</h3><p>原理就是先删除后添加。</p>
<pre><code class="hljs java"><span class="hljs-comment">//修改索引库</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    IndexWriter indexWriter = getIndexWriter();
    <span class="hljs-comment">//创建一个Document对象</span>
    Document document = <span class="hljs-keyword">new</span> Document();
    <span class="hljs-comment">//向document对象中添加域。</span>
    <span class="hljs-comment">//不同的document可以有不同的域，同一个document可以有相同的域。</span>
    document.add(<span class="hljs-keyword">new</span> TextField(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-string">&quot;要更新的文档&quot;</span>, Field.Store.YES));
    document.add(<span class="hljs-keyword">new</span> TextField(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot; Lucene 简介 Lucene 是一个基于 Java 的全文信息检索&quot;</span>,
                Field.Store.YES));
    indexWriter.updateDocument(<span class="hljs-keyword">new</span> Term(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>), document);
    <span class="hljs-comment">//关闭indexWriter</span>
    indexWriter.close();
&#125;
</code></pre>

<h1 id="六、Lucene索引库查询"><a href="#六、Lucene索引库查询" class="headerlink" title="六、Lucene索引库查询"></a>六、Lucene索引库查询</h1><p>对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法，类似关系数据库Sql语法一样Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。<br>    可通过两种方法创建查询对象：<br>    1）使用Lucene提供Query子类<br>    2）使用QueryParse解析查询表达式</p>
<h3 id="6-1-TermQuery"><a href="#6-1-TermQuery" class="headerlink" title="6.1 TermQuery"></a>6.1 TermQuery</h3><p>TermQuery，通过项查询，TermQuery不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等。指定要查询的域和要查询的关键词。<br>上面入门例子即是</p>
<h3 id="6-2-数值范围查询"><a href="#6-2-数值范围查询" class="headerlink" title="6.2 数值范围查询"></a>6.2 数值范围查询</h3><p>size为LongPoint类型</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRangeQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    IndexSearcher indexSearcher = getIndexSearcher();
    Query query = LongPoint.newRangeQuery(<span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-number">0L</span>, <span class="hljs-number">10000L</span>);
    printResult(query, indexSearcher);
&#125;</code></pre>
<h3 id="6-3-使用queryparser查询"><a href="#6-3-使用queryparser查询" class="headerlink" title="6.3 使用queryparser查询"></a>6.3 使用queryparser查询</h3><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQueryParser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
      <span class="hljs-comment">//指定索引库存放的路径</span>
      FSDirectory fsDirectory = FSDirectory.open(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\java\\IDEA_WORKSPACE\\LuceneDomo\\index&quot;</span>).toPath());
      <span class="hljs-comment">//指定索引库存放的路径</span>
      IndexReader reader= DirectoryReader.open(fsDirectory);
      IndexSearcher searcher=<span class="hljs-keyword">new</span> IndexSearcher(reader);
      QueryParser queryParser=<span class="hljs-keyword">new</span> QueryParser(<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-keyword">new</span> IKAnalyzer());
      Query query = queryParser.parse(<span class="hljs-string">&quot;Lucene是java开发的&quot;</span>);
      printResult(query,searcher);

  &#125;
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(Query query, IndexSearcher indexSearcher)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
      <span class="hljs-comment">//执行查询</span>
      TopDocs topDocs = indexSearcher.search(query, <span class="hljs-number">10</span>);
      <span class="hljs-comment">//共查询到的document个数</span>
      System.out.println(<span class="hljs-string">&quot;查询结果总数量：&quot;</span> + topDocs.totalHits);
      <span class="hljs-comment">//遍历查询结果</span>
      <span class="hljs-keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;
          Document document = indexSearcher.doc(scoreDoc.doc);
          System.out.println(document.get(<span class="hljs-string">&quot;name&quot;</span>));
          <span class="hljs-comment">//System.out.println(document.get(&quot;content&quot;));</span>
          System.out.println(document.get(<span class="hljs-string">&quot;path&quot;</span>));
          System.out.println(document.get(<span class="hljs-string">&quot;size&quot;</span>));
      &#125;
      <span class="hljs-comment">//关闭indexreader</span>
      indexSearcher.getIndexReader().close();
  &#125;</code></pre>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>贴下pom.xml方便使用</p>
<pre><code class="hljs java">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
    &lt;artifactId&gt;lucene-core&lt;/artifactId&gt;
    &lt;version&gt;8.0.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
    &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt;
    &lt;version&gt;8.0.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!--自己安装得--&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;com.lucene&lt;/groupId&gt;
    &lt;artifactId&gt;ikAnalyzer&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
    &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt;
    &lt;version&gt;8.0.0&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lucen</tag>
      </tags>
  </entry>
  <entry>
    <title>PageHelper入门初体验</title>
    <url>/Java/%E5%B7%A5%E5%85%B7/PageHelper%E5%85%A5%E9%97%A8%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>PageHelper是国内非常优秀的一款开源的mybatis分页插件，它支持基本主流与常用的数据库，例如mysql、oracle、mariaDB、DB2、SQLite、Hsqldb等。</p>
<p>github 的项目地址：<a href="https://github.com/pagehelper/Mybatis-PageHelper">https://github.com/pagehelper/Mybatis-PageHelper</a><br>gitosc 的项目地址：<a href="http://git.oschina.net/free/Mybatis_PageHelper">http://git.oschina.net/free/Mybatis_PageHelper</a></p>
<h2 id="二、简单使用"><a href="#二、简单使用" class="headerlink" title="二、简单使用"></a>二、简单使用</h2><h4 id="2-1-准备"><a href="#2-1-准备" class="headerlink" title="2.1 准备"></a>2.1 准备</h4><h6 id="2-2-1-导入jar包方式"><a href="#2-2-1-导入jar包方式" class="headerlink" title="2.2.1 导入jar包方式"></a>2.2.1 导入jar包方式</h6><p>PageHelper<a href="http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/">最新下载地址</a><br>由于使用了sql 解析工具，你还需要下载<a href="http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/">jsqlparser.jar</a></p>
<h6 id="2-2-2-Maven依赖"><a href="#2-2-2-Maven依赖" class="headerlink" title="2.2.2 Maven依赖"></a>2.2.2 Maven依赖</h6><p>坐标</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h4 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h4><p>特别注意，新版拦截器是  com.github.pagehelper.PageInterceptor。com.github.pagehelper.PageHelper  现在是一个特殊的  dialect  实现类，是分页插件的默认实现类，提供了和以前相同的用法。</p>
<h6 id="2-2-1-Mybatis的xml配置中配置"><a href="#2-2-1-Mybatis的xml配置中配置" class="headerlink" title="2.2.1 Mybatis的xml配置中配置"></a>2.2.1 Mybatis的xml配置中配置</h6><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;param1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></code></pre>
<h6 id="2-2-2-在-Spring-配置文件中配置拦截器插件"><a href="#2-2-2-在-Spring-配置文件中配置拦截器插件" class="headerlink" title="2.2.2. 在 Spring 配置文件中配置拦截器插件"></a>2.2.2. 在 Spring 配置文件中配置拦截器插件</h6><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 配置pageHelper --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;plugins&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>
                      <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;helperDialect&quot;</span>&gt;</span>oracle<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
                      <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;reasonable&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
                  <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<h6 id="2-3-参数介绍"><a href="#2-3-参数介绍" class="headerlink" title="2.3 参数介绍"></a>2.3 参数介绍</h6><ol>
<li><strong>helperDialect</strong> ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2 , sqlserver2012 , derby<br>特别注意：使用 SqlServer2012 数据库时，需要手动指定为  sqlserver2012 ，否则会使用 SqlServer2005 的方式进行分页。<br>也可以实现  AbstractHelperDialect ，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。</li>
<li><strong>offsetAsPageNum</strong> ：默认值为  false ，该参数对使用  RowBounds  作为分页参数时有效。 当该参数设置为 true  时，会将  RowBounds  中的  offset  参数当成  pageNum  使用，可以用页码和页面大小两个参数进行分页。</li>
<li><strong>rowBoundsWithCount</strong> ：默认值为 false ，该参数对使用  RowBounds  作为分页参数时有效。 当该参数设置为 true 时，使用  RowBounds  分页会进行 count 查询。</li>
<li><strong>pageSizeZero</strong> ：默认值为  false ，当该参数设置为  true  时，如果  pageSize=0  或者  RowBounds.limit = 0  就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是  Page  类型）。</li>
<li><strong>reasonable</strong> ：分页合理化参数，默认值为 false 。当该参数设置为  true  时， pageNum&lt;=0  时会查询第一页， pageNum&gt;pages （超过总数时），会查询最后一页。默认 false  时，直接根据参数进行查询。</li>
<li><strong>params</strong> ：为了支持 startPage(Object params) 方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置  pageNum,pageSize,count,pageSizeZero,reasonable ，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。</li>
<li><strong>supportMethodsArguments</strong> ：支持通过 Mapper 接口参数来传递分页参数，默认值 false ，分页插件会从查询方法的参数值中，自动根据上面  params  配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的  com.github.pagehelper.test.basic  包下的  ArgumentsMapTest  和 ArgumentsObjTest 。</li>
<li><strong>autoRuntimeDialect</strong> ：默认值为  false 。设置为  true  时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择 sqlserver2012 ，只能使用 sqlserver ），用法和注意事项参考下面的场景五。</li>
<li><strong>closeConn</strong> ：默认值为  true 。当使用运行时动态数据源或没有设置  helperDialect  属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认 true 关闭，设置为 false  后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。</li>
</ol>
<h4 id="2-4-两种常用使用方式"><a href="#2-4-两种常用使用方式" class="headerlink" title="2.4 两种常用使用方式"></a>2.4 两种常用使用方式</h4><p>PageHelper的基本使用有6种，大家可以查看文档，最常用的有两种</p>
<h6 id="2-4-1-RowBounds方式的调用（了解）"><a href="#2-4-1-RowBounds方式的调用（了解）" class="headerlink" title="2.4.1. RowBounds方式的调用（了解）"></a>2.4.1. RowBounds方式的调用（了解）</h6><pre><code class="hljs java">List&lt;Country&gt; list = sqlSession.selectList(<span class="hljs-string">&quot;x.y.selectIf&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));</code></pre>
<p>使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。</p>
<p>分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。</p>
<p>关于这种方式的调用，有两个特殊的参数是针对  RowBounds  的，你可以参看上面的分页插件参数介绍</p>
<p> 注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如：</p>
<pre><code class="hljs java">  <span class="hljs-comment">//这种情况下也会进行物理分页查询</span>
<span class="hljs-function">List&lt;Country&gt; <span class="hljs-title">selectAll</span><span class="hljs-params">(RowBounds rowBounds)</span></span>;</code></pre>
<p>注意： 由于默认情况下的  RowBounds  无法获取查询总数，分页插件提供了一个继承自  RowBounds  的PageRowBounds ，这个对象中增加了  total  属性，执行分页查询后，可以从该属性得到查询总数。</p>
<h6 id="2-4-2-PageHelper-startPage-静态方法调用（重点）"><a href="#2-4-2-PageHelper-startPage-静态方法调用（重点）" class="headerlink" title="2.4.2. PageHelper.startPage 静态方法调用（重点）"></a>2.4.2. PageHelper.startPage 静态方法调用（重点）</h6><p>这种方式是我们要掌握的 在你需要进行分页的 MyBatis 查询方法前调用PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。</p>
<pre><code class="hljs java">PageHelper.startPage(page,pagesize);
dao.findAll(pagesize,page);</code></pre>

<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><p>主要使用的参数都在PageInfo中</p>
<pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IOrderService</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    OrderDao dao;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Orders&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Integer pagesize, Integer page)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        PageHelper.startPage(page,pagesize);
        <span class="hljs-keyword">return</span> dao.findAll(pagesize,page);
    &#125;
&#125;

<span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping(&quot;/orders&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    IOrderService service;
    <span class="hljs-meta">@RequestMapping(&quot;/findAll.do&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name=&quot;page&quot;,required = true,defaultValue =&quot;1&quot;)</span> Integer page,</span></span>
<span class="hljs-function"><span class="hljs-params">                                <span class="hljs-meta">@RequestParam(name=&quot;pageSize&quot;,required = true,defaultValue =&quot;10&quot;)</span> Integer pageSize)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ModelAndView mv=<span class="hljs-keyword">new</span> ModelAndView();
        List&lt;Orders&gt; ordersList = service.findAll(pageSize, page);
        PageInfo pageInfo=<span class="hljs-keyword">new</span> PageInfo(ordersList,<span class="hljs-number">3</span>);
        mv.addObject(<span class="hljs-string">&quot;pageInfo&quot;</span>,pageInfo);
        mv.setViewName(<span class="hljs-string">&quot;orders-list&quot;</span>);
        <span class="hljs-keyword">return</span> mv;
    &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>PageHelper</tag>
      </tags>
  </entry>
  <entry>
    <title>plsql简单入门</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/plsql%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h2 id="一、PL-SQL简介"><a href="#一、PL-SQL简介" class="headerlink" title="一、PL/SQL简介"></a>一、PL/SQL简介</h2><p>PL/SQL（Procedural Language/SQL）是甲骨文公司专有的SQL扩展语言，应用在甲骨文公司的Oracle数据库系统。一些的SQL数据库管理系统也提供了类似的扩展SQL语言。PL/SQL的的语法非常类似于Ada，而且像1980年代的Ada编译器一样，PL/SQL的运作系统使用Diana作为中介语言。</p>
<h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><p>测试表<br><img src="https://img-blog.csdnimg.cn/2019040621393121.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/2019040621393121.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h4 id="2-1基本语法骨架"><a href="#2-1基本语法骨架" class="headerlink" title="2.1基本语法骨架"></a>2.1基本语法骨架</h4><pre><code class="hljs sql"><span class="hljs-keyword">declare</span>
	声明区
<span class="hljs-keyword">begin</span>
	核心代码
<span class="hljs-keyword">end</span>;</code></pre>
<h6 id="2-1-1-输出hello-world"><a href="#2-1-1-输出hello-world" class="headerlink" title="2.1.1 输出hello world"></a>2.1.1 输出hello world</h6><pre><code class="hljs sql"><span class="hljs-keyword">declare</span>
	s <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">11</span>) :=<span class="hljs-string">&#x27;hello world&#x27;</span>;
<span class="hljs-keyword">begin</span>
	dbms_output.put_line(s);
<span class="hljs-keyword">end</span>;</code></pre>
<h6 id="2-1-2声明变量、赋值"><a href="#2-1-2声明变量、赋值" class="headerlink" title="2.1.2声明变量、赋值"></a>2.1.2声明变量、赋值</h6><p>1.声明格式： 变量名  数据类型及长度 </p>
<pre><code class="hljs sql">i number(10)  := 10;
name varchar2(10) :=abc;
<span class="hljs-comment">--根据emp表中的ename的数据类型来声明</span>
name2 emp.ename%type;</code></pre>
<p>2.sql赋值<br>||符号是字符连接符号</p>
<pre><code class="hljs sql"><span class="hljs-keyword">declare</span>
	<span class="hljs-keyword">name</span> emp.ename%<span class="hljs-keyword">type</span>;
	msal emp.sal%type;
<span class="hljs-keyword">begin</span>
	<span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">into</span> <span class="hljs-keyword">name</span>,msal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> empno=<span class="hljs-number">7369</span>;
	dbms_output.put_line(name || &#x27;<span class="hljs-comment">--&#x27; || msal);</span>
<span class="hljs-keyword">end</span>;</code></pre>

<h4 id="2-2流程控制"><a href="#2-2流程控制" class="headerlink" title="2.2流程控制"></a>2.2流程控制</h4><p>&amp;inNum    读入一个数,名字随意</p>
<h6 id="2-2-1-if判断"><a href="#2-2-1-if判断" class="headerlink" title="2.2.1 if判断"></a>2.2.1 if判断</h6><p>读入一个数，根据数值判断哪个年代</p>
<pre><code class="hljs sql"><span class="hljs-keyword">declare</span>
	i <span class="hljs-built_in">number</span>(<span class="hljs-number">2</span>) :=&amp;inNum;
<span class="hljs-keyword">begin</span>
	<span class="hljs-keyword">if</span> i&lt;<span class="hljs-number">18</span> <span class="hljs-keyword">then</span> 
		dbms_output.put_line(<span class="hljs-string">&#x27;未成年&#x27;</span>);
	elsif i&lt;40 then
		dbms_output.put_line(&#x27;不惑之年&#x27;);
	else
		dbms_output.put_line(&#x27;老了老了&#x27;);
	<span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
<span class="hljs-keyword">end</span>;</code></pre>
<h6 id="2-2-2-while循环"><a href="#2-2-2-while循环" class="headerlink" title="2.2.2 while循环"></a>2.2.2 while循环</h6><p>打印1到10</p>
<pre><code class="hljs sql"><span class="hljs-keyword">declare</span>
	i <span class="hljs-built_in">number</span>(<span class="hljs-number">2</span>) :=<span class="hljs-number">1</span>;
<span class="hljs-keyword">begin</span>
	<span class="hljs-keyword">while</span> i&lt;<span class="hljs-number">11</span> <span class="hljs-keyword">loop</span>
		dbms_output.put_line(i);
		i := i+1;
	<span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;
<span class="hljs-keyword">end</span>;</code></pre>

<h6 id="2-2-3-exit-循环"><a href="#2-2-3-exit-循环" class="headerlink" title="2.2.3 exit 循环"></a>2.2.3 exit 循环</h6><p>打印1到10</p>
<pre><code class="hljs sql"><span class="hljs-keyword">declare</span>
	i <span class="hljs-built_in">number</span>(<span class="hljs-number">2</span>) :=<span class="hljs-number">1</span>;
<span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">loop</span>
    <span class="hljs-keyword">exit</span> <span class="hljs-keyword">when</span> i&gt;<span class="hljs-number">10</span>;
		dbms_output.put_line(i);
		i := i+1;
	<span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;
<span class="hljs-keyword">end</span>;</code></pre>

<h6 id="2-2-3-for-循环"><a href="#2-2-3-for-循环" class="headerlink" title="2.2.3 for 循环"></a>2.2.3 for 循环</h6><p>打印1到10</p>
<pre><code class="hljs sql"><span class="hljs-keyword">declare</span>
<span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> <span class="hljs-keyword">loop</span>
    	dbms_output.put_line(i);
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;
<span class="hljs-keyword">end</span>;</code></pre>
<h4 id="2-3-游标"><a href="#2-3-游标" class="headerlink" title="2.3 游标"></a>2.3 游标</h4><p>可以记录多个对象，多行记录</p>
<pre><code class="hljs sql"><span class="hljs-keyword">declare</span> 
	<span class="hljs-comment">--无参游标</span>
	<span class="hljs-keyword">cursor</span> c1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp;
	empRow emp%rowtype; <span class="hljs-comment">--一行数据类型</span>
	<span class="hljs-comment">--带参游标</span>
	cursor c2(dno emp.deptno%type) is <span class="hljs-keyword">select</span> empno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno=dno;
	eno emp.empno%type;
<span class="hljs-keyword">begin</span>
	<span class="hljs-comment">--无参遍历</span>
	<span class="hljs-keyword">open</span> c1;		
		loop
			fetch c1 into empRow;
			exit when c1%notfound;
			dbms_output.put_line(empRow.ename||&#x27;<span class="hljs-comment">--&#x27;||empRow.sal);</span>
		<span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;
	close c1;
	<span class="hljs-comment">--带参遍历</span>
	open c2(10);		
		loop
			fetch c2 into eno;
			exit when c2%notfound;
			dbms_output.put_line(eno);
		<span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;
	close c2;
<span class="hljs-keyword">end</span>;</code></pre>

<h2 id="三、存储过程、函数"><a href="#三、存储过程、函数" class="headerlink" title="三、存储过程、函数"></a>三、存储过程、函数</h2><h4 id="3-1存储过程"><a href="#3-1存储过程" class="headerlink" title="3.1存储过程"></a>3.1存储过程</h4><p>存储过程的就是提前编译好的一段pl/sql语言，放置在数据库中，可以直接被调用，这一段pl/sql一般都是固定步骤的业务<br>注意：参数和返回值的数据类型不能带长度</p>
<h6 id="3-1-1-创建语法"><a href="#3-1-1-创建语法" class="headerlink" title="3.1.1 创建语法"></a>3.1.1 创建语法</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>] <span class="hljs-keyword">procedure</span> 过程名字（参数 <span class="hljs-keyword">in</span>/<span class="hljs-keyword">out</span> 数据类型）
<span class="hljs-keyword">as</span>/<span class="hljs-keyword">is</span>
<span class="hljs-keyword">begin</span> 
	程序体
<span class="hljs-keyword">end</span>;</code></pre>
<h6 id="3-1-2-例子"><a href="#3-1-2-例子" class="headerlink" title="3.1.2 例子"></a>3.1.2 例子</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span> <span class="hljs-keyword">procedure</span> findNameById(eno <span class="hljs-keyword">in</span> emp.empno%<span class="hljs-keyword">type</span>,sname <span class="hljs-keyword">out</span> emp.ename%<span class="hljs-keyword">type</span>)
<span class="hljs-keyword">is</span>
<span class="hljs-keyword">begin</span> 
	<span class="hljs-keyword">select</span> ename <span class="hljs-keyword">into</span> sname <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> empno=eno;
<span class="hljs-keyword">end</span>;

<span class="hljs-comment">--调用</span>
<span class="hljs-keyword">declare</span>
	sname emp.ename%<span class="hljs-keyword">type</span>;
<span class="hljs-keyword">begin</span>
	findNameById(<span class="hljs-number">7782</span>,sname);
	dbms_output.put_line(sname);
<span class="hljs-keyword">end</span>;</code></pre>

<h4 id="3-2存储函数"><a href="#3-2存储函数" class="headerlink" title="3.2存储函数"></a>3.2存储函数</h4><h6 id="3-2-1创建语法"><a href="#3-2-1创建语法" class="headerlink" title="3.2.1创建语法"></a>3.2.1创建语法</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>] <span class="hljs-keyword">function</span> 函数名字（参数  数据类型） <span class="hljs-keyword">return</span> 数据类型
<span class="hljs-keyword">as</span>/<span class="hljs-keyword">is</span>
<span class="hljs-keyword">begin</span> 
	程序体
<span class="hljs-keyword">end</span>;</code></pre>
<h6 id="3-2-2-例子"><a href="#3-2-2-例子" class="headerlink" title="3.2.2 例子"></a>3.2.2 例子</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span> <span class="hljs-keyword">function</span> findNameByEid(eno emp.empno%<span class="hljs-keyword">type</span>) <span class="hljs-keyword">return</span> emp.ename%<span class="hljs-keyword">type</span> 
<span class="hljs-keyword">is</span>
	sname emp.ename%<span class="hljs-keyword">type</span>;
<span class="hljs-keyword">begin</span> 
	<span class="hljs-keyword">select</span> ename <span class="hljs-keyword">into</span> sname <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> empno=eno;
	return sname;
<span class="hljs-keyword">end</span>;

<span class="hljs-comment">--调用</span>
<span class="hljs-keyword">declare</span>
<span class="hljs-keyword">begin</span>
	dbms_output.put_line(findNameByEid(<span class="hljs-number">7782</span>));
<span class="hljs-keyword">end</span>;</code></pre>
<h2 id="四、触发器"><a href="#四、触发器" class="headerlink" title="四、触发器"></a>四、触发器</h2><p>数据库触发器是一个与表相关联的、存储的 PL/SQL 程序。每当一个特定的数据操作语句<br>(Insert,update,delete)在指定的表上发出时，Oracle自动地执行触发器中定义的语句序列。   </p>
<h4 id="4-1-作用及器类型"><a href="#4-1-作用及器类型" class="headerlink" title="4.1 作用及器类型"></a>4.1 作用及器类型</h4><h6 id="4-1-1-触发器可用于"><a href="#4-1-1-触发器可用于" class="headerlink" title="4.1.1 触发器可用于"></a>4.1.1 触发器可用于</h6><ul>
<li>数据确认    </li>
<li>实施复杂的安全性检查 </li>
<li>做审计，跟踪表上所做的数据操作等   </li>
<li>数据的备份和同步   </li>
</ul>
<h6 id="4-1-2-触发器的类型"><a href="#4-1-2-触发器的类型" class="headerlink" title="4.1.2 触发器的类型   :"></a>4.1.2 触发器的类型   :</h6><p><strong>语句级触发器</strong> ：在指定的操作语句操作之前或之后执行一次，不管这条语句影响了多少行 。<br><strong>行级触发器(FOR EACH ROW)</strong>：触发语句作用的每一条记录都被触发。在行级触 发器中使用old和new伪记录变量, 识别值的状态。   </p>
<p>在触发器中触发语句与伪记录变量的值<br><img src="https://img-blog.csdnimg.cn/20190406221924528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190406221924528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h4 id="4-2基本语法"><a href="#4-2基本语法" class="headerlink" title="4.2基本语法"></a>4.2基本语法</h4><p>CREATE  [or REPLACE] TRIGGER  触发器名<br>    {BEFORE | AFTER}<br>    {DELETE | INSERT | UPDATE [OF 列名]}<br>    ON  表名<br>    [FOR EACH ROW [WHEN(条件) ] ]<br>declare<br>begin<br>    PLSQL 块<br>End；</p>
<h4 id="4-3-例子"><a href="#4-3-例子" class="headerlink" title="4.3 例子"></a>4.3 例子</h4><p>实现主键自增长,user_k是自定义的序列，每次执行insert语句都会自动增长id了</p>
<pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span> <span class="hljs-keyword">trigger</span> myAutoAdd
<span class="hljs-keyword">before</span>
<span class="hljs-keyword">insert</span>
<span class="hljs-keyword">on</span> c<span class="hljs-comment">##user</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span>
<span class="hljs-keyword">declare</span> 
<span class="hljs-keyword">begin</span>
	<span class="hljs-keyword">select</span> user_k.nextval <span class="hljs-keyword">into</span> :new.id <span class="hljs-keyword">from</span> dual;
<span class="hljs-keyword">end</span>;</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>PLSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle的查询、视图、索引</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/oracle%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E7%B4%A2%E5%BC%95.html</url>
    <content><![CDATA[<p>所有表来自oracle的scott用户的默认表</p>
<h2 id="一、查询"><a href="#一、查询" class="headerlink" title="一、查询"></a>一、查询</h2><h4 id="1-1分组查询"><a href="#1-1分组查询" class="headerlink" title="1.1分组查询"></a>1.1分组查询</h4><p>查询平均工资大于2000的部门<br>t.deptno 部门<br>t.sal 工资</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> t.deptno ,<span class="hljs-keyword">avg</span>(t.sal)
<span class="hljs-keyword">from</span> emp t
<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> t.deptno
<span class="hljs-keyword">having</span> <span class="hljs-keyword">avg</span>(t.sal)&gt;<span class="hljs-number">2000</span>;</code></pre>
<h4 id="1-2多表查询"><a href="#1-2多表查询" class="headerlink" title="1.2多表查询"></a>1.2多表查询</h4><h6 id="1-2-1-内连接"><a href="#1-2-1-内连接" class="headerlink" title="1.2.1 内连接"></a>1.2.1 内连接</h6><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp e,dept d <span class="hljs-keyword">where</span> e.deptno=d.deptno;
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno=d.deptno;</code></pre>
<h6 id="1-2-2-外连接"><a href="#1-2-2-外连接" class="headerlink" title="1.2.2 外连接"></a>1.2.2 外连接</h6><pre><code class="hljs sql"><span class="hljs-comment">--左外连接</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno=d.deptno;
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.deptno(+)=d.deptno;
<span class="hljs-comment">--右外连接</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno=d.deptno;
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.deptno=d.deptno(+);</code></pre>
<h6 id="1-2-3-自连接"><a href="#1-2-3-自连接" class="headerlink" title="1.2.3 自连接"></a>1.2.3 自连接</h6><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e1.ename <span class="hljs-keyword">as</span> 员工,e2.ename <span class="hljs-keyword">as</span> 上级
<span class="hljs-keyword">from</span> emp e1,emp e2
<span class="hljs-keyword">where</span> e1.mgr=e2.empno;</code></pre>
<h6 id="1-2-4子查询"><a href="#1-2-4子查询" class="headerlink" title="1.2.4子查询"></a>1.2.4子查询</h6><p>1.如果返回一个值则使用where ？=(sql)<br>2.返回一个列表则使用 where ? in (sql)<br>3.返回一张表</p>
<pre><code class="hljs sql"><span class="hljs-comment">-- 查询部分最低工资，最低工资员工姓名，所在部门名字</span>
<span class="hljs-keyword">select</span> t.msal,e.ename,d.dname
<span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> deptno,<span class="hljs-keyword">min</span>(sal) msal
      <span class="hljs-keyword">from</span> emp
      <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno) t,emp e,dept d
<span class="hljs-keyword">where</span> t.msal=e.sal
<span class="hljs-keyword">and</span> t.deptno=d.deptno;</code></pre>

<h6 id="1-2-5分页查询"><a href="#1-2-5分页查询" class="headerlink" title="1.2.5分页查询"></a>1.2.5分页查询</h6><p>oracle的分页查询依靠rownum,<br>select每查询一条记录就会加个rownum,<br>rownum初始为1，依次递增，不能跳着走；<br>当查询时加入order by的时候就可能导致rownum错乱<br>比如:</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">rownum</span>,e.* <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span>;</code></pre>
<p>结果集：<br><img src="https://img-blog.csdnimg.cn/20190406184520927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190406184520927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>select 先执行完了再排序的，所以，rownum乱了</p>
<p>分页查询模板：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>
      (<span class="hljs-keyword">select</span> <span class="hljs-keyword">rownum</span> rn,e1.* <span class="hljs-keyword">from</span>
             (<span class="hljs-keyword">select</span> e.* <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span>) e1 
      <span class="hljs-keyword">where</span> <span class="hljs-keyword">rownum</span> &lt;<span class="hljs-number">10</span>)
<span class="hljs-keyword">where</span> rn&gt;<span class="hljs-number">5</span>;</code></pre>

<h2 id="二、视图"><a href="#二、视图" class="headerlink" title="二、视图"></a>二、视图</h2><h4 id="2-1创建视图"><a href="#2-1创建视图" class="headerlink" title="2.1创建视图"></a>2.1创建视图</h4><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> v_emp <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span>  ename,sal <span class="hljs-keyword">from</span> emp;
<span class="hljs-comment">--只读视图</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> v_emp <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span>  ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">with</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">only</span>;</code></pre>
<h4 id="2-2查询视图"><a href="#2-2查询视图" class="headerlink" title="2.2查询视图"></a>2.2查询视图</h4><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> v_emp;</code></pre>
<h4 id="2-3修改视图内容"><a href="#2-3修改视图内容" class="headerlink" title="2.3修改视图内容"></a>2.3修改视图内容</h4><p>修改后对应表的值也会变</p>
<pre><code class="hljs sql"><span class="hljs-keyword">update</span> v_emp <span class="hljs-keyword">set</span> sal=<span class="hljs-number">1000.00</span> <span class="hljs-keyword">where</span> ename=<span class="hljs-string">&#x27;SMITH&#x27;</span></code></pre>
<h2 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h2><p>索引就是在表的列上构建一个二叉树，达到大幅度提高查询效率的目的，但是索引影响增删改的效率</p>
<h4 id="3-1单列索引"><a href="#3-1单列索引" class="headerlink" title="3.1单列索引"></a>3.1单列索引</h4><h6 id="3-1-1创建单列索引"><a href="#3-1-1创建单列索引" class="headerlink" title="3.1.1创建单列索引"></a>3.1.1创建单列索引</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> index_ename <span class="hljs-keyword">on</span> emp(ename);</code></pre>

<h6 id="3-1-2触发单列索引"><a href="#3-1-2触发单列索引" class="headerlink" title="3.1.2触发单列索引"></a>3.1.2触发单列索引</h6><p>触发规则是，查询条件必须是索引中的<strong>原始值</strong>,比如模糊查询和单行函数都会影响索引触发；<br>而且在or语句中，如果不包含触发原始值的条件则不触发索引；</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename=<span class="hljs-string">&#x27;SCOTT&#x27;</span>; <span class="hljs-comment">---触发 表中有ename=SCOTT</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename=<span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">---不触发 表中无ename=abc</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename=<span class="hljs-string">&#x27;SCOTT&#x27;</span> <span class="hljs-keyword">or</span> sal=<span class="hljs-number">1000</span>; <span class="hljs-comment">---不触发</span></code></pre>
<h4 id="3-2多列索引"><a href="#3-2多列索引" class="headerlink" title="3.2多列索引"></a>3.2多列索引</h4><h6 id="3-2-1创建多列索引"><a href="#3-2-1创建多列索引" class="headerlink" title="3.2.1创建多列索引"></a>3.2.1创建多列索引</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> index_ename_sal <span class="hljs-keyword">on</span> emp(ename,job);</code></pre>

<h6 id="3-2-1触发多列索引"><a href="#3-2-1触发多列索引" class="headerlink" title="3.2.1触发多列索引"></a>3.2.1触发多列索引</h6><p>优先检索列：索引的第一列<br>触发规则:查询条件必须包含优先检索列中的原始值</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename=<span class="hljs-string">&#x27;SCOTT&#x27;</span> <span class="hljs-keyword">and</span> sal=<span class="hljs-number">1234</span>; <span class="hljs-comment">--触发多列索引</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename=<span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">and</span> sal=<span class="hljs-string">&#x27;asx&#x27;</span>; <span class="hljs-comment">--不触发多列索引  表中无ename=abc</span>
<span class="hljs-comment">--表中既有单列索引又有多列索引时</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename=<span class="hljs-string">&#x27;SCOTT&#x27;</span>;  <span class="hljs-comment">--触发单列索引</span></code></pre>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle的表空间，用户管理，表操作，函数</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/oracle%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4%EF%BC%8C%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%EF%BC%8C%E8%A1%A8%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<p>基于oracle 12c</p>
<h3 id="1-表空间"><a href="#1-表空间" class="headerlink" title="1.表空间"></a>1.表空间</h3><h6 id="1-1-创建表空间"><a href="#1-1-创建表空间" class="headerlink" title="1.1 创建表空间"></a>1.1 创建表空间</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">tablespace</span> uncle
<span class="hljs-keyword">datafile</span> <span class="hljs-string">&#x27;c:\oracle\unclez.dbf&#x27;</span>
<span class="hljs-keyword">size</span> <span class="hljs-number">100</span>m
<span class="hljs-keyword">autoextend</span> <span class="hljs-keyword">on</span>  <span class="hljs-comment">--自动扩容</span>
<span class="hljs-keyword">next</span> <span class="hljs-number">10</span>m; <span class="hljs-comment">--每次扩容10M</span></code></pre>
<h6 id="1-2-删除表空间"><a href="#1-2-删除表空间" class="headerlink" title="1.2 删除表空间"></a>1.2 删除表空间</h6><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">tablespace</span> uncle;</code></pre>
<h3 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h3><h6 id="2-1创建用户"><a href="#2-1创建用户" class="headerlink" title="2.1创建用户"></a>2.1创建用户</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> root
<span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-number">123</span>
<span class="hljs-keyword">default</span> <span class="hljs-keyword">tablespace</span> uncle;</code></pre>
<h6 id="2-2授权"><a href="#2-2授权" class="headerlink" title="2.2授权"></a>2.2授权</h6><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> dba <span class="hljs-keyword">to</span> root;</code></pre>

<p>常用角色：</p>
<ul>
<li>connect:连接角色，基本角色</li>
<li>resource:开发者角色</li>
<li>dba:超级管理员角色</li>
</ul>
<h6 id="2-3解锁用户"><a href="#2-3解锁用户" class="headerlink" title="2.3解锁用户"></a>2.3解锁用户</h6><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> 用户名 <span class="hljs-keyword">account</span> <span class="hljs-keyword">unlock</span>;</code></pre>

<h3 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3.表操作"></a>3.表操作</h3><h6 id="3-1创建、删除表"><a href="#3-1创建、删除表" class="headerlink" title="3.1创建、删除表"></a>3.1创建、删除表</h6><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(
       <span class="hljs-keyword">id</span> <span class="hljs-built_in">number</span>(<span class="hljs-number">10</span>),
       <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">20</span>)
);

<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> 表名</code></pre>
<h6 id="3-2-表结构"><a href="#3-2-表结构" class="headerlink" title="3.2 表结构"></a>3.2 表结构</h6><p>1.添加一列</p>
<pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> (字段名 类型)</code></pre>
<p>2.删除一列</p>
<pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 字段名</code></pre>
<p>3.修改列</p>
<pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">modify</span> 字段名 类型</code></pre>
<p>4.重命名一列</p>
<pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">rename</span> <span class="hljs-keyword">column</span> 字段名 <span class="hljs-keyword">to</span> 新字段名</code></pre>
<h6 id="3-3-CRUD"><a href="#3-3-CRUD" class="headerlink" title="3.3.CRUD"></a>3.3.CRUD</h6><p>事务需要自己手动提交<br>3.1.插入数据</p>
<pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> c<span class="hljs-comment">##user (id,name) values(1,&#x27;uncle&#x27;);</span></code></pre>
<p>3.2.查询数据</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span>* <span class="hljs-keyword">from</span> c<span class="hljs-comment">##user;</span></code></pre>
<p>3.3修改数据</p>
<pre><code class="hljs sql"><span class="hljs-keyword">update</span> c<span class="hljs-comment">##user set sex=&#x27;男&#x27; where id=1;</span></code></pre>
<p>3.4.删除数据</p>
<pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> c<span class="hljs-comment">##user where id=1;</span></code></pre>
<p>3.5重建表</p>
<pre><code class="hljs sql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名</code></pre>
<h6 id="3-4-序列"><a href="#3-4-序列" class="headerlink" title="3.4 序列"></a>3.4 序列</h6><p>3.4.1 创建序列</p>
<pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">sequence</span> user_k;</code></pre>
<p>3.4.2 查询序列</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> user_k.nextval <span class="hljs-keyword">from</span> dual; <span class="hljs-comment">--下一前值,自增</span>
<span class="hljs-keyword">select</span> user_k.currentfrom dual; <span class="hljs-comment">--当前值</span></code></pre>
<p>3.4.2 使用序列</p>
<pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> (<span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span>  (uesr_k.nextval,<span class="hljs-string">&#x27;uncle&#x27;</span>);</code></pre>
<h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h3><h6 id="4-1单行函数"><a href="#4-1单行函数" class="headerlink" title="4.1单行函数"></a>4.1单行函数</h6><p>接收字符输入返回字符或者数值，dual是伪表<br>1.upper、lower<br>大小写转换</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">upper</span>(<span class="hljs-string">&#x27;smith&#x27;</span>) <span class="hljs-keyword">from</span> dual;
<span class="hljs-keyword">select</span> <span class="hljs-keyword">lower</span>(<span class="hljs-string">&#x27;SMITH&#x27;</span>) <span class="hljs-keyword">from</span> dual;</code></pre>
<p>2.四舍五入函数：ROUND()<br>默认情况下ROUND四舍五入取整，可以自己指定保留的位数。<br>参数一是数据，参数二是保留几位</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">round</span>(<span class="hljs-number">51.56</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> dual;</code></pre>
<p>3.获得两个时间段中的月数：MONTHS_BETWEEN() </p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,<span class="hljs-keyword">round</span>(months_between(date1,date2)) <span class="hljs-keyword">from</span> emp;</code></pre>
<p>4.TO_CHAR:字符串转换函数<br>年：y, 年是四位使用yyyy<br>月：m, 月是两位使用mm<br>日：d,  日是两位使用dd </p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> empno,ename,
		   to_char(<span class="hljs-built_in">date</span>,<span class="hljs-string">&#x27;yyyy&#x27;</span>)年,
		   to_char(<span class="hljs-built_in">date</span>,<span class="hljs-string">&#x27;mm&#x27;</span>)月,
		   to_char(<span class="hljs-built_in">date</span>,<span class="hljs-string">&#x27;dd&#x27;</span>)日
<span class="hljs-keyword">from</span> emp;</code></pre>
<p>5.TO_DATE:日期转换函数<br>  TO_DATE可以把字符串的数据转换成日期类型</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">to_date</span>(<span class="hljs-string">&#x27;2019-04-04&#x27;</span>,<span class="hljs-string">&#x27;yyyy-mm-dd&#x27;</span>) <span class="hljs-keyword">from</span> dual;</code></pre>
<p>6.空值处理nvl<br>nvl(值,为NULL时候要赋的值)</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> total_money <span class="hljs-keyword">nav</span>(reward,<span class="hljs-number">0</span>)+money <span class="hljs-keyword">from</span> emp;</code></pre>
<p>7.条件函数case when </p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> sal ,
       sal ,
       <span class="hljs-keyword">case</span>
         <span class="hljs-keyword">when</span> sal&lt;<span class="hljs-number">1500</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;低工资&#x27;</span>
           <span class="hljs-keyword">when</span> sal&gt;<span class="hljs-number">2500</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;高工资&#x27;</span>
             <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;中等工资&#x27;</span>
               <span class="hljs-keyword">end</span>
<span class="hljs-keyword">from</span> emp t;</code></pre>
<h6 id="4-2多行函数"><a href="#4-2多行函数" class="headerlink" title="4.2多行函数"></a>4.2多行函数</h6><p>1.统计记录数 count()<br>2.最小值查询 min()<br>3.最大值查询 max()<br>4.查询平均值 avg()<br>5.求和函数 sum() </p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox下win7安装oracle12c问题解决</title>
    <url>/%E9%97%AE%E9%A2%98%E6%95%99%E7%A8%8B/VirtualBox%E4%B8%8Bwin7%E5%AE%89%E8%A3%85oracle12c%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
    <content><![CDATA[<h2 id="一、主机无法ping通虚拟机"><a href="#一、主机无法ping通虚拟机" class="headerlink" title="一、主机无法ping通虚拟机"></a>一、主机无法ping通虚拟机</h2><h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h4><p>选择了NAT模式后，查看ipconfig只能看到一个10.0.2.15的地址，放到主机上，ping不通。但是虚拟机能连接网络</p>
<h4 id="host-only模式"><a href="#host-only模式" class="headerlink" title="host-only模式"></a>host-only模式</h4><p>设置后，虚拟机无法上网，关闭虚拟机和主机防火墙后可以互ping，我用的这种，但是因为数据库使用只要主机连接虚拟机就行了，所以我还是把主机防火墙打开了。</p>
<h2 id="二、连接时显示No-Lisenter"><a href="#二、连接时显示No-Lisenter" class="headerlink" title="二、连接时显示No Lisenter"></a>二、连接时显示No Lisenter</h2><p>原因：未配置oracle的lisener，监听主机，找到C:\app\oracle\product\12.2.0\dbhome_1\network\admin\listener.asr</p>
<p><img src="https://img-blog.csdnimg.cn/20190403222229745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190403222229745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br><strong>编辑listener.ora改host为0.0.0.0</strong></p>
<pre><code class="hljs java"># listener.ora Network Configuration File: C:\app\oracle\product\12.2.0\dbhome_1\network\admin\listener.ora
# Generated by Oracle configuration tools.

SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (SID_NAME = CLRExtProc)
      (ORACLE_HOME = C:\app\oracle\product\<span class="hljs-number">12.2</span>.<span class="hljs-number">0</span>\dbhome_1)
      (PROGRAM = extproc)
      (ENVS = <span class="hljs-string">&quot;EXTPROC_DLLS=ONLY:C:\app\oracle\product\12.2.0\dbhome_1\bin\oraclr12.dll&quot;</span>)
    )
  )

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>)(PORT = <span class="hljs-number">1521</span>))
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
    )
  )

</code></pre>

<h2 id="三、sqlplus在cmd下连接时中文乱码"><a href="#三、sqlplus在cmd下连接时中文乱码" class="headerlink" title="三、sqlplus在cmd下连接时中文乱码"></a>三、sqlplus在cmd下连接时中文乱码</h2><p>连接上orcle，输入</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> userenv(<span class="hljs-string">&#x27;language&#x27;</span>) <span class="hljs-keyword">from</span> dual;</code></pre>
<p>查询编码集，如果是  SIMPLIFIED CHINESE_CHINA.AL32UTF8<br>那么在环境变量里面添加NLS_LANG值就是你查出来的值<br><img src="https://img-blog.csdnimg.cn/20190403224525163.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190403224525163.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>这时重新打开cmd，如果还是乱码，那么就退出连接（Ctrl +c）;然后<br>如果你查出来的时UTF-8编码的就在连接前输入CHCP 65001;然后连接数据库<br>如果是GBK就输入CHCP 936；然后连接就没乱码了</p>
<h2 id="四、创建用户要带C"><a href="#四、创建用户要带C" class="headerlink" title="四、创建用户要带C##"></a>四、创建用户要带C##</h2><p>安装时不勾选此项<br><img src="https://img-blog.csdnimg.cn/20190404210252229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190404210252229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>问题教程</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>步道乐跑位置模拟刷步数</title>
    <url>/%E7%8E%A9%E6%9C%BA/%E6%9D%82%E8%AE%B0/%E6%AD%A5%E9%81%93%E4%B9%90%E8%B7%91%E4%BD%8D%E7%BD%AE%E6%A8%A1%E6%8B%9F%E5%88%B7%E6%AD%A5%E6%95%B0.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为学校突然来了个需要跑步打卡，每学期要跑60多次，宅男心塞，所以就想着弄个位置模拟器来代劳了</p>
<h2 id="需要工具"><a href="#需要工具" class="headerlink" title="需要工具"></a>需要工具</h2><p>Fake Location<br>root的安卓手机一部<br>步道乐跑软件</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-过检测"><a href="#1-过检测" class="headerlink" title="1.过检测"></a>1.过检测</h3><p>打开Fake location授予它root权限,<br>左边侧滑有个反检测，进入点 “〉”这个符号，点那个Fake location软件一栏点击“√”然后返回<br>出来后你可以看到一个“+”号，点击找到步道乐跑，然后点√，返回，<br>开启反检测，主界面右上角有个“…”点击后进入setting找到增强反检测，点击，增强隐藏root，返回后，<br>侧滑找到一个“root隐藏”点击加号，选择步道乐跑，点击√</p>
<h3 id="2-模拟位置"><a href="#2-模拟位置" class="headerlink" title="2.模拟位置"></a>2.模拟位置</h3><p>在Fake Location里面定位到自己开始跑步的位置，然后开启摇杆，这个悬浮窗权限要开，然后点击开始模拟，进入步道乐跑，开始跑步，然后返回到Fake Location，打开地图，选择<br><img src="https://img-blog.csdnimg.cn/20190330163244804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_4,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190330163244804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_4,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>调整为真实地图，定位会在你选择的位置出现，<img src="https://img-blog.csdnimg.cn/20190330163535768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_4,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190330163535768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_4,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>操作摇杆开始在操场上跑圈圈，记得位置设置为跑步，步长3、4/s差不多；跑完几圈差不多了，我们是2公里，所以5圈；</p>
<h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p><img src="https://img-blog.csdnimg.cn/20190330163928150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190330163928150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果觉得每次都得手动控制跑步麻烦，浪费时间，可以设置路线模拟，释放双手，用法简单，自己看看就会了；</p>
]]></content>
      <categories>
        <category>玩机</category>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>步道乐跑</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言成员变量--栈与堆</title>
    <url>/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E6%A0%88%E4%B8%8E%E5%A0%86.html</url>
    <content><![CDATA[<h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><p>最近学数据结构打算重新学一遍c语言，c语言函数返回值不像是java一样，java在定义一个成员变量后给其赋值，直接返回还是能拿到他的值，c却不一样了，成员变量放在栈内存中，栈内存中的成员变量会在方法执行后会释放，所以在成员变量赋值后返回是拿不到数据的</p>
<h2 id="二、栈中的成员变量"><a href="#二、栈中的成员变量" class="headerlink" title="二、栈中的成员变量"></a>二、栈中的成员变量</h2><h4 id="1-不能取得值1"><a href="#1-不能取得值1" class="headerlink" title="1.不能取得值1"></a>1.不能取得值1</h4><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p>看看这个例子：</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">testJB</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> a=<span class="hljs-string">&#x27;H&#x27;</span>;
	<span class="hljs-keyword">return</span> &amp;a;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> p=testJB();
	<span class="hljs-built_in">putchar</span>(p);
&#125;</code></pre>
<p>这个打印的时候你会发现没看到想要的’H’</p>
<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>当testJB执行完成后，a执行的栈内存区域将自动被释放，这时候再返回a的地址已经拿不到数据了</p>
<h4 id="2-不能取得值2"><a href="#2-不能取得值2" class="headerlink" title="2.不能取得值2"></a>2.不能取得值2</h4><h6 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h6><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">test</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> arr[]=<span class="hljs-string">&quot;hello world&quot;</span>;
	<span class="hljs-keyword">return</span> arr;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> *p=test();
	<span class="hljs-built_in">puts</span>(p);
&#125;</code></pre>
<p>运行结果：乱码输出；</p>
<h6 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h6><pre><code class="hljs c"><span class="hljs-keyword">char</span> arr[]=<span class="hljs-string">&quot;hello world&quot;</span>;</code></pre>
<p>内存过程:<br>首先将“hello world” 放入常量区，然后再把其重常量区拷贝到arr的栈内存中，函数执行完成后，arr的栈内存被自动释放，返回的arr首地址也拿不到数据了；</p>
<h2 id="二、堆内存"><a href="#二、堆内存" class="headerlink" title="二、堆内存"></a>二、堆内存</h2><h4 id="1-可以取得值1"><a href="#1-可以取得值1" class="headerlink" title="1.可以取得值1"></a>1.可以取得值1</h4><h6 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h6><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">test</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)*<span class="hljs-number">10</span>);
	*p = <span class="hljs-string">&quot;hello word&quot;</span>;
	<span class="hljs-keyword">return</span> p;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">char</span> *p=test();
	<span class="hljs-built_in">puts</span>(p);
	<span class="hljs-built_in">free</span>(p);
&#125;</code></pre>
<p>运行结果:hello word；</p>
<h6 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h6><p>malloc 函数是在<strong>堆内存</strong>中开辟一块空间，并且不会自动释放,需要用完后手动释放；<br>因此，当函数执行完成后，堆内存不被释放，返回首地址仍然可以取得数据，注意用完后手动释放；</p>
<h4 id="2-不可取得值1"><a href="#2-不可取得值1" class="headerlink" title="2.不可取得值1"></a>2.不可取得值1</h4><h6 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h6><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *num)</span></span>
<span class="hljs-function"></span>&#123;
	num = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * <span class="hljs-number">10</span>);
	num=<span class="hljs-string">&quot;hello word&quot;</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> *p=<span class="hljs-literal">NULL</span>;
	testCY(p);
	<span class="hljs-built_in">puts</span>(p);
&#125;</code></pre>
<p>运行结果：报错；</p>
<h6 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h6><p>test函数中的num指针和main函数中的p指针不是同一个指针,因为形参也可以看作成员变量；在test函数开辟的空间是给num指针开辟的，而不是给p指针开辟的，这时候的p指针一直为NULL；所以这时候报错；</p>
<h4 id="3-可以取得值2"><a href="#3-可以取得值2" class="headerlink" title="3.可以取得值2"></a>3.可以取得值2</h4><h6 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h6><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCY</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **num)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> *tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);
	<span class="hljs-built_in">memset</span>(tmp,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);
	<span class="hljs-built_in">strcpy</span>(tmp,<span class="hljs-string">&quot;hello word&quot;</span>);
	*num = tmp;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> *p=<span class="hljs-literal">NULL</span>;
	testCY(&amp;p);
	<span class="hljs-built_in">puts</span>(p);
	<span class="hljs-built_in">free</span>(p);
&#125;</code></pre>
<p>运行结果：hello word</p>
<h6 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h6><p>首先将二级指针num的值赋值为一级指针p的地址值，再创建临时指针tmp，在堆中开辟一块空间,tmp指针指向这块内存，将“hello world”从常量区拷贝到这块内存，再将一级指针p指向tmp指向的地址，这样在函数结束后，二级指针num、一级指针tmp会被销毁，但是一级指针p已经指向了开辟的堆内存；</p>
<p>优化：不需要tmp也可以做到，用<em>num代替</em>tmp；</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言笔记</title>
    <url>/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="一、常用字符串处理函数"><a href="#一、常用字符串处理函数" class="headerlink" title="一、常用字符串处理函数"></a>一、常用字符串处理函数</h2><h4 id="1-读入字符"><a href="#1-读入字符" class="headerlink" title="1.读入字符"></a>1.读入字符</h4><p>fgets(字符指针，大小，输入流)； 可以读入文件<br>gets(字符指针，大小) ；控制台读入</p>
<h4 id="2-输出字符"><a href="#2-输出字符" class="headerlink" title="2.输出字符"></a>2.输出字符</h4><p>fputs(字符指针，大小，输出流); 可以输入到文件<br>puts（字符指针）；控制台输出</p>
<h4 id="3-字符操作"><a href="#3-字符操作" class="headerlink" title="3.字符操作"></a>3.字符操作</h4><p>strlen(字符指针)； 字符有效长度（\0结束）<br>sizeof(字符指针)；字符真实长度；<br>strcpy(目标字符指针,源字符指针)；字符串拷贝<br>strncpy(目标字符指针,源字符指针,拷贝长度)；字符串拷贝<br>strcat(char *a1,char *a2);字符拼接，后会加\0<br>strncat(char *a1,char *a2,int len);同上<br>strcmp(char *a1,char *a2) 字符串比较，比较ASCLL，返回a1与a2的ASCLL差值<br>strcmp(char *a1,char *a2,int len) 字符串比较，比较ASCLL，返回a1与a2的ASCLL差值<br>strchr(char *a,int index);查找字符，找到返回其地址，否则null<br>strstr(char *src,char *find); 在src中查找find字符串，找到返回其地址，否则null<br>strtok(char *str,char c);字符串分割，以c来分割字符串str<br>eg:</p>
<pre><code class="hljs c"><span class="hljs-keyword">char</span> arr[] = <span class="hljs-string">&quot;www.unclezs.com&quot;</span>;
<span class="hljs-keyword">char</span> *p = strtok(arr,<span class="hljs-string">&quot;.&quot;</span>);
<span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)
&#123;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);
	p = strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;.&quot;</span>);
&#125;</code></pre>

<h4 id="4-格式化输入输出"><a href="#4-格式化输入输出" class="headerlink" title="4.格式化输入输出"></a>4.格式化输入输出</h4><p>sprintf(char <em>c,”%d+%d”,a,b);读入a,b,的值格式化后存入c<br>*</em>eg:** </p>
<pre><code class="hljs c"><span class="hljs-built_in">sprintf</span>(arr, <span class="hljs-string">&quot;%d+%d=%d&quot;</span>,a,b,a+b);
<span class="hljs-comment">//打印arr输出10+20=30</span></code></pre>
<p>sscanf(arr, “%d+%d=”,&amp;a,&amp;b);根据arr的字符串格式化读出字符；<br><strong>eg：</strong> </p>
<pre><code class="hljs c">   <span class="hljs-keyword">char</span> arr[<span class="hljs-number">100</span>]=“<span class="hljs-number">100</span>+<span class="hljs-number">200</span>=”;
<span class="hljs-keyword">int</span> a, b;
<span class="hljs-built_in">sscanf</span>(arr, <span class="hljs-string">&quot;%d+%d=&quot;</span>,&amp;a,&amp;b);
<span class="hljs-comment">//打印a,b输出100，200</span></code></pre>
<h4 id="5-字符串转换类型"><a href="#5-字符串转换类型" class="headerlink" title="5.字符串转换类型"></a>5.字符串转换类型</h4><p>atoi转换成int<br>atol 转换成long<br>atof 转换成float、double</p>
<h2 id="二、内存操作函数"><a href="#二、内存操作函数" class="headerlink" title="二、内存操作函数"></a>二、内存操作函数</h2><h6 id="注意：成员变量的栈区内存会被用完后自动释放，堆区则不会"><a href="#注意：成员变量的栈区内存会被用完后自动释放，堆区则不会" class="headerlink" title="注意：成员变量的栈区内存会被用完后自动释放，堆区则不会"></a>注意：成员变量的栈区内存会被用完后自动释放，堆区则不会</h6><h4 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1.malloc"></a>1.malloc</h4><p>在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域<br>格式：malloc(分配大小)</p>
<h4 id="2-strcopy-拷贝"><a href="#2-strcopy-拷贝" class="headerlink" title="2.strcopy 拷贝"></a>2.strcopy 拷贝</h4><p>strcopy操作对空间，会将拷贝的字符串全都放到堆空间中，这样就会导致超出堆空间 使程序出现错误；</p>
<h4 id="3-memset重置"><a href="#3-memset重置" class="headerlink" title="3.memset重置"></a>3.memset重置</h4><p>  memset(<em>src,</em>des, int len)<br>  参数：目标  值  字节大小</p>
<h4 id="4-memcpy拷贝"><a href="#4-memcpy拷贝" class="headerlink" title="4.memcpy拷贝"></a>4.memcpy拷贝</h4><p>  拷贝src所指的内存内容的前n个字节到dest所值的内存地址上<br>  可以从栈区拷贝到堆区  也可以从堆区拷贝到栈区<br>  注意：源地址与目标地址不能发生重叠<br><strong>strcpy 与mencpy的不同:</strong><br>①函数参数不同<br>②strcpy拷贝字符串  memcpy 可以拷贝一块内存<br>③strcpy与memcpy拷贝结束标志不同</p>
<h4 id="5-memmove"><a href="#5-memmove" class="headerlink" title="5.memmove"></a>5.memmove</h4><p>功能用法和memcpy()一样，<br>区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比memcpy()低些。</p>
<h4 id="6-memcmp"><a href="#6-memcmp" class="headerlink" title="6.memcmp"></a>6.memcmp</h4><p>比较s1和s2所指向内存区域的前n个字节,类型不同，但在内存中存的ASCII码相同，比较的内容相同<br>注意：不限类型比对</p>
<h4 id="7-free"><a href="#7-free" class="headerlink" title="7.free"></a>7.free</h4><p>释放内存</p>
<h4 id="8-realloc-重新申请内存"><a href="#8-realloc-重新申请内存" class="headerlink" title="8.realloc 重新申请内存"></a>8.realloc 重新申请内存</h4><p>realloc(<em>p,size);在原有地址上重新申请内存，当</em>p传入NULL时候和malloc功能一致</p>
<h4 id="9-calloc"><a href="#9-calloc" class="headerlink" title="9.calloc"></a>9.calloc</h4><p>calloc(几块，一块的大小)；按照快来分配内存空间，且会自动初始化为0</p>
<h2 id="三、结构体"><a href="#三、结构体" class="headerlink" title="三、结构体"></a>三、结构体</h2><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span></span>
<span class="hljs-class">&#123;</span>
	<span class="hljs-keyword">char</span> *name;
	<span class="hljs-keyword">int</span> age;
	<span class="hljs-keyword">char</span> *gender;
	<span class="hljs-keyword">char</span>* tel;
&#125;stus;
<span class="hljs-comment">/*结构体*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">strtuctTest</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-comment">//赋值方式一</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">stu1</span> = &#123;</span> <span class="hljs-string">&quot;uncle&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;15023814323&quot;</span>&#125;;

	<span class="hljs-comment">//方式二</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">stu2</span> = &#123;</span> .name=<span class="hljs-string">&quot;uncle&quot;</span>,.age=<span class="hljs-number">19</span>,.gender=<span class="hljs-string">&quot;男&quot;</span>,.tel=<span class="hljs-string">&quot;15023814323&quot;</span> &#125;;

	<span class="hljs-comment">//方式3</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">stu</span>;</span>
	stu.age = <span class="hljs-number">19</span>;
	stu.gender = <span class="hljs-string">&quot;男&quot;</span>;
	stu.name = <span class="hljs-string">&quot;unclezs&quot;</span>;
	stu.tel = <span class="hljs-string">&quot;15023814323&quot;</span>;
	<span class="hljs-comment">//strcpy(stu.tel,&quot;85&quot;);数组需这样赋值</span>

	<span class="hljs-comment">//指针操作结构体</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">stu</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">student</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">stus</span>));</span>
	stu-&gt;name = <span class="hljs-string">&quot;unclezs&quot;</span>;
	stu-&gt;age = <span class="hljs-number">19</span>;
	stu-&gt;gender = <span class="hljs-string">&quot;男&quot;</span>;
	stu-&gt;tel = <span class="hljs-string">&quot;133337000&quot;</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;姓名%s\n年龄:%d\n性别:%s\n电话号码:%s\n&quot;</span>,stu-&gt;name,stu-&gt;age,stu-&gt;gender,stu-&gt;tel);
	<span class="hljs-built_in">free</span>(stu);
&#125;</code></pre>

<h2 id="四、IO"><a href="#四、IO" class="headerlink" title="四、IO"></a>四、IO</h2><h4 id="1、输入流"><a href="#1、输入流" class="headerlink" title="1、输入流"></a>1、输入流</h4><p>fgets(char <em>src,len,</em>file);读字符串<br>fgetc(<em>file);读一个字符<br>fread(</em>src,len,number,<em>file);读文件，以二进制<br>fscanf(</em>file,*des,&amp;a,&amp;b);文件格式化读取，和sscanf差不多</p>
<h4 id="2、输出流"><a href="#2、输出流" class="headerlink" title="2、输出流"></a>2、输出流</h4><p>fputs(char<em>,</em>file)<br>fputc(char,<em>file)<br>fwrite(char *)<br>fprintf(char</em>,*file);文件格式化输出，和sprintf差不多</p>
<h4 id="3、文件指针"><a href="#3、文件指针" class="headerlink" title="3、文件指针"></a>3、文件指针</h4><p>rewind(<em>file);重置文件指针<br>ftell(</em>fiel):  获取光标当前为位置  返回值是long类型 -1代表失败<br>fseek(<em>file,move_count,*</em>mode<strong>);<br>**mode:</strong><br>SEEK_SET:开始位置移动<br>SEEK_END:结束位置移动<br>SEEK_CUR:当前位置移动</p>
<h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h4><p>feof    判断文件流是否到结尾， eof判断字符是否到结尾<br>fclose(<em>file):关闭文件流<br>fflush(</em>file);文件缓冲区更新<br>remove(<em>path);删除文件<br>rename(</em>oldParh,*newPath);重命名</p>
<h4 id="五、细节知识"><a href="#五、细节知识" class="headerlink" title="五、细节知识"></a>五、细节知识</h4><h6 id="全局const和局部const区别"><a href="#全局const和局部const区别" class="headerlink" title="全局const和局部const区别"></a>全局const和局部const区别</h6><p>全局常量：<strong>不能</strong>直接修改，指针操作地址也<strong>不能</strong>修改<br>局部常量：<strong>不能</strong>直接修改，指针操作地址<strong>能</strong>修改;</p>
<h6 id="static和extern区别"><a href="#static和extern区别" class="headerlink" title="static和extern区别"></a>static和extern区别</h6><p>static:<br>全局：其修饰的变量函数，都只能在本个文件中使用，且全局使用，在运行区都有效；<br>局部：其修饰的变量函数，仅限函数内，在运行区都有效；<br>extern:<br>局部：只能在本文件中使用<br>全局：所有文件都能使用；</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本操作指令记录</title>
    <url>/linux/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h2 id="Linux常用命令集合"><a href="#Linux常用命令集合" class="headerlink" title="Linux常用命令集合"></a>Linux常用命令集合</h2><h4 id="1-man-查看指令帮助"><a href="#1-man-查看指令帮助" class="headerlink" title="1.man 查看指令帮助"></a>1.man 查看指令帮助</h4><p>  和- -help差不多</p>
<h4 id="2-ls当前目录列出文件名字"><a href="#2-ls当前目录列出文件名字" class="headerlink" title="2.ls当前目录列出文件名字"></a>2.ls当前目录列出文件名字</h4><p><strong>参数：</strong><br>-h: 以KB、M等来显示文件目录大小<br>-l: 以列表形式显示文件目录<br>-a:显示目录    及隐藏目录</p>
<h4 id="3-cd-【切换工作目录】"><a href="#3-cd-【切换工作目录】" class="headerlink" title="3.cd 【切换工作目录】"></a>3.cd 【切换工作目录】</h4><p><strong>格式：</strong><br>cd 目录<br>cd 切换到用户主目录<br>cd ~ 切换到当前用户的主目录<br>cd .. 切换到上级目录<br>cd .  切换到当前目录<br>cd -  切换到上一次目录</p>
<h4 id="4-mkdir-创建目录"><a href="#4-mkdir-创建目录" class="headerlink" title="4.mkdir 创建目录"></a>4.mkdir 创建目录</h4><p>mkdir 目录名 -p 递归创建<br>rmdir 目录名  目录一定是空的<br>rm 文件  -i询问 -r 递归删除</p>
<h4 id="5-ln-链接"><a href="#5-ln-链接" class="headerlink" title="5.ln 链接"></a>5.ln 链接</h4><p><strong>格式：</strong><br>ln 源文件 链接文件 硬链接<br>ln -s 源文件 链接文件 软连接<br>硬链接文件占磁盘空间 但是删除源文件不会影响硬链接文件<br>软链接文件不占磁盘空间 但是删除源文件会影响软链接文件</p>
<h4 id="6-grep-文本搜索"><a href="#6-grep-文本搜索" class="headerlink" title="6.grep 文本搜索"></a>6.grep 文本搜索</h4><p><strong>格式：</strong><br>grep  ‘搜索内容’ 文件名<br><strong>参数：</strong><br>-n 显示行号<br>-v 反选<br>-i 忽略大小写</p>
<h4 id="7-find-文件搜索"><a href="#7-find-文件搜索" class="headerlink" title="7.find 文件搜索"></a>7.find 文件搜索</h4><p><strong>格式：</strong><br>find 目录 参数 文件名（可以使用通配符）<br><strong>参数：</strong><br>-name 文件名（通配符支持）<br>-size 大小          eg:-size +2M -size  -5M (大于2M小于5M的)<br>-perm rwx          eg:-perm 777</p>
<h4 id="9-tar-归档-未压缩"><a href="#9-tar-归档-未压缩" class="headerlink" title="9.tar 归档(未压缩)"></a>9.tar 归档(未压缩)</h4><p><strong>归档：</strong> tar -cvf 归档文件名.tar 文件1 文件2  目录1 目录2<br><strong>解归档：</strong> tar -xvf 归档文件名.tar  -C 路径<br><strong>一步归档压缩：</strong> tar -czvf 文件名.tar.gz 文件1 文件2 目录1 目录2<br><strong>一步解归档压缩：</strong> tar -xzvf 文件名.tar.gz -C 路径</p>
<h4 id="10-gzip、bzip2、zip-压缩、解压缩"><a href="#10-gzip、bzip2、zip-压缩、解压缩" class="headerlink" title="10.gzip、bzip2、zip  压缩、解压缩"></a>10.gzip、bzip2、zip  压缩、解压缩</h4><p><strong>gzip压缩：</strong><br>gzip 归档文件名.tar  生成了一个文件 归档文件名.tar.gz 文件大小小于归档文件大小 归档文件名.tar不存在了<br><strong>gzip解压缩：</strong><br>gzip -d 归档文件名.tar.gz 生成了一个文件 归档文件名.tar<br><strong>bzip2压缩：</strong><br>tar -cjvf 文件名.tar.bz2 文件1 文件2 目录1 目录2<br><strong>bzip2解压缩：</strong><br>tar -xjvf 文件名.tar.bz2 -C 路径<br><strong>zip压缩：</strong><br>zip 文件名 文件1 文件2 目录1 目录2  生成一个文件为：文件名.zip<br><strong>unzip解压缩：</strong><br>unzip 文件名.zip -C 路径</p>
<h4 id="11-su-用户权限："><a href="#11-su-用户权限：" class="headerlink" title="11.su 用户权限："></a>11.su 用户权限：</h4><p>su 切换用户账户<br><strong>格式：</strong><br>【su 用户名 】<br>【su】 切换到root<br>【su root】 切换到root<br>【su -】 切换到root用户 同时切换到root目录</p>
<h4 id="12-用户管理"><a href="#12-用户管理" class="headerlink" title="12.用户管理"></a>12.用户管理</h4><ul>
<li>添加组：<br>【groupadd 组名】  添加组  需要用户权限</li>
<li>删除组<br>【groupdel 组名】  删除组  需要用户权限和清空组成员</li>
<li>修改用户所在组：<br>【usermod -g 组名 用户名1 用户名2】需要用户权限</li>
<li>添加用户：<br>【useradd -d /home/目录 用户名 -g 组名 -m】新建用户 设置用户主目录和设置组名 并自动创建  需要用户权限</li>
<li>设置密码：<br>【passwd 用户名】设置密码 需要用户权限</li>
<li>删除用户：<br>【userdel -r 用户名】 删除用户递归删除该用户所有文件 需要用户权限</li>
</ul>
<h4 id="13-chmod-修改文件权限"><a href="#13-chmod-修改文件权限" class="headerlink" title="13.chmod 修改文件权限"></a>13.chmod 修改文件权限</h4><p>字符法格式：【chmod -u|g|o|a +|- rwc 文件1 文件2】<br><strong>参数：</strong></p>
<ul>
<li>d rwx r-x r-x</li>
<li>u user +|- rwx</li>
<li>g group +|- rwx</li>
<li>o other +|- rwx</li>
<li>a all +|- rwx</li>
</ul>
<p><strong>文件权限数字：</strong><br>rwx rwx rwx<br>421 421 421</p>
<h4 id="14-vi-文本编辑器"><a href="#14-vi-文本编辑器" class="headerlink" title="14.vi 文本编辑器"></a>14.vi 文本编辑器</h4><p>VI编辑器有两个模式：文本编辑模式 命令行处理模式<br><strong>进入编辑器</strong>：<br>1、vi 文件名  2、vim<br>操作编辑器：<br>【i】在光标当前位置插入<br>【a】在光标右侧位置插入<br>【o】在光标下一行位置开启新的一行插入<br>【O】在光标上一行位置开启新的一行插入<br>【I】在光标当前行行首插入<br>【A】在光标当前行行尾插入</p>
<p><strong>退出编辑器：</strong><br>【ZZ】保存退出<br>【:wq】保存退出<br>【:x】保存退出<br>【:w 文件名】保存到指定文件中<br>【:q】 保存退出 针对未修改的文件 注意：未保存文件会提示 无法退出<br>【:q!】 强制退出  退出 不保存<br>【:! 命令】暂时离开vi 执行其他命令<br><strong>编辑器操作：</strong><br>【[n]x】删除光标位置后面n个字符<br>【[n]X】删除光标位置前面n个字符<br>【D】删除光标所在位置后面到行尾的所有字符<br>【[n]dd】删除光标所在行及下面n行   剪切<br>【p】在光标下一行粘贴<br>【[n]yy】复制光标所在行及下面n行<br>【dG】删除光标所在行到文件结尾<br>【J】合并光标所在行和下一行 中间用空格连接<br>【.】执行上一次命令行操作<br>【u】撤销</p>
<p><strong>编辑器定位：</strong><br>【ctrl+b】回滚 行号减小<br>【ctrl+f】前滚 行号增加<br>【gg】定位在文件第一行行首<br>【G】定位在文件最后一行行首<br>【:$】定位在文件最后一行行首<br>【[n]G | [n]gg】定位在m行<br>注意：在查找一些特殊含义的字符时，需要加上转义字符<br>【/内容】查找<br>【n】查找下一个<br>【N】查找上一个<br>【?】查找上一次的所搜内容<br>【/^word】 查找以word开头的内容<br>【/word$】 查找以word结尾的内容<br>【/.】查找任意一个字符<br>【/*】查找任意多个字符</p>
<p><strong>编辑器替换：</strong><br>【r】替换光标所在位置的字符<br>【:r 文件名】在光标当前行的下一行插入一个文件 每次添加只能添加一个文件<br>【: s/a/b/g】将光标所在行的a替换为b<br>【:g/a/s//b/g】将文件中所有a替换为b<br>【:n1,n2s/a/b/g】将行区间n1到n2的行中所有的a替换为b</p>
<p><strong>编辑器设置：</strong><br>【:set ic】搜索时不区分大小写<br>【:set noic】搜索时区分大小写</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>NetKeeper批处理一键开启热点</title>
    <url>/%E7%8E%A9%E6%9C%BA/%E6%9D%82%E8%AE%B0/NetKeeper%E6%89%B9%E5%A4%84%E7%90%86%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AF%E7%83%AD%E7%82%B9.html</url>
    <content><![CDATA[<h1 id="Netkeeper（创意）"><a href="#Netkeeper（创意）" class="headerlink" title="Netkeeper（创意）"></a>Netkeeper（创意）</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>因为寝室网速比较慢，一个追求网速的我实在受不了，就办了个学校的50M的宽带，结果发现居然不能开热点。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p><strong>netkeeper 、 360随身wifi（其他热点工具应该通用）</strong></p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>不能开热点这我就受不了了啊，打开万能的goole，搜索了一下，说杀死netkeeper后台进程就可以绕过netkeeper的检测热点软件，而且不会断网，我就打开任务管理器试了一下，发现真的还行，不过好景不长，一会就断网了。后面才发现需要结束进程树，试了试，还真的可以，不断网了。</p>
<h3 id="一键化"><a href="#一键化" class="headerlink" title="一键化"></a>一键化</h3><p>每次开机都需要这么操作一次，这是真的麻烦啊，所以我就想着，这个能不能一键化，想着就开始干吧，我就用到了平时没事的时候学的点批处理。<br>1、首先杀死netkeeper进程树<br><code>taskkill /im NK.exe /f /t</code><br>2、检测热点软件是否打开，打开则关闭<br><code>taskkill /im 360AP.exe /f /t</code><br>3、打开热点软件（我是用的快捷方式，可以试试exe可执行文件）<br><code>cd C:\Users\uncle\Desktop
360WIFI.lnk</code></p>
<p>以上的根据自己的文件路径改就行</p>
<p>贴下我的完整的</p>
<pre><code class="hljs plain">@echo off
&gt;nul 2&gt;&amp;1 &quot;%SYSTEMROOT%\system32\cacls.exe&quot; &quot;%SYSTEMROOT%\system32\config\system&quot;
if &#39;%errorlevel%&#39; NEQ &#39;0&#39; (
goto UACPrompt
) else ( goto gotAdmin )
:UACPrompt
echo Set UAC &#x3D; CreateObject^(&quot;Shell.Application&quot;^) &gt; &quot;%temp%\getadmin.vbs&quot;
echo UAC.ShellExecute &quot;%~s0&quot;, &quot;&quot;, &quot;&quot;, &quot;runas&quot;, 1 &gt;&gt; &quot;%temp%\getadmin.vbs&quot;
&quot;%temp%\getadmin.vbs&quot;
exit &#x2F;B
:gotAdmin
if exist &quot;%temp%\getadmin.vbs&quot; ( del &quot;%temp%\getadmin.vbs&quot; )
pushd &quot;%CD%&quot;
CD &#x2F;D &quot;%~dp0&quot;
title OneLine NKiller
taskkill &#x2F;im NK.exe &#x2F;f &#x2F;t
taskkill &#x2F;im unclez.exe &#x2F;f &#x2F;t
cd C:\Users\uncle\Desktop
360WIFI.lnk
:: taskkill 结束进程的DOS命令;
:: &#x2F;im 指通过指定进程名方式结束进程，后面紧跟进程名，如 NK.exe；
:: &#x2F;f 强制终止；&#x2F;t 结束进程树。</code></pre>

<p>复制代码到文本改自己的路径，然后改后缀为bat，每次开机netkeeper连接上后，直接执行bat文件<br>即可开启热点。方便快捷。</p>
<h1 id="最新解决方案（当前使用中）"><a href="#最新解决方案（当前使用中）" class="headerlink" title="最新解决方案（当前使用中）"></a>最新解决方案（当前使用中）</h1><p>这个方案比较简单，是最近在吾爱破解上面看到个热点开启软件。就是调用Win10的系统API开启了系统自带的热点 经我测试不会断网<br>原文链接：<a href="https://www.52pojie.cn/thread-1129624-1-1.html">点击前往</a></p>
<p>使用步骤很简单 就是链接netkeeper然后打开这个软件输入热点账号密码，点击开启热点然后关闭软件就可以了。是不是很简单，不用什么结束什么进程之类的了。</p>
<pre><code class="hljs bat">%<span class="hljs-number">1</span> mshta vbscript:CreateObject(&quot;Shell.Application&quot;).ShellExecute(&quot;<span class="hljs-built_in">cmd</span>.exe&quot;,&quot;/c %~s0 ::&quot;,&quot;&quot;,&quot;runas&quot;,<span class="hljs-number">1</span>)(window.close)&amp;&amp;<span class="hljs-keyword">exit</span>
<span class="hljs-built_in">taskkill</span> /F /IM NK.exe
<span class="hljs-function">E:</span>
<span class="hljs-function"><span class="hljs-title">cd</span> <span class="hljs-title">E</span>:\<span class="hljs-title">Program</span> <span class="hljs-title">Files</span>\<span class="hljs-title">NetKeeper</span></span>
<span class="hljs-function"><span class="hljs-title">rd</span> /<span class="hljs-title">s</span> /<span class="hljs-title">q</span>  <span class="hljs-title">run</span>/</span>
<span class="hljs-function"><span class="hljs-title">exit</span></span></code></pre>

<p><strong>对了仅支持win10</strong></p>
<p>软件地址：可以去论坛直接下载，也可以关注公众号【书虫无书荒】回复【热点软件】获取下载链接。</p>
]]></content>
      <categories>
        <category>玩机</category>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用指令集</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySql%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%9B%86.html</url>
    <content><![CDATA[<h2 id="1、创建（Create）"><a href="#1、创建（Create）" class="headerlink" title="1、创建（Create）"></a>1、创建（Create）</h2><h4 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h4><pre><code class="hljs sql">- <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> <span class="hljs-keyword">name</span>; 创建数据库
- <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> gbk; 指定编码创建数据库</code></pre>

<hr>
<h4 id="2-数据表"><a href="#2-数据表" class="headerlink" title="2.数据表"></a>2.数据表</h4><pre><code class="hljs sql">- <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> tablename(<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>) primary <span class="hljs-keyword">key</span> auto_increment,<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) ,age <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>)); 创建表
- <span class="hljs-keyword">create</span> tablename <span class="hljs-keyword">like</span> tablename2；复制表
- <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名 （列名<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span>） <span class="hljs-keyword">values</span> (值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>); 插入数据</code></pre>
<hr>
<h2 id="2、查询-Retrieve"><a href="#2、查询-Retrieve" class="headerlink" title="2、查询(Retrieve)"></a>2、查询(Retrieve)</h2><h4 id="1-数据库-1"><a href="#1-数据库-1" class="headerlink" title="1.数据库"></a>1.数据库</h4><ul>
<li>show create database name 查看创建信息</li>
</ul>
<hr>
<h4 id="2-数据表-1"><a href="#2-数据表-1" class="headerlink" title="2.数据表"></a>2.数据表</h4><hr>
<pre><code class="hljs sql">- <span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>; 显示表
- <span class="hljs-keyword">describe</span> tablename;或者 desc tablename； 查看表结构
- <span class="hljs-keyword">select</span> 中加上<span class="hljs-keyword">distinct</span>去除重复字段
- <span class="hljs-keyword">select</span> 列名<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span> <span class="hljs-keyword">from</span> 表名字；查询
- <span class="hljs-keyword">select</span> 列名<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span> <span class="hljs-keyword">from</span> 表名字 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 列名<span class="hljs-number">1</span> <span class="hljs-keyword">ASC</span>,列名 <span class="hljs-keyword">DESC</span>；  排序查询（列名<span class="hljs-number">1</span>升序，相同则按列名<span class="hljs-number">2</span>降序）
- <span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(列名或*) <span class="hljs-keyword">from</span> tablename; 查询有多少条数据（排除null）
- <span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-keyword">IFNULL</span>(列名，值)) <span class="hljs-keyword">from</span> wxxs;把值赋给null，然后统计数据条数
- <span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(列名或*) <span class="hljs-keyword">from</span> tablename;列最大值
- <span class="hljs-keyword">select</span> <span class="hljs-keyword">min</span>(列名或*) <span class="hljs-keyword">from</span> tablename;列最小值
- <span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(列名或*) <span class="hljs-keyword">from</span> tablename;列平均值
- <span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(列名或*) <span class="hljs-keyword">from</span> tablename;列的和
- <span class="hljs-keyword">select</span> sex,<span class="hljs-keyword">avg</span>(age) <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sex;按照性别分组查询，男女平均年龄
- <span class="hljs-keyword">select</span> sex,<span class="hljs-keyword">avg</span>(age),<span class="hljs-keyword">count</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sex <span class="hljs-keyword">where</span> age&gt;<span class="hljs-number">20</span> <span class="hljs-keyword">having</span> <span class="hljs-keyword">count</span>(<span class="hljs-keyword">id</span>)&gt;<span class="hljs-number">2</span>;按照性别分组查询，男女平均年龄,除去年龄大于20岁的，分组后现在数量大于2个的；where用在分组前（不可跟聚合函数（sum之类）），having用在分租后；
- <span class="hljs-keyword">select</span> sex,<span class="hljs-keyword">avg</span>(age),<span class="hljs-keyword">count</span>(<span class="hljs-keyword">id</span>) **<span class="hljs-keyword">num</span>** <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sex <span class="hljs-keyword">where</span> age&gt;<span class="hljs-number">20</span> <span class="hljs-keyword">having</span> **<span class="hljs-keyword">num</span>**&gt;<span class="hljs-number">2</span>; 别名
- <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">limit</span> 开始索引，一页显示条数;分页查询；
- <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">between</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">10</span>;查询id为5到10的
- <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);查询id为5和10的数据
- <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">is</span> (<span class="hljs-keyword">not</span>) <span class="hljs-literal">null</span>;查询id为（非）空的数据
- <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;_张%&#x27;</span>；_匹配一个字符，%匹配多个字符；</code></pre>
<h2 id="3、删除-Delete"><a href="#3、删除-Delete" class="headerlink" title="3、删除(Delete)"></a>3、删除(Delete)</h2><h4 id="1-数据库-2"><a href="#1-数据库-2" class="headerlink" title="1.数据库"></a>1.数据库</h4><pre><code class="hljs sql">- <span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">name</span> ;直接删除数据库，不提醒
- <span class="hljs-keyword">drop</span> datebase <span class="hljs-keyword">name</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>; 存在则删除数据库
- mysqladmin <span class="hljs-keyword">drop</span> databasename 删除数据库前，有提示。</code></pre>
<hr>
<h4 id="2-数据表-2"><a href="#2-数据表-2" class="headerlink" title="2.数据表"></a>2.数据表</h4><pre><code class="hljs sql">- <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名字 <span class="hljs-keyword">where</span> 条件；删除满足条件的数据
- <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名; 删除所有数据（效率低）
- <span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> 表名字；清空表数据（实际是删除再创建，效率高）</code></pre>
<hr>
<h2 id="4、修改（Update）"><a href="#4、修改（Update）" class="headerlink" title="4、修改（Update）"></a>4、修改（Update）</h2><h4 id="1-数据库-3"><a href="#1-数据库-3" class="headerlink" title="1.数据库"></a>1.数据库</h4><ul>
<li><code>alter datebase name character set utf8; 修改编码</code></li>
</ul>
<hr>
<h4 id="2-数据表-3"><a href="#2-数据表-3" class="headerlink" title="2.数据表"></a>2.数据表</h4><hr>
<pre><code class="hljs sql">- <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> NewName;修改表名字
- <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8; 修改编码
- <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">add</span> 列名 数据类型;增加一列
- <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">change</span> 列名 新列名 新数据类型; 修改列
- <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">modify</span> 列名 数据类型; 修改列数据类型
- <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">drop</span> 列名； 删除列
- uptate tablename <span class="hljs-keyword">set</span> 行名=值，行名=值 <span class="hljs-keyword">where</span> 条件; 修改满足条件的值
- uptate tablename <span class="hljs-keyword">set</span> 行名=值；修改指定列名的所有数据位指定值</code></pre>

<h2 id="5、使用数据库"><a href="#5、使用数据库" class="headerlink" title="5、使用数据库"></a>5、使用数据库</h2><ul>
<li>use databasename; 选择数据库</li>
<li>select database(); 查看当前使用的数据库</li>
<li>select version(),current_date; 显示当前mysql版本和当前日期</li>
</ul>
<hr>
<h2 id="6、约束"><a href="#6、约束" class="headerlink" title="6、约束"></a>6、约束</h2><p>非空约束 not null；创建表时添加，或者使用alter添加/删除（alter table 表名 modify 列名 数据类型 not null），删除时不加not null即可；<br>唯一约束 unique；可以有多个null，创建表时添加，或者使用alter添加/删除（alter table 表名 drop index 列名），添加和非空约束一样；<br>主键约束 primary key；添加auto——increment可实现自增长，alter添加/删除与not null一样格式；<br>外键约束 foreign key；</p>
<h5 id="a-创建表时添加"><a href="#a-创建表时添加" class="headerlink" title="a.创建表时添加"></a>a.创建表时添加</h5><p> <code>constraint 外健名称 foreign key 外键列名称 references 主表名称（主表列名称）；</code></p>
<h5 id="b-创建后alter添加"><a href="#b-创建后alter添加" class="headerlink" title="b.创建后alter添加"></a>b.创建后alter添加</h5><p> <code>alter table tablename constraint 外健名称 foreign key 外键列名称 references 主表名称（主表列名称）;</code></p>
<h5 id="c-删除"><a href="#c-删除" class="headerlink" title="c.删除"></a>c.删除</h5><p> <code>alter table tablename drop foreign key 外键名字；</code></p>
<h5 id="d-级联-更新-删除"><a href="#d-级联-更新-删除" class="headerlink" title="d.级联 更新/删除"></a>d.级联 更新/删除</h5><p> <code>alter table tablename constraint 外健名称 foreign key 外键列名称 references 主表名称（主表列名称）on update cascade on delete cascade;</code><br> 主表删除从表数据也被删除，更新同理</p>
<h2 id="7、多表查询"><a href="#7、多表查询" class="headerlink" title="7、多表查询"></a>7、多表查询</h2><h5 id="A、内连接查询"><a href="#A、内连接查询" class="headerlink" title="A、内连接查询"></a>A、内连接查询</h5><ul>
<li>a.隐式内连接<br>select * from 表一名，表二名 where 条件；</li>
<li>b.显示内连接<br>select * from 表一名 别名1 (inner) join 表二名 别名2 on 条件;<br>select * from table1 w (inner) join table2 m on w.id=m.id;<h5 id="B、外连接查询"><a href="#B、外连接查询" class="headerlink" title="B、外连接查询"></a>B、外连接查询</h5></li>
<li>a.左外连接<br>select 字段列表 from 表一名 left （outer） join 表二 on 条件；<br>查询左表全部，加上右表与左边交集；</li>
<li>b.又外连接<br>select 字段列表 from 表一名 right （outer） join 表二 on 条件；<br>查询又表全部，加上左表与右边交集；<h5 id="C、子查询"><a href="#C、子查询" class="headerlink" title="C、子查询"></a>C、子查询</h5>把查询语句当成条件使用来进行查询<br>a。子查询结果是单行单列的<br>b。子查询结果是单行多列的<br>c。子查询的结果是多行多列的</li>
</ul>
<hr>
<h2 id="8、事务"><a href="#8、事务" class="headerlink" title="8、事务"></a>8、事务</h2><h5 id="a-基本操作"><a href="#a-基本操作" class="headerlink" title="a.基本操作"></a>a.基本操作</h5><p>事务开启（start transaction），执行sql，发现错误回滚事务(rollback)，没出错提交事务(commit)；<br>select @@autocommit;查看自动提交， 1为自动0为手动；<br>set @@autocommit=0;设置为手动提交</p>
<h5 id="b-事务的四大特征"><a href="#b-事务的四大特征" class="headerlink" title="b.事务的四大特征"></a>b.事务的四大特征</h5><ol>
<li>隔离性：多个事务之间，相互隔离。</li>
<li>原子性：是不可分割的，要么同时成功，要么同时失败。</li>
<li>持久性：事务提交或者回滚之后，数据会持久化保存。</li>
<li>一致性：数据总量不变。例如转账</li>
</ol>
<hr>
<h5 id="c-事务的隔离级别"><a href="#c-事务的隔离级别" class="headerlink" title="c.事务的隔离级别"></a>c.事务的隔离级别</h5><ol>
<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</li>
<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。<br><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></li>
</ol>
<ul>
<li>事务隔离级别    脏读    不可重复读    幻读</li>
<li>读未提交（read-uncommitted）    是    是    是</li>
<li>不可重复读（read-committed）    否    是    是</li>
<li>可重复读（repeatable-read）    否    否    是</li>
<li>串行化（serializable）    否    否    否</li>
</ul>
<p>查询隔离级别：select @@tx_isolation;<br>设置隔离级别：set global transaction isolation level 级别名；</p>
<h2 id="9、用户模块"><a href="#9、用户模块" class="headerlink" title="9、用户模块"></a>9、用户模块</h2><h3 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1.用户管理"></a>1.用户管理</h3><h5 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1.添加用户"></a>1.添加用户</h5><p>create user ‘用户名‘@’主机名’ identified by ‘密码’;</p>
<h5 id="2-删除用户"><a href="#2-删除用户" class="headerlink" title="2.删除用户"></a>2.删除用户</h5><p>drop user ‘用户名‘@’主机名’;</p>
<h5 id="3-修改密码"><a href="#3-修改密码" class="headerlink" title="3.修改密码"></a>3.修改密码</h5><p>update user set passward=passward(‘新密码’) where user=’用户名’;<br>set password for ‘用户名‘@’localhost’= password(‘新密码’);</p>
<h5 id="4-重置root密码"><a href="#4-重置root密码" class="headerlink" title="4.重置root密码"></a>4.重置root密码</h5><p>停止mysql服务（net stop mysql）-&gt;管理员执行（mysqld -skip-grant-tables）-&gt;新开窗口cmd（mysql）-&gt;修改密码；</p>
<h5 id="5-查询用户"><a href="#5-查询用户" class="headerlink" title="5.查询用户"></a>5.查询用户</h5><p>select (host,user,passeword) from user;</p>
<h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h3><h5 id="1-查询权限"><a href="#1-查询权限" class="headerlink" title="1.查询权限"></a>1.查询权限</h5><p>show grants for ‘用户名‘@’主机名’</p>
<h5 id="2-授予权限"><a href="#2-授予权限" class="headerlink" title="2.授予权限"></a>2.授予权限</h5><p>grant 权限列表 on 数据库名.数据表名 to ‘用户名‘@’主机名’<br>grant ALL on <em>.</em> to ‘用户名‘@’主机名’;给全部权限；<br>grant update,select on 数据库名.数据表名 to ‘用户名‘@’主机名’;给特定表更新查询权限；</p>
<h5 id="3-撤销权限"><a href="#3-撤销权限" class="headerlink" title="3.撤销权限"></a>3.撤销权限</h5><p>revoke  权限列表 on 数据库名.数据表名 from ‘用户名‘@’主机名’<br>revoke ALL on <em>.</em> from ‘用户名‘@’主机名’;撤销全部权限；<br>revoke update,select on 数据库名.数据表名 from ‘用户名‘@’主机名’;撤销特定表更新查询权限；</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>指令集</tag>
      </tags>
  </entry>
  <entry>
    <title>通用小说爬虫思路及JAVA实现</title>
    <url>/Java/%E5%85%B6%E4%BB%96/%E9%80%9A%E7%94%A8%E5%B0%8F%E8%AF%B4%E7%88%AC%E8%99%AB%E6%80%9D%E8%B7%AF%E5%8F%8AJAVA%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<p>前面不是写了个小说爬虫吗，然后就觉得维护起来比较麻烦。想弄一个通用的经过我的构想，觉得还是用正则匹配才行。首先用正则提取了正文，记过我在多个网站的测试，已经差不多可以适配大多数了贴下正则</p>
<pre><code class="hljs java"><span class="hljs-comment">//正则抓取内容</span>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//String pinyin=&quot;āáǎàēéěèīíǐìōóǒA8B0òūúǔùǖǘǚǜüê&quot;;</span>
        String ch_punctuation=<span class="hljs-string">&quot;~。\\u000A\\u0009\\u00A0\\u0020\\u3000&quot;</span>;
        <span class="hljs-comment">//String punctuation=&quot;[\\-,\\/,\\|,\\$,\\+,\\%,\\&amp;,\\&#x27;,\\(,\\),\\*,\\x20-\\x2f,\\x3a-\\x40,\\x5b-\\x60,\\x7b-\\x7e,\\x80-\\xff,\\u3000-\\u3002,\\u300a,\\u300b,\\u300e-\\u3011,\\u2014,\\u2018,\\u2019,\\u201c,\\u201d,\\u2026,\\u203b,\\u25ce,\\uff01-\\uff5e,\\uffe5]&quot;;</span>
        <span class="hljs-comment">//String eh_punctuation=&quot;\\u003A\\u0028\\u201C\\uFF0C\\uFF1F\\u3001\\u201D\\uFF01\\uFF1A\\u223C\\u003D\\u2026&quot;;</span>
        String unicode_azAZ09=<span class="hljs-string">&quot;\\uFF41-\\uFF5a\\uFF21-\\uFF3a\\uFF10-\\uFF19&quot;</span>;
        String chinese=<span class="hljs-string">&quot;\\u4E00-\\u9FFF&quot;</span>;
        String html = <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-keyword">try</span> &#123;
            html = SpiderUtils.getSource(<span class="hljs-string">&quot;https://www.88dush.com/xiaoshuo/37/37125/20723618.html&quot;</span>);
            <span class="hljs-comment">//System.out.println(html);</span>
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
        Pattern compile = Pattern.compile(<span class="hljs-string">&quot;[pvr/\&quot;]&gt;[^字\\w&lt;*][\\pP\\w\\pN\\pL\\pM&quot;</span>
                +unicode_azAZ09+chinese+ch_punctuation
                    + <span class="hljs-string">&quot;]&#123;3,&#125;[^字\\w&gt;]&#123;0,2&#125;(&lt;br|&lt;/p|&lt;/d|&lt;p)&quot;</span>);
        Matcher m=compile.matcher(html);
        <span class="hljs-keyword">while</span>(m.find()) 
            String reString=m.group(<span class="hljs-number">0</span>).replace(<span class="hljs-string">&quot;\r\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&lt;br&quot;</span>, <span class="hljs-string">&quot;\n&quot;</span>).replace(<span class="hljs-string">&quot;&lt;/p&quot;</span>, <span class="hljs-string">&quot;\n&quot;</span>)
                    .replace(<span class="hljs-string">&quot;p&gt;&quot;</span>, <span class="hljs-string">&quot;\n&quot;</span>).replaceAll(<span class="hljs-string">&quot;&amp;[a-z]&#123;3,6&#125;;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&lt;p&quot;</span>, <span class="hljs-string">&quot;\n&quot;</span>)
                    .replace(<span class="hljs-string">&quot;/&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;r&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;　&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&lt;/d&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;v&gt;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)
                    .replace(<span class="hljs-string">&quot;\&quot;&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;　&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).trim();
            <span class="hljs-keyword">if</span>(reString.length()&gt;<span class="hljs-number">0</span>) &#123;
                System.out.println(reString);
            &#125;
        &#125;
    &#125;</code></pre>

<p>基本实现了提取小说正文的功能，然后就是提取小说目录链接了</p>
<pre><code class="hljs java"><span class="hljs-comment">//抓Chapter</span>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestEncode</span><span class="hljs-params">()</span> </span>&#123;
        String html = <span class="hljs-string">&quot;&quot;</span>;
        String chinese=<span class="hljs-string">&quot;\\u4E00-\\u9FFF&quot;</span>;
        String url=<span class="hljs-string">&quot;https://www.88dush.com/xiaoshuo/37/37125/&quot;</span>;
        <span class="hljs-keyword">try</span> &#123;
            html = SpiderUtils.getSource(url);
<span class="hljs-comment">//          System.out.println(html);</span>
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
        Pattern compile = Pattern.compile(<span class="hljs-string">&quot;\&lt;\a href=\&quot;([\\w./-]+?)\&quot;.*?&gt;([&quot;</span>+chinese+<span class="hljs-string">&quot; \\d\\pP]+?)&lt;/a&quot;</span>);
        Matcher m=compile.matcher(html);
        <span class="hljs-keyword">while</span>(m.find()) &#123;   
<span class="hljs-comment">//          String reString=m.group(0).trim();</span>
            String re1=m.group(<span class="hljs-number">1</span>).trim();
            String re2=m.group(<span class="hljs-number">2</span>).trim();
            <span class="hljs-keyword">if</span>(re1.length()&gt;<span class="hljs-number">5</span>&amp;&amp;re2.length()&gt;<span class="hljs-number">5</span>) &#123;
                System.out.println(SpiderUtils.GetAbsUrl(url,re1)+<span class="hljs-string">&quot;--------&quot;</span>+re2);
            &#125;
        &#125;
    &#125;</code></pre>

<p>这个提取没有正文那么精细了，还可以改进<br>这样就基本实现了，给一个小说目录就可以爬取整本小说的目的<br>这是我的思路，就是匹配汉字来筛选正文<br>匹配a标签加标题来实现目录链接提取</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Java</tag>
        <tag>一些娱乐代码</tag>
      </tags>
  </entry>
  <entry>
    <title>解决MySQL不到中文数据</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%A7%A3%E5%86%B3MySQL%E4%B8%8D%E5%88%B0%E4%B8%AD%E6%96%87%E6%95%B0%E6%8D%AE.html</url>
    <content><![CDATA[<p>查询数据库编码<br>show variables like ‘%char%’<br>如果其中含有Latin1而不是utf-8则不是正确的</p>
<p>解决方法<br>修改mysql配置文件<br>vim /etc/my.cnf</p>
<p>如果没有就手动加入<br>[mysqld]下加入<br>datadir=/var/lib/mysql<br>socket=/var/lib/mysql/mysql.sock<br>user=mysql<br>symbolic-links=0<br>character-set-server=utf8<br>init_connect=’SET NAMES utf8’</p>
<p>[client]<br>default-character-set=utf8</p>
<p>[mysql]<br>no-auto-rehash<br>default-character-set=utf8</p>
<p>[mysqld_safe]<br>log-error=/var/log/mysqld.log<br>pid-file=/var/run/mysqld/mysqld.pid</p>
<p>systemctl restart mysqld</p>
<p>然后再查询数据库的编码</p>
<p>以前的latin1都变成了utf-8的格式</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaFX的GridPane实现自适应</title>
    <url>/Java/javaFX/JavaFX%E7%9A%84GridPane%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94.html</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>因为最近想做一个书架一样得东西所以需要用到这个，有没有找到合适的，索性自己写一个</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.unclez.ui.view;

<span class="hljs-keyword">import</span> javafx.application.Application;
<span class="hljs-keyword">import</span> javafx.fxml.FXMLLoader;
<span class="hljs-keyword">import</span> javafx.scene.Scene;
<span class="hljs-keyword">import</span> javafx.scene.control.Label;
<span class="hljs-keyword">import</span> javafx.scene.layout.*;
<span class="hljs-keyword">import</span> javafx.stage.Stage;
<span class="hljs-keyword">import</span> top.unclez.ui.util.StageUtil;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookMark</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        launch(args);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Stage stage)</span> </span>&#123;
        stage.setTitle(<span class="hljs-string">&quot;GRIDPANE 自适应&quot;</span>);
        FXMLLoader loader = <span class="hljs-keyword">new</span> FXMLLoader();
        GridPane pane= <span class="hljs-keyword">new</span> GridPane();
        pane.setHgap(<span class="hljs-number">10</span>);
        pane.setVgap(<span class="hljs-number">10</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++)&#123;
                Label label=<span class="hljs-keyword">new</span> Label(<span class="hljs-string">&quot;UNCLE&quot;</span>);
                GridPane.setHgrow(label,Priority.ALWAYS);
                GridPane.setVgrow(label,Priority.ALWAYS);
                pane.add(label,i,j);
            &#125;
        StageUtil.showStage(stage,<span class="hljs-keyword">new</span> Scene(pane));
    &#125;
&#125;
</code></pre>

<p>这样就实现了自适应布局<br><img src="https://img-blog.csdnimg.cn/20181229210304363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20181229210304363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA2MTIw,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaFX</category>
      </categories>
      <tags>
        <tag>JavaFX</tag>
        <tag>GridPane</tag>
        <tag>自适应</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中final关键词详解</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/Java%E4%B8%ADfinal%E5%85%B3%E9%94%AE%E8%AF%8D%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>final 关键字看上去简单，但是真正深入理解的人可以说少之又少，读完本文你就知道我在说什么了。本文将常规的用法简化，提出一些用法和深入的思考。<br>可能 </p>
<h2 id="不同的作用域"><a href="#不同的作用域" class="headerlink" title="不同的作用域"></a>不同的作用域</h2><h3 id="作用与类"><a href="#作用与类" class="headerlink" title="作用与类"></a>作用与类</h3><p>当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p>
<p><strong>注意：</strong> final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。</p>
<h3 id="作用于方法"><a href="#作用于方法" class="headerlink" title="作用于方法"></a>作用于方法</h3><ul>
<li>private 方法是隐式的final</li>
<li>final方法是可以被重载的</li>
</ul>
<h3 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h3><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>
<h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><blockquote>
<p>常规的用法比较简单，这里通过下面三个问题进一步说明。</p>
</blockquote>
<p><strong>1. 编译期常量和非编译期常量</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-comment">//编译期常量</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> J = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;
    <span class="hljs-comment">//非编译期常量</span>
    Random r = <span class="hljs-keyword">new</span> Random();
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> k = r.nextInt();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

    &#125;
&#125;</code></pre>

<p>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</p>
<p><strong>2. static final</strong></p>
<p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，或者在静态代码块进行赋值，否则编译器将不予通过。</p>
<p><strong>3. blank final</strong></p>
<p>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段，但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p>
<ul>
<li>在定义处进行赋值(这不叫空白final) </li>
<li>在构造器中进行赋值，保证了该值在被使用前赋值。 </li>
</ul>
<p>这增强了final的灵活性。</p>
<h2 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h2><p>按照final修饰的数据类型分类： </p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。 </li>
<li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。 </li>
</ul>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</p>
<h2 id="final的实现原理"><a href="#final的实现原理" class="headerlink" title="final的实现原理"></a>final的实现原理</h2><p>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p>
<p> 很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合之HashMap与ConcurrentHashMap</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E4%B8%8EConcurrentHashMap.html</url>
    <content><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在JDK1.7时，底层是由数组+链表与拉链法解决冲突的。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200912101312.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200912101312.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>在JDK1.8时，底层是由数组+链表与拉链法+链表长度为8时转为红黑树。但是红黑树节点少于6时退化为链表。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726194810.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200726194810.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>


<h3 id="添加元素的时间复杂度"><a href="#添加元素的时间复杂度" class="headerlink" title="添加元素的时间复杂度"></a>添加元素的时间复杂度</h3><p>put操作的流程：</p>
<p>第一步：key.hashcode()，时间复杂度O(1)。</p>
<p>第二步：找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度<strong>O(1)</strong>。</p>
<p>第三步：如果桶里有元素，并且元素个数小于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(n)=<strong>O(n)</strong>。</p>
<p>第四步：如果桶里有元素，并且元素个数大于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(logn)=O(logn)。红黑树查询的时间复杂度是<strong>logn</strong>。</p>
<p>通过上面的分析，我们可以得出结论，HashMap新增元素的时间复杂度是不固定的，可能的值有O(1)、O(logn)、O(n)。最好情况是O(1)，最坏情况是O(n)</p>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>扩容条件就是当threshold=loadFactory*capacity大于等于hash表当前的节点个数，HashMap采用2倍扩容。</p>
<pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    <span class="hljs-comment">//旧的容量</span>
    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;
    <span class="hljs-comment">//旧的阈值</span>
    <span class="hljs-keyword">int</span> oldThr = threshold;
    <span class="hljs-comment">//新的容量与阈值</span>
    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//如果初始化过了</span>
    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-comment">//如果旧的容量大于了最大的容量 2的30次方，装不下了，不再扩容了</span>
        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
          <span class="hljs-comment">//设置为最大，后续不再进入此方法了</span>
            threshold = Integer.MAX_VALUE;
            <span class="hljs-keyword">return</span> oldTab;
        &#125;
        <span class="hljs-comment">//两倍扩容</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>
    &#125;
    <span class="hljs-comment">//未初始化的时候</span>
    <span class="hljs-comment">//初始阈值大于0则将新的容量设置为旧的阈值</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>
        newCap = oldThr;
    <span class="hljs-comment">//否则使用默认的容量进行初始化新的容量    </span>
    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>
        newCap = DEFAULT_INITIAL_CAPACITY;
        <span class="hljs-comment">//计算新的阈值</span>
        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    <span class="hljs-comment">//计算新的阈值，如果新的阈值为0的话</span>
    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);
    &#125;
    <span class="hljs-comment">//更新新的阈值</span>
    threshold = newThr;
    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];
    table = newTab;
    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;
       <span class="hljs-comment">//遍历每个桶，拷贝到新的hash数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            <span class="hljs-comment">//如果桶不为空</span>
            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//释放以前节点的空间</span>
                oldTab[j] = <span class="hljs-keyword">null</span>;
                <span class="hljs-comment">//这个桶只有这一个节点</span>
                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)
                   <span class="hljs-comment">//直接把这个节点放到新的桶里</span>
                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;
                <span class="hljs-comment">//不只有一个节点</span>
                <span class="hljs-comment">//是树节点的时候    </span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);
                <span class="hljs-comment">//为链表的时候    </span>
                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>
                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;
                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;
                    Node&lt;K,V&gt; next;
                    <span class="hljs-comment">//遍历桶的所有节点</span>
                    <span class="hljs-keyword">do</span> &#123;
                        next = e.next;
                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;
                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)
                                loHead = e;
                            <span class="hljs-keyword">else</span>
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        <span class="hljs-keyword">else</span> &#123;
                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)
                                hiHead = e;
                            <span class="hljs-keyword">else</span>
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);

                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;
                        loTail.next = <span class="hljs-keyword">null</span>;
                        newTab[j] = loHead;
                    &#125;
                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;
                        hiTail.next = <span class="hljs-keyword">null</span>;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> newTab;
&#125;</code></pre>

<h3 id="JDK7并发情况的成环问题"><a href="#JDK7并发情况的成环问题" class="headerlink" title="JDK7并发情况的成环问题"></a>JDK7并发情况的成环问题</h3><p>在 JDK7 版本下，很多人都知道 HashMap 会有链表成环的问题，但大多数人只知道，是多线程引起的，至于具体细节的原因，和 JDK8 中如何解决这个问题，很少有人说的清楚，百度也几乎看不懂，本文就和大家聊清楚两个问题：</p>
<ol>
<li>JDK7 中 HashMap 成环原因，2</li>
<li>JDK8 中是如何解决的。</li>
</ol>
<p>成环核心原因在JDK7的transfer方法。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-keyword">boolean</span> rehash)</span> </span>&#123;
    <span class="hljs-keyword">int</span> newCapacity = newTable.length;
    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;
        <span class="hljs-comment">//e为空时循环结束</span>
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) &#123;
            Entry&lt;K,V&gt; next = e.next;
            <span class="hljs-keyword">if</span> (rehash) &#123;
                e.hash = <span class="hljs-keyword">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);
            &#125;
            <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);
            <span class="hljs-comment">// 成环的代码主要是在这三行代码</span>
            <span class="hljs-comment">// 首先插入是从头开始插入的</span>
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        &#125;
    &#125;
&#125;</code></pre>

<p>JDK8中的扩容方法，重新写了，为resize，链表扩容的核心代码：</p>
<pre><code class="hljs java"><span class="hljs-comment">// loHead 表示老值,老值的意思是扩容后，该链表中计算出索引位置不变的元素</span>
<span class="hljs-comment">// hiHead 表示新值，新值的意思是扩容后，计算出索引位置发生变化的元素</span>
<span class="hljs-comment">// 举个例子，数组大小是 8 ，在数组索引位置是 1 的地方挂着一个链表，链表有两个值，两个值的 hashcode 分别是是9和33。</span>
<span class="hljs-comment">// 当数组发生扩容时，新数组的大小是 16，此时 hashcode 是 33 的值计算出来的数组索引位置仍然是 1，我们称为老值</span>
<span class="hljs-comment">// hashcode 是 9 的值计算出来的数组索引位置是 9，就发生了变化，我们称为新值。</span>
Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;
Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;
Node&lt;K,V&gt; next;
<span class="hljs-keyword">do</span> &#123;
    next = e.next;
    <span class="hljs-comment">// (e.hash &amp; oldCap) == 0 表示老值链表</span>
    <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)
            loHead = e;
        <span class="hljs-keyword">else</span>
            loTail.next = e;
        loTail = e;
    &#125;
    <span class="hljs-comment">// (e.hash &amp; oldCap) != 0 表示新值链表</span>
    <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)
            hiHead = e;
        <span class="hljs-keyword">else</span>
            hiTail.next = e;
        hiTail = e;
    &#125;
&#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);
<span class="hljs-comment">// 老值链表赋值给原来的数组索引位置</span>
<span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;
    loTail.next = <span class="hljs-keyword">null</span>;
    newTab[j] = loHead;
&#125;
<span class="hljs-comment">// 新值链表赋值到新的数组索引位置</span>
<span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;
    hiTail.next = <span class="hljs-keyword">null</span>;
    newTab[j + oldCap] = hiHead;
&#125;</code></pre>

<p>总的来说，就是将每个桶的节点的hash值遍历出来，如果hash与oldCap取模为0，则表示数据不需要移动桶位置，如果不为0，则在桶的位置为 当前桶的索引+oldCap，举例解释：</p>
<p>oldCap=16，新的容量2倍扩容为32，遍历每个桶，当两个hashcode分别为5和21，在容量为16的时候，都在索引为5的桶，扩容为32时，相当于高位补了1，所以如果hashcode与olcCap取模后不再是以前的位置了则代表新位置为oldcap+oldIndex</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200918105724.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200918105724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p><strong>总结</strong></p>
<p>JDK7 是在 while 循环里面，单个计算好数组索引位置后，单个的进行头插法插入数组中，在多线程情况下，会有成环问题</p>
<p>JDK8 ，改用尾插法，是等链表整个 while 循环结束后，才给数组赋值，所以多线程情况下，也不会成环</p>
<p>推荐阅读：<a href="https://www.cnblogs.com/wen-he/p/11496050.html">HashMap链表成环的原因和解决方案</a></p>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;
        <span class="hljs-keyword">int</span> h;
        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
    &#125;</code></pre>

<p>可以看到把hashcode的高16位与低16位进行了异或运算，这样做的好处就是让低16位中包含了高16位的特征，尽量避免了hash冲突。</p>
<p>之所以只取16位还有一个原因，那就是因为最终取模运算使用的是 （n-1）&amp; hashcode方式代替%，之所以能够代替是因为n为2^x方。所以在容量比较少的时候，都是取的低16位的结果。</p>
<h3 id="转化为红黑树及退化成链表原因"><a href="#转化为红黑树及退化成链表原因" class="headerlink" title="转化为红黑树及退化成链表原因"></a>转化为红黑树及退化成链表原因</h3><h4 id="链表长度为8转化为红黑树原因"><a href="#链表长度为8转化为红黑树原因" class="headerlink" title="链表长度为8转化为红黑树原因"></a>链表长度为8转化为红黑树原因</h4><p>HashMap源码中可以看到：</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200912104417.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200912104417.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>这个其实就是泊松分布，节点的分布频率会遵循泊松分布，链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。</p>
<p>还有就是红黑树的平均查找长度为O(logn)而链表为O(n)</p>
<h4 id="节点个数少于6退化链表原因"><a href="#节点个数少于6退化链表原因" class="headerlink" title="节点个数少于6退化链表原因"></a>节点个数少于6退化链表原因</h4><ul>
<li>为什么转化为红黑树的阈值8和转化为链表的阈值6不一样，是为了避免频繁来回转化。</li>
<li>退化是为了节省空间，红黑树占用的空间是链表的两倍。</li>
</ul>
<p>首先得注意，网上说的到小于6退化为链表是分时机的，在移除节点的时候并不会判断小于6进行退化成链表，这个退化过程发生在resize中，为树节点的时候调用的spilt方法中进行的。</p>
<p>在remove的时候，通过红黑树根节点及其子节点是否为空来判断是否需要退化。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeTreeNode</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,<span class="hljs-keyword">boolean</span>  movable)</span> </span>&#123;
     <span class="hljs-comment">//只贴核心代码</span>
     <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || (movable &amp;&amp; (root.right == <span class="hljs-keyword">null</span> || (rl = root.left) == <span class="hljs-keyword">null</span>|| rl.left == <span class="hljs-keyword">null</span>))) &#123;
               tab[index] = first.untreeify(map);  <span class="hljs-comment">// too small</span>
               <span class="hljs-keyword">return</span>;
           &#125;
&#125;</code></pre>

<p>resize的时候，对红黑树进行了拆分</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bit)</span> </span>&#123;
      TreeNode&lt;K,V&gt; b = <span class="hljs-keyword">this</span>;
      <span class="hljs-comment">// Relink into lo and hi lists, preserving order</span>
      TreeNode&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;
      TreeNode&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-keyword">null</span>; e = next) &#123;
          next = (TreeNode&lt;K,V&gt;)e.next;
          e.next = <span class="hljs-keyword">null</span>;
          <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;
              <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-keyword">null</span>)
                  loHead = e;
              <span class="hljs-keyword">else</span>
                  loTail.next = e;
              loTail = e;
              ++lc;
          &#125;
          <span class="hljs-keyword">else</span> &#123;
              <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-keyword">null</span>)
                  hiHead = e;
              <span class="hljs-keyword">else</span>
                  hiTail.next = e;
              hiTail = e;
              ++hc;
          &#125;
      &#125;
      <span class="hljs-comment">//在这之前的逻辑是将红黑树每个节点的hash和一个bit进行&amp;运算，</span>
      <span class="hljs-comment">//根据运算结果将树划分为两棵红黑树，lc表示其中一棵树的节点数</span>
      <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>) &#123;
          <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)
              tab[index] = loHead.untreeify(map);
          <span class="hljs-keyword">else</span> &#123;
              tab[index] = loHead;
              <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// (else is already treeified)</span>
                  loHead.treeify(tab);
          &#125;
      &#125;
      <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) &#123;
          <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)
              tab[index + bit] = hiHead.untreeify(map);
          <span class="hljs-keyword">else</span> &#123;
              tab[index + bit] = hiHead;
              <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>)
                  hiHead.treeify(tab);
          &#125;
      &#125;
  &#125;</code></pre>
<p>这里才用到了 UNTREEIFY_THRESHOLD 的判断，当红黑树节点元素小于等于6时，才调用untreeify方法转换回链表</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p> JDK7底层实现线程线程安全是通过分段锁Segment，继承自ReentrantLock。<br> JDK8底层改为CAS+Synchronized实现。</p>
<p>首先使用添加一个元素的时候，发现这个元素对应的Buket是空的，则通过CAS进行添加Buket的第一个元素。<br>如果元素的对应的Buket的不为空则通过同步代码块进行并发同步控制。</p>
<p>升级原因：</p>
<ul>
<li>减少内存开销:如果使用ReentrantLock则需要节点继承AQS来获得同步支持，增加内存开销，而1.8中只有头节点需要进行同步。</li>
<li>synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性之函数式接口</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.html</url>
    <content><![CDATA[<h2 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h2><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。可以通过增加@FunctionalInterface注解进行编译时判断。</p>
<h2 id="JDK提供的函数式接口"><a href="#JDK提供的函数式接口" class="headerlink" title="JDK提供的函数式接口"></a>JDK提供的函数式接口</h2><img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200928151158.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200928151158.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>可以看到JDK提供了大量的函数式接口</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>故名思意就是提供给你一个对象然后你只需要做对应的处理，也可以说是消费即可。</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; after)</span> </span>&#123;
        Objects.requireNonNull(after);
        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;
    &#125;
&#125;</code></pre>

<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>可以当作一个供应商一样，只负责传值</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>

<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>断言，也就是传入一个值返回对应的true/false，也可以链式调用</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(aAndB(n -&gt; n &lt; <span class="hljs-number">101</span>, n -&gt; n &gt; <span class="hljs-number">10</span>));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">aAndB</span><span class="hljs-params">(Predicate&lt;Integer&gt; a, Predicate&lt;Integer&gt; b)</span></span>&#123;
        <span class="hljs-keyword">return</span> a.and(b).test(<span class="hljs-number">100</span>);
    &#125;
&#125;
</code></pre>

<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>也就是通过接受一个值，处理过后返回一个值</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;
    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;
&#125;</code></pre>

<h2 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h2><p>在JDK中，只要接口只有一个抽象方法即可当作函数式接口，也就是说我们可以不加@FunctionalInterface</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyConsumer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doIt</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>

<p>当然如果加上了则会在编译的时候自动判断是否定义正确的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>lamda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中注解Annotation概念及原理</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E6%B3%A8%E8%A7%A3Annotation%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Annontation是Java5开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p>
<p>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p>
<h2 id="注解的用处"><a href="#注解的用处" class="headerlink" title="注解的用处"></a>注解的用处</h2><ol>
<li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能。</li>
<li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：<br>@Documented – 注解是否将包含在JavaDoc中<br>@Retention – 什么时候使用该注解<br>@Target – 注解用于什么地方<br>@Inherited – 是否允许子类继承该注解</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>定义该注解的生命周期</p>
<ul>
<li>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</li>
<li>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li>
<li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li>
</ul>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括</p>
<ul>
<li>ElementType.CONSTRUCTOR: 用于描述构造器</li>
<li>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</li>
<li>ElementType.LOCAL_VARIABLE: 用于描述局部变量</li>
<li>ElementType.METHOD: 用于描述方法</li>
<li>ElementType.PACKAGE: 用于描述包</li>
<li>ElementType.PARAMETER: 用于描述参数</li>
<li>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</li>
</ul>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java 文档中。</p>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>定义该注释和子类的关系<br>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Java反射原理</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/%E6%B5%85%E8%B0%88Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java 反射主要提供以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<p>重点：是运行时而不是编译时</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="反射的优点"><a href="#反射的优点" class="headerlink" title="反射的优点"></a>反射的优点</h3><ul>
<li><p><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p>
</li>
<li><p><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</p>
</li>
<li><p><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</p>
</li>
</ul>
<h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><p><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li><p><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li><p><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
</ul>
<h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><p>以下内容只供参考，不一定官方。</p>
<p>反射原理就是将类的.class文件进行类加载进入JVM，得到了对应的Class对象，然后通过class对象及参数个数获得方法、属性、成员之类的，再通过invoke方法调用。invoke方法是一个Native方法。</p>
<p>推荐阅读：<a href="https://www.jianshu.com/p/3ea4a6b57f87">深入分析Java方法反射的实现原理</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的思想OOP</title>
    <url>/Java/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3OOP.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>OOP(Object Oriented Programming)，面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。</p>
<img src="https://gitee.com/unclezs/image-blog/raw/master/blog/20200908111641.png" class="lazyload" data-srcset="https://gitee.com/unclezs/image-blog/raw/master/blog/20200908111641.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了  IS-A  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。 </p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p> Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为<strong>向上转型</strong> 。</p>
<pre><code class="hljs java">Animal animal = <span class="hljs-keyword">new</span> Cat();</code></pre>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态:</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件:</p>
<ul>
<li>继承</li>
<li>覆盖(重写)</li>
<li>向上转型</li>
</ul>
<h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><h3 id="单一职责原则SRP-Single-Responsibility-Principle"><a href="#单一职责原则SRP-Single-Responsibility-Principle" class="headerlink" title="单一职责原则SRP(Single Responsibility Principle)"></a>单一职责原则SRP(Single Responsibility Principle)</h3><p>类的功能要单一，不能包罗万象，跟杂货铺似的。</p>
<h3 id="开放封闭原则OCP-Open－Close-Principle"><a href="#开放封闭原则OCP-Open－Close-Principle" class="headerlink" title="开放封闭原则OCP(Open－Close Principle)"></a>开放封闭原则OCP(Open－Close Principle)</h3><p>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p>
<h3 id="里式替换原则LSP-the-Liskov-Substitution-Principle-LSP"><a href="#里式替换原则LSP-the-Liskov-Substitution-Principle-LSP" class="headerlink" title="里式替换原则LSP(the Liskov Substitution Principle LSP)"></a>里式替换原则LSP(the Liskov Substitution Principle LSP)</h3><p>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</p>
<h3 id="依赖倒置原则DIP-the-Dependency-Inversion-Principle-DIP"><a href="#依赖倒置原则DIP-the-Dependency-Inversion-Principle-DIP" class="headerlink" title="依赖倒置原则DIP(the Dependency Inversion Principle DIP)"></a>依赖倒置原则DIP(the Dependency Inversion Principle DIP)</h3><p>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的是抽象的中国人，而不是你是xx村的。</p>
<h3 id="接口分离原则ISP-the-Interface-Segregation-Principle-ISP"><a href="#接口分离原则ISP-the-Interface-Segregation-Principle-ISP" class="headerlink" title="接口分离原则ISP(the Interface Segregation Principle ISP)"></a>接口分离原则ISP(the Interface Segregation Principle ISP)</h3><p>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p>
<h2 id="OOP与面向过程（POP）的区别？"><a href="#OOP与面向过程（POP）的区别？" class="headerlink" title="OOP与面向过程（POP）的区别？"></a>OOP与面向过程（POP）的区别？</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>
<p><strong>优点</strong>：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。<br><strong>缺点</strong>：不易维护、不易复用、不易扩展.</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p><strong>优点</strong>：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。</p>
<p><strong>缺点</strong>：性能比面向过程差</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
</search>
